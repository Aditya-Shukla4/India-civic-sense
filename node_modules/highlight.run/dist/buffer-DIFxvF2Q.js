var h = Object.defineProperty;
var _ = (a, t, e) => t in a ? h(a, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : a[t] = e;
var s = (a, t, e) => _(a, typeof t != "symbol" ? t + "" : t, e);
var d = (a, t, e) => new Promise((r, c) => {
  var u = (i) => {
    try {
      l(e.next(i));
    } catch (n) {
      c(n);
    }
  }, p = (i) => {
    try {
      l(e.throw(i));
    } catch (n) {
      c(n);
    }
  }, l = (i) => i.done ? r(i.value) : Promise.resolve(i.value).then(u, p);
  l((e = e.apply(a, t)).next());
});
const f = /* @__PURE__ */ Object.create(null), o = (a, t, ...e) => {
  const r = `[@launchdarkly plugins]: (${a}): `;
  console[t].apply(console, [r, ...e]), g(r, ...e);
}, L = (a, t, e, ...r) => {
  f[`${a}-${t}`] || (f[`${a}-${t}`] = !0, o(a, e, ...r));
}, g = (a, ...t) => d(void 0, null, function* () {
  try {
    const { LDObserve: e } = yield import("./LDObserve.js");
    e.recordLog(`${a}${t}`, "warn");
  } catch (e) {
  }
});
class y {
  constructor(t, e) {
    s(this, "debug");
    s(this, "name");
    this.debug = t, this.name = e;
  }
  log(...t) {
    if (this.debug) {
      let e = `[${Date.now()}]`;
      this.name && (e += ` - ${this.name}`), console.log.apply(console, [e, ...t]);
    }
  }
  warn(...t) {
    let e = `[${Date.now()}]`;
    this.name && (e += ` - ${this.name}`), console.warn.apply(console, [e, ...t]);
  }
}
class x {
  constructor() {
    s(this, "_sdk");
    s(this, "_isLoaded", !1);
    s(this, "_callBuffer", []);
    s(this, "_capacity", 1e5);
    s(this, "_droppedEvents", 0);
    s(this, "_exceededCapacity", !1);
    s(this, "_logger", new y());
  }
  _bufferCall(t, e) {
    if (this._isLoaded)
      try {
        return this._sdk[t](...e);
      } catch (r) {
        o(
          `Error executing buffered call to ${t}:`,
          "error",
          r
        );
      }
    else {
      this._enqueue({ method: t, args: e });
      return;
    }
  }
  _enqueue(t) {
    this._callBuffer.length < this._capacity ? (this._callBuffer.push(t), this._exceededCapacity = !1) : (this._exceededCapacity || (this._exceededCapacity = !0, o(
      "Exceeded event queue capacity. Increase capacity to avoid dropping events.",
      "warn"
    )), this._droppedEvents += 1);
  }
  load(t) {
    this._sdk = t, this._isLoaded = !0;
    for (const { method: e, args: r } of this._callBuffer)
      try {
        this._sdk[e](...r);
      } catch (c) {
        o(
          `Error executing buffered call to ${e}:`,
          "error",
          c
        );
      }
    this._callBuffer = [];
  }
}
export {
  x as B,
  y as L,
  L as a,
  o as i
};
//# sourceMappingURL=buffer-DIFxvF2Q.js.map
