var pa = Object.defineProperty, ma = Object.defineProperties;
var fa = Object.getOwnPropertyDescriptors;
var At = Object.getOwnPropertySymbols;
var Nr = Object.prototype.hasOwnProperty, Tr = Object.prototype.propertyIsEnumerable;
var es = (s, e, t) => e in s ? pa(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, x = (s, e) => {
  for (var t in e || (e = {}))
    Nr.call(e, t) && es(s, t, e[t]);
  if (At)
    for (var t of At(e))
      Tr.call(e, t) && es(s, t, e[t]);
  return s;
}, re = (s, e) => ma(s, fa(e));
var Qe = (s, e) => {
  var t = {};
  for (var i in s)
    Nr.call(s, i) && e.indexOf(i) < 0 && (t[i] = s[i]);
  if (s != null && At)
    for (var i of At(s))
      e.indexOf(i) < 0 && Tr.call(s, i) && (t[i] = s[i]);
  return t;
};
var k = (s, e, t) => es(s, typeof e != "symbol" ? e + "" : e, t);
var ne = (s, e, t) => new Promise((i, r) => {
  var n = (l) => {
    try {
      a(t.next(l));
    } catch (u) {
      r(u);
    }
  }, o = (l) => {
    try {
      a(t.throw(l));
    } catch (u) {
      r(u);
    }
  }, a = (l) => l.done ? i(l.value) : Promise.resolve(l.value).then(n, o);
  a((t = t.apply(s, e)).next());
});
import { z as nl, B as ba, a as Ce, S as ve, d as De, g as ts, r as Ur, G as is, b as ya, c as ga, q as Za, t as Ga, n as Kr, e as ss, f as Zt, F as Fr, V as Va, i as Sa, u as Ia, H as zr, j as Xa, k as Wa, s as Ra, L as Ca, C as wa, D as xa, E as ka, I as La, p as Ja, m as Hr, P as va, J as Ya, y as Na, K as Mr, N as Ta, O as Ua, Q as Ka, R as Fa, T as za, U as Ha, W as Ma } from "./common-B4ZaE0sS.js";
import { L as Oa, i as Fe } from "./buffer-DIFxvF2Q.js";
import { LDRecord as Pa } from "./LDRecord.js";
const Ea = {
  key: "_sid"
}, Ba = "rrweb/sequential-id@1", Qa = (s) => {
  const e = Ea;
  let t = 0;
  return {
    name: Ba,
    eventProcessor(i) {
      return Object.assign(i, {
        [e.key]: ++t
      }), i;
    },
    options: e
  };
};
var ja = Object.defineProperty, Da = (s, e, t) => e in s ? ja(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, Z = (s, e, t) => Da(s, typeof e != "symbol" ? e + "" : e, t), Or, Aa = Object.defineProperty, _a = (s, e, t) => e in s ? Aa(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, Pr = (s, e, t) => _a(s, typeof e != "symbol" ? e + "" : e, t), ie = /* @__PURE__ */ ((s) => (s[s.Document = 0] = "Document", s[s.DocumentType = 1] = "DocumentType", s[s.Element = 2] = "Element", s[s.Text = 3] = "Text", s[s.CDATA = 4] = "CDATA", s[s.Comment = 5] = "Comment", s))(ie || {});
const Er = {
  Node: ["childNodes", "parentNode", "parentElement", "textContent"],
  ShadowRoot: ["host", "styleSheets"],
  Element: ["shadowRoot", "querySelector", "querySelectorAll"],
  MutationObserver: []
}, Br = {
  Node: ["contains", "getRootNode"],
  ShadowRoot: ["getSelection"],
  Element: [],
  MutationObserver: ["constructor"]
}, _t = {}, $a = () => !!globalThis.Zone;
function nr(s) {
  if (_t[s])
    return _t[s];
  const e = globalThis[s], t = e.prototype, i = s in Er ? Er[s] : void 0, r = !!(i && // @ts-expect-error 2345
  i.every(
    (a) => {
      var l, u;
      return !!((u = (l = Object.getOwnPropertyDescriptor(t, a)) == null ? void 0 : l.get) != null && u.toString().includes("[native code]"));
    }
  )), n = s in Br ? Br[s] : void 0, o = !!(n && n.every(
    // @ts-expect-error 2345
    (a) => {
      var l;
      return typeof t[a] == "function" && ((l = t[a]) == null ? void 0 : l.toString().includes("[native code]"));
    }
  ));
  if (r && o && !$a())
    return _t[s] = e.prototype, e.prototype;
  try {
    const a = document.createElement("iframe");
    document.body.appendChild(a);
    const l = a.contentWindow;
    if (!l) return e.prototype;
    const u = l[s].prototype;
    return document.body.removeChild(a), u ? _t[s] = u : t;
  } catch (a) {
    return t;
  }
}
const rs = {};
function Me(s, e, t) {
  var i;
  const r = `${s}.${String(t)}`;
  if (rs[r])
    return rs[r].call(
      e
    );
  const n = nr(s), o = (i = Object.getOwnPropertyDescriptor(
    n,
    t
  )) == null ? void 0 : i.get;
  return o ? (rs[r] = o, o.call(e)) : e[t];
}
const ns = {};
function ll(s, e, t) {
  const i = `${s}.${String(t)}`;
  if (ns[i])
    return ns[i].bind(
      e
    );
  const n = nr(s)[t];
  return typeof n != "function" ? e[t] : (ns[i] = n, n.bind(e));
}
function qa(s) {
  return Me("Node", s, "childNodes");
}
function ec(s) {
  return Me("Node", s, "parentNode");
}
function tc(s) {
  return Me("Node", s, "parentElement");
}
function ic(s) {
  return Me("Node", s, "textContent");
}
function sc(s, e) {
  return ll("Node", s, "contains")(e);
}
function rc(s) {
  return ll("Node", s, "getRootNode")();
}
function nc(s) {
  return !s || !("host" in s) ? null : Me("ShadowRoot", s, "host");
}
function lc(s) {
  return s.styleSheets;
}
function oc(s) {
  return !s || !("shadowRoot" in s) ? null : Me("Element", s, "shadowRoot");
}
function ac(s, e) {
  return Me("Element", s, "querySelector")(e);
}
function cc(s, e) {
  return Me("Element", s, "querySelectorAll")(e);
}
function uc() {
  return nr("MutationObserver").constructor;
}
function hc(s, e, t) {
  try {
    if (!(e in s))
      return () => {
      };
    const i = s[e], r = t(i);
    return typeof r == "function" && (r.prototype = r.prototype || {}, Object.defineProperties(r, {
      __rrweb_original__: {
        enumerable: !1,
        value: i
      }
    })), s[e] = r, () => {
      s[e] = i;
    };
  } catch (i) {
    return () => {
    };
  }
}
const le = {
  childNodes: qa,
  parentNode: ec,
  parentElement: tc,
  textContent: ic,
  contains: sc,
  getRootNode: rc,
  host: nc,
  styleSheets: lc,
  shadowRoot: oc,
  querySelector: ac,
  querySelectorAll: cc,
  mutationObserver: uc,
  patch: hc
};
function ol(s) {
  return s.nodeType === s.ELEMENT_NODE;
}
function wt(s) {
  const e = (
    // anchor and textarea elements also have a `host` property
    // but only shadow roots have a `mode` property
    s && "host" in s && "mode" in s && le.host(s) || null
  );
  return !!(e && "shadowRoot" in e && le.shadowRoot(e) === s);
}
function xt(s) {
  return Object.prototype.toString.call(s) === "[object ShadowRoot]";
}
function dc(s) {
  return s.includes(" background-clip: text;") && !s.includes(" -webkit-background-clip: text;") && (s = s.replace(
    /\sbackground-clip:\s*text;/g,
    " -webkit-background-clip: text; background-clip: text;"
  )), s;
}
function pc(s) {
  const { cssText: e } = s;
  if (e.split('"').length < 3) return e;
  const t = ["@import", `url(${JSON.stringify(s.href)})`];
  return s.layerName === "" ? t.push("layer") : s.layerName && t.push(`layer(${s.layerName})`), s.supportsText && t.push(`supports(${s.supportsText})`), s.media.length && t.push(s.media.mediaText), t.join(" ") + ";";
}
function Gs(s) {
  try {
    const e = s.rules || s.cssRules;
    if (!e)
      return null;
    let t = s.href;
    !t && s.ownerNode && s.ownerNode.ownerDocument && (t = s.ownerNode.ownerDocument.location.href);
    const i = Array.from(
      e,
      (r) => al(r, t)
    ).join("");
    return dc(i);
  } catch (e) {
    return null;
  }
}
function al(s, e) {
  if (fc(s)) {
    let t;
    try {
      t = // for same-origin stylesheets,
      // we can access the imported stylesheet rules directly
      Gs(s.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement
      pc(s);
    } catch (i) {
      t = s.cssText;
    }
    return s.styleSheet.href ? Ci(t, s.styleSheet.href) : t;
  } else {
    let t = s.cssText;
    return bc(s) && s.selectorText.includes(":") && (t = mc(t)), e ? Ci(t, e) : t;
  }
}
function mc(s) {
  const e = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
  return s.replace(e, "$1\\$2");
}
function fc(s) {
  return "styleSheet" in s;
}
function bc(s) {
  return "selectorText" in s;
}
class cl {
  constructor() {
    Pr(this, "idNodeMap", /* @__PURE__ */ new Map()), Pr(this, "nodeMetaMap", /* @__PURE__ */ new WeakMap());
  }
  getId(e) {
    var t;
    if (!e) return -1;
    const i = (t = this.getMeta(e)) == null ? void 0 : t.id;
    return i != null ? i : -1;
  }
  getNode(e) {
    return this.idNodeMap.get(e) || null;
  }
  getIds() {
    return Array.from(this.idNodeMap.keys());
  }
  getMeta(e) {
    return this.nodeMetaMap.get(e) || null;
  }
  // removes the node from idNodeMap
  // doesn't remove the node from nodeMetaMap
  removeNodeFromMap(e) {
    const t = this.getId(e);
    this.idNodeMap.delete(t), e.childNodes && e.childNodes.forEach(
      (i) => this.removeNodeFromMap(i)
    );
  }
  has(e) {
    return this.idNodeMap.has(e);
  }
  hasNode(e) {
    return this.nodeMetaMap.has(e);
  }
  add(e, t) {
    const i = t.id;
    this.idNodeMap.set(i, e), this.nodeMetaMap.set(e, t);
  }
  replace(e, t) {
    const i = this.getNode(e);
    if (i) {
      const r = this.nodeMetaMap.get(i);
      r && this.nodeMetaMap.set(t, r);
    }
    this.idNodeMap.set(e, t);
  }
  reset() {
    this.idNodeMap = /* @__PURE__ */ new Map(), this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
  }
}
function yc() {
  return new cl();
}
function Wi({
  element: s,
  maskInputOptions: e,
  tagName: t,
  type: i,
  value: r,
  overwriteRecord: n,
  maskInputFn: o
}) {
  let a = r || "";
  return dl({
    maskInputOptions: e,
    tagName: t,
    type: i,
    overwriteRecord: n
  }) && (o ? a = o(a, s) : a = "*".repeat(a.length)), a;
}
function ct(s) {
  return s.toLowerCase();
}
const Qr = "__rrweb_original__";
function gc(s) {
  const e = s.getContext("2d");
  if (!e) return !0;
  const t = 50;
  for (let i = 0; i < s.width; i += t)
    for (let r = 0; r < s.height; r += t) {
      const n = e.getImageData, o = Qr in n ? n[Qr] : n;
      if (new Uint32Array(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
        o.call(
          e,
          i,
          r,
          Math.min(t, s.width - i),
          Math.min(t, s.height - r)
        ).data.buffer
      ).some((l) => l !== 0)) return !1;
    }
  return !0;
}
function Ri(s) {
  const e = s.type;
  return s.hasAttribute("data-rr-is-password") ? "password" : e ? (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
    ct(e)
  ) : null;
}
function ul(s, e) {
  var n;
  let t;
  try {
    t = new URL(s, window.location.href);
  } catch (o) {
    return null;
  }
  const i = /\.([0-9a-z]+)(?:$)/i, r = t.pathname.match(i);
  return (n = r == null ? void 0 : r[1]) != null ? n : null;
}
function Zc(s) {
  let e = "";
  return s.indexOf("//") > -1 ? e = s.split("/").slice(0, 3).join("/") : e = s.split("/")[0], e = e.split("?")[0], e;
}
const Gc = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm, Vc = /^(?:[a-z+]+:)?\/\//i, Sc = /^www\..*/i, Ic = /^(data:)([^,]*),(.*)/i;
function Ci(s, e) {
  return (s || "").replace(
    Gc,
    (t, i, r, n, o, a) => {
      const l = r || o || a, u = i || n || "";
      if (!l)
        return t;
      if (Vc.test(l) || Sc.test(l))
        return `url(${u}${l}${u})`;
      if (Ic.test(l))
        return `url(${u}${l}${u})`;
      if (l[0] === "/")
        return `url(${u}${Zc(e) + l}${u})`;
      const c = e.split("/"), h = l.split("/");
      c.pop();
      for (const p of h)
        p !== "." && (p === ".." ? c.pop() : c.push(p));
      return `url(${u}${c.join("/")}${u})`;
    }
  );
}
function $t(s, e = !1) {
  return e ? s.replace(/(\/\*[^*]*\*\/)|[\s;]/g, "") : s.replace(/(\/\*[^*]*\*\/)|[\s;]/g, "").replace(/0px/g, "0");
}
function Xc(s, e, t = !1) {
  const i = Array.from(e.childNodes), r = [];
  let n = 0;
  if (i.length > 1 && s && typeof s == "string") {
    let o = $t(s, t);
    const a = o.length / s.length;
    for (let l = 1; l < i.length; l++)
      if (i[l].textContent && typeof i[l].textContent == "string") {
        const u = $t(
          i[l].textContent,
          t
        ), c = 100;
        let h = 3;
        for (; h < u.length && // keep consuming css identifiers (to get a decent chunk more quickly)
        (u[h].match(/[a-zA-Z0-9]/) || // substring needs to be unique to this section
        u.indexOf(u.substring(0, h), 1) !== -1); h++)
          ;
        for (; h < u.length; h++) {
          let p = u.substring(0, h), d = o.split(p), b = -1;
          if (d.length === 2)
            b = d[0].length;
          else if (d.length > 2 && d[0] === "" && i[l - 1].textContent !== "")
            b = o.indexOf(p, 1);
          else if (d.length === 1) {
            if (p = p.substring(
              0,
              p.length - 1
            ), d = o.split(p), d.length <= 1)
              return r.push(s), r;
            h = c + 1;
          } else h === u.length - 1 && (b = o.indexOf(p));
          if (d.length >= 2 && h > c) {
            const m = i[l - 1].textContent;
            if (m && typeof m == "string") {
              const f = $t(m).length;
              b = o.indexOf(p, f);
            }
            b === -1 && (b = d[0].length);
          }
          if (b !== -1) {
            let m = Math.floor(b / a);
            for (; m > 0 && m < s.length; ) {
              if (n += 1, n > 50 * i.length)
                return r.push(s), r;
              const f = $t(
                s.substring(0, m),
                t
              );
              if (f.length === b) {
                r.push(s.substring(0, m)), s = s.substring(m), o = o.substring(b);
                break;
              } else f.length < b ? m += Math.max(
                1,
                Math.floor((b - f.length) / a)
              ) : m -= Math.max(
                1,
                Math.floor((f.length - b) * a)
              );
            }
            break;
          }
        }
      }
  }
  return r.push(s), r;
}
function Wc(s, e) {
  return Xc(s, e).join("/* rr_split */");
}
function lr(s) {
  return s = s.replace(/[^ -~]+/g, ""), s = (s == null ? void 0 : s.split(" ").map((e) => Math.random().toString(20).substring(2, e.length)).join(" ")) || "", s;
}
function Vs(s) {
  return s === "img" || s === "video" || s === "audio" || s === "source";
}
const Rc = new RegExp(
  /[a-zA-Z0-9.!#$%&'*+=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:.[a-zA-Z0-9-]+)*/
), Cc = new RegExp(/[0-9]{9,16}/), wc = new RegExp(/[0-9]{3}-?[0-9]{2}-?[0-9]{4}/), xc = new RegExp(
  /[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}/
), kc = new RegExp(/[0-9]{4}-?[0-9]{4}-?[0-9]{4}-?[0-9]{4}/), Lc = new RegExp(
  /[0-9]{1,5}.?[0-9]{0,3}\s[a-zA-Z]{2,30}\s[a-zA-Z]{2,15}/
), Jc = new RegExp(/(?:[0-9]{1,3}.){3}[0-9]{1,3}/), vc = [
  Rc,
  Cc,
  wc,
  xc,
  kc,
  Lc,
  Jc
];
function hl(s) {
  return s ? vc.some((e) => e.test(s)) : !1;
}
const dl = ({
  maskInputOptions: s,
  tagName: e,
  type: t,
  overwriteRecord: i
}) => {
  const r = t && t.toLowerCase();
  return i !== "true" && (!!s[e.toLowerCase()] || !!(r && s[r]));
};
let Yc = 1;
const Nc = new RegExp("[^a-z0-9-_:]"), vt = -2;
function pl() {
  return Yc++;
}
function Tc(s) {
  if (s instanceof HTMLFormElement)
    return "form";
  const e = ct(s.tagName);
  return Nc.test(e) ? "div" : e;
}
let st, jr;
const Uc = /^[^ \t\n\r\u000c]+/, Kc = /^[, \t\n\r\u000c]+/;
function Fc(s, e) {
  if (e.trim() === "")
    return e;
  let t = 0;
  function i(n) {
    let o;
    const a = n.exec(e.substring(t));
    return a ? (o = a[0], t += o.length, o) : "";
  }
  const r = [];
  for (; i(Kc), !(t >= e.length); ) {
    let n = i(Uc);
    if (n.slice(-1) === ",")
      n = lt(s, n.substring(0, n.length - 1)), r.push(n);
    else {
      let o = "";
      n = lt(s, n);
      let a = !1;
      for (; ; ) {
        const l = e.charAt(t);
        if (l === "") {
          r.push((n + o).trim());
          break;
        } else if (a)
          l === ")" && (a = !1);
        else if (l === ",") {
          t += 1, r.push((n + o).trim());
          break;
        } else l === "(" && (a = !0);
        o += l, t += 1;
      }
    }
  }
  return r.join(", ");
}
const Dr = /* @__PURE__ */ new WeakMap();
function lt(s, e) {
  return !e || e.trim() === "" ? e : or(s, e);
}
function zc(s) {
  return !!(s.tagName === "svg" || s.ownerSVGElement);
}
function or(s, e) {
  let t = Dr.get(s);
  if (t || (t = s.createElement("a"), Dr.set(s, t)), !e)
    e = "";
  else if (e.startsWith("blob:") || e.startsWith("data:"))
    return e;
  return t.setAttribute("href", e), t.href;
}
function ml(s, e, t, i) {
  return i && (t === "src" || t === "href" && !(e === "use" && i[0] === "#") || t === "xlink:href" && i[0] !== "#" || t === "background" && (e === "table" || e === "td" || e === "th") ? lt(s, i) : t === "srcset" ? Fc(s, i) : t === "style" ? Ci(i, or(s)) : e === "object" && t === "data" ? lt(s, i) : i);
}
function fl(s, e, t) {
  return (s === "video" || s === "audio") && e === "autoplay";
}
function Ar(s, e, t) {
  try {
    if (typeof e == "string") {
      if (s.classList.contains(e))
        return !0;
    } else
      for (let i = s.classList.length; i--; ) {
        const r = s.classList[i];
        if (e.test(r))
          return !0;
      }
    if (t)
      return s.matches(t);
  } catch (i) {
  }
  return !1;
}
function wi(s, e, t) {
  if (!s) return !1;
  if (s.nodeType !== s.ELEMENT_NODE)
    return t ? wi(le.parentNode(s), e, t) : !1;
  for (let i = s.classList.length; i--; ) {
    const r = s.classList[i];
    if (e.test(r))
      return !0;
  }
  return t ? wi(le.parentNode(s), e, t) : !1;
}
function bl(s, e, t, i) {
  let r;
  if (ol(s)) {
    if (r = s, !le.childNodes(r).length)
      return !1;
  } else {
    if (le.parentElement(s) === null)
      return !1;
    r = le.parentElement(s);
  }
  try {
    if (typeof e == "string") {
      if (i) {
        if (r.closest(`.${e}`)) return !0;
      } else if (r.classList.contains(e)) return !0;
    } else if (wi(r, e, i)) return !0;
    if (t) {
      if (i) {
        if (r.closest(t)) return !0;
      } else if (r.matches(t)) return !0;
    }
  } catch (n) {
  }
  return !1;
}
function Hc(s, e, t) {
  const i = s.contentWindow;
  if (!i)
    return;
  let r = !1, n;
  try {
    n = i.document.readyState;
  } catch (a) {
    return;
  }
  if (n !== "complete") {
    const a = setTimeout(() => {
      r || (e(), r = !0);
    }, t);
    s.addEventListener("load", () => {
      clearTimeout(a), r = !0, e();
    });
    return;
  }
  const o = "about:blank";
  if (i.location.href !== o || s.src === o || s.src === "")
    return setTimeout(e, 0), s.addEventListener("load", e);
  s.addEventListener("load", e);
}
function Mc(s, e, t) {
  let i = !1, r;
  try {
    r = s.sheet;
  } catch (o) {
    return;
  }
  if (r) return;
  const n = setTimeout(() => {
    i || (e(), i = !0);
  }, t);
  s.addEventListener("load", () => {
    clearTimeout(n), i = !0, e();
  });
}
function Oc(s, e) {
  const {
    doc: t,
    mirror: i,
    blockClass: r,
    blockSelector: n,
    needsMask: o,
    inlineStylesheet: a,
    maskInputOptions: l = {},
    maskTextClass: u,
    maskTextFn: c,
    maskInputFn: h,
    dataURLOptions: p = {},
    inlineImages: d,
    inlineVideos: b,
    recordCanvas: m,
    keepIframeSrcFn: f,
    newlyAddedElement: G = !1,
    cssCaptured: S = !1,
    privacySetting: V
  } = e, I = Pc(t, i);
  switch (s.nodeType) {
    case s.DOCUMENT_NODE:
      return s.compatMode !== "CSS1Compat" ? {
        type: ie.Document,
        childNodes: [],
        compatMode: s.compatMode
        // probably "BackCompat"
      } : {
        type: ie.Document,
        childNodes: []
      };
    case s.DOCUMENT_TYPE_NODE:
      return {
        type: ie.DocumentType,
        name: s.name,
        publicId: s.publicId,
        systemId: s.systemId,
        rootId: I
      };
    case s.ELEMENT_NODE:
      return Bc(s, {
        doc: t,
        blockClass: r,
        blockSelector: n,
        inlineStylesheet: a,
        maskInputOptions: l,
        maskInputFn: h,
        maskTextClass: u,
        dataURLOptions: p,
        inlineImages: d,
        inlineVideos: b,
        recordCanvas: m,
        keepIframeSrcFn: f,
        newlyAddedElement: G,
        privacySetting: V,
        rootId: I
      });
    case s.TEXT_NODE:
      return Ec(s, {
        doc: t,
        needsMask: o,
        maskTextFn: c,
        privacySetting: V,
        rootId: I,
        cssCaptured: S
      });
    case s.CDATA_SECTION_NODE:
      return {
        type: ie.CDATA,
        textContent: "",
        rootId: I
      };
    case s.COMMENT_NODE:
      return {
        type: ie.Comment,
        textContent: le.textContent(s) || "",
        rootId: I
      };
    default:
      return !1;
  }
}
function Pc(s, e) {
  if (!e.hasNode(s)) return;
  const t = e.getId(s);
  return t === 1 ? void 0 : t;
}
function Ec(s, e) {
  var t;
  const { needsMask: i, maskTextFn: r, privacySetting: n, rootId: o, cssCaptured: a } = e, l = le.parentNode(s), u = l && l.tagName;
  let c = "";
  const h = u === "STYLE" ? !0 : void 0, p = u === "SCRIPT" ? !0 : void 0;
  p ? c = "SCRIPT_PLACEHOLDER" : a || (c = le.textContent(s), h && c && (c = Ci(c, or(e.doc)))), !h && !p && c && i && (c = r ? r(c, le.parentElement(s)) : c.replace(/[\S]/g, "*"));
  const d = n === "strict", b = (t = s.parentElement) == null ? void 0 : t.getAttribute("data-hl-record"), m = n === "default" && hl(c);
  return (d || m) && !b && u && !(/* @__PURE__ */ new Set([
    "HEAD",
    "TITLE",
    "STYLE",
    "SCRIPT",
    "HTML",
    "BODY",
    "NOSCRIPT"
  ])).has(u) && c && (c = lr(c)), {
    type: ie.Text,
    textContent: c || "",
    rootId: o
  };
}
function Bc(s, e) {
  const {
    doc: t,
    blockClass: i,
    blockSelector: r,
    inlineStylesheet: n,
    maskInputOptions: o = {},
    maskInputFn: a,
    maskTextClass: l,
    dataURLOptions: u = {},
    inlineImages: c,
    inlineVideos: h,
    recordCanvas: p,
    keepIframeSrcFn: d,
    newlyAddedElement: b = !1,
    privacySetting: m,
    rootId: f
  } = e;
  let G = Ar(s, i, r);
  const S = Ar(s, l, null), V = m === "strict";
  let I = Tc(s), g = {};
  const R = s.attributes.length;
  for (let y = 0; y < R; y++) {
    const X = s.attributes[y];
    fl(I, X.name) || (g[X.name] = ml(
      t,
      I,
      ct(X.name),
      X.value
    ));
  }
  if (I === "link" && n) {
    const y = Array.from(t.styleSheets).find((Y) => Y.href === s.href);
    let X = null;
    y && (X = Gs(y)), X && (delete g.rel, delete g.href, g._cssText = X);
  }
  if (I === "style" && s.sheet) {
    let y = Gs(
      s.sheet
    );
    y && (s.childNodes.length > 1 && (y = Wc(y, s)), g._cssText = y);
  }
  if (I === "input" || I === "textarea" || I === "select") {
    const y = s.value, X = s.checked;
    g.type !== "radio" && g.type !== "checkbox" && g.type !== "submit" && g.type !== "button" && y ? g.value = Wi({
      element: s,
      type: Ri(s),
      tagName: I,
      value: y,
      overwriteRecord: s.getAttribute("data-hl-record"),
      maskInputOptions: o,
      maskInputFn: a
    }) : X && (g.checked = X);
  }
  if (I === "option" && (s.selected && !o.select ? g.selected = !0 : delete g.selected), I === "dialog" && s.open && (g.rr_open_mode = s.matches("dialog:modal") ? "modal" : "non-modal"), I === "canvas" && p) {
    if (s.__context === "2d")
      gc(s);
    else if (!("__context" in s)) {
      const y = s.toDataURL(
        u.type,
        u.quality
      ), X = t.createElement("canvas");
      X.width = s.width, X.height = s.height;
      const Y = X.toDataURL(
        u.type,
        u.quality
      );
      y !== Y && (g.rr_dataURL = y);
    }
  }
  if (I === "img" && c && !G && !S && !V) {
    st || (st = t.createElement("canvas"), jr = st.getContext("2d"));
    const y = s, X = y.currentSrc || y.getAttribute("src") || "<unknown-src>", Y = y.crossOrigin, v = () => {
      y.removeEventListener("load", v);
      try {
        st.width = y.naturalWidth, st.height = y.naturalHeight, jr.drawImage(y, 0, 0), g.rr_dataURL = st.toDataURL(
          u.type,
          u.quality
        );
      } catch (Q) {
        if (y.crossOrigin !== "anonymous") {
          y.crossOrigin = "anonymous", y.complete && y.naturalWidth !== 0 ? v() : y.addEventListener("load", v);
          return;
        } else
          console.warn(
            `Cannot inline img src=${X}! Error: ${Q}`
          );
      }
      y.crossOrigin === "anonymous" && (Y ? g.crossOrigin = Y : y.removeAttribute("crossorigin"));
    };
    y.complete && y.naturalWidth !== 0 ? v() : y.addEventListener("load", v);
  }
  if (I === "audio" || I === "video") {
    const y = g;
    y.rr_mediaState = s.paused ? "paused" : "played", y.rr_mediaCurrentTime = s.currentTime, y.rr_mediaPlaybackRate = s.playbackRate, y.rr_mediaMuted = s.muted, y.rr_mediaLoop = s.loop, y.rr_mediaVolume = s.volume;
  }
  if (b || (s.scrollLeft && (g.rr_scrollLeft = s.scrollLeft), s.scrollTop && (g.rr_scrollTop = s.scrollTop)), G || S || V && Vs(I)) {
    const { width: y, height: X } = s.getBoundingClientRect();
    g = {
      class: g.class,
      rr_width: `${y}px`,
      rr_height: `${X}px`
    };
  }
  V && Vs(I) && (G = !0), I === "iframe" && !d(g.src) && (s.contentDocument || (g.rr_src = g.src), delete g.src);
  let C;
  try {
    customElements.get(I) && (C = !0);
  } catch (y) {
  }
  const W = (y) => {
    const { width: X, height: Y } = y.getBoundingClientRect();
    g = {
      width: X,
      height: Y,
      rr_width: `${X}px`,
      rr_height: `${Y}px`,
      rr_inlined_video: !0,
      class: g.class,
      style: g.style
    }, I = "canvas";
    const v = t.createElement("canvas");
    v.width = s.width, v.height = s.height, g.rr_dataURL = v.toDataURL(
      u.type,
      u.quality
    );
  };
  if (I === "video") {
    const y = s;
    c && (y.src === "" || y.src.indexOf("blob:") !== -1) && W(y), h && y.src !== "" && y.src.indexOf("blob:") === -1 && W(y);
  }
  return {
    type: ie.Element,
    tagName: I,
    attributes: g,
    childNodes: [],
    isSVG: zc(s) || void 0,
    needBlock: G,
    needMask: S,
    rootId: f,
    isCustom: C
  };
}
function B(s) {
  return s == null ? "" : s.toLowerCase();
}
function Qc(s, e) {
  if (e.comment && s.type === ie.Comment)
    return !0;
  if (s.type === ie.Element) {
    if (e.script && // script tag
    (s.tagName === "script" || // (module)preload link
    s.tagName === "link" && (s.attributes.rel === "preload" && s.attributes.as === "script" || s.attributes.rel === "modulepreload") || // prefetch link
    s.tagName === "link" && s.attributes.rel === "prefetch" && typeof s.attributes.href == "string" && ul(s.attributes.href) === "js"))
      return !0;
    if (e.headFavicon && (s.tagName === "link" && s.attributes.rel === "shortcut icon" || s.tagName === "meta" && (B(s.attributes.name).match(
      /^msapplication-tile(image|color)$/
    ) || B(s.attributes.name) === "application-name" || B(s.attributes.rel) === "icon" || B(s.attributes.rel) === "apple-touch-icon" || B(s.attributes.rel) === "shortcut icon")))
      return !0;
    if (s.tagName === "meta") {
      if (e.headMetaDescKeywords && B(s.attributes.name).match(/^description|keywords$/))
        return !0;
      if (e.headMetaSocial && (B(s.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)
      B(s.attributes.name).match(/^(og|twitter):/) || B(s.attributes.name) === "pinterest"))
        return !0;
      if (e.headMetaRobots && (B(s.attributes.name) === "robots" || B(s.attributes.name) === "googlebot" || B(s.attributes.name) === "bingbot"))
        return !0;
      if (e.headMetaHttpEquiv && s.attributes["http-equiv"] !== void 0)
        return !0;
      if (e.headMetaAuthorship && (B(s.attributes.name) === "author" || B(s.attributes.name) === "generator" || B(s.attributes.name) === "framework" || B(s.attributes.name) === "publisher" || B(s.attributes.name) === "progid" || B(s.attributes.property).match(/^article:/) || B(s.attributes.property).match(/^product:/)))
        return !0;
      if (e.headMetaVerification && (B(s.attributes.name) === "google-site-verification" || B(s.attributes.name) === "yandex-verification" || B(s.attributes.name) === "csrf-token" || B(s.attributes.name) === "p:domain_verify" || B(s.attributes.name) === "verify-v1" || B(s.attributes.name) === "verification" || B(s.attributes.name) === "shopify-checkout-api-token"))
        return !0;
    }
  }
  return !1;
}
function ot(s, e) {
  const {
    doc: t,
    mirror: i,
    blockClass: r,
    blockSelector: n,
    maskTextClass: o,
    maskTextSelector: a,
    skipChild: l = !1,
    inlineStylesheet: u = !0,
    maskInputOptions: c = {},
    maskTextFn: h,
    maskInputFn: p,
    slimDOMOptions: d,
    dataURLOptions: b = {},
    inlineImages: m = !1,
    inlineVideos: f = !1,
    recordCanvas: G = !1,
    onSerialize: S,
    onIframeLoad: V,
    iframeLoadTimeout: I = 5e3,
    onStylesheetLoad: g,
    stylesheetLoadTimeout: R = 5e3,
    keepIframeSrcFn: C = () => !1,
    newlyAddedElement: W = !1,
    cssCaptured: y = !1,
    privacySetting: X
  } = e;
  let { needsMask: Y } = e, { preserveWhiteSpace: v = !0 } = e;
  Y || (Y = bl(
    s,
    o,
    a,
    Y === void 0
  ));
  const Q = Oc(s, {
    doc: t,
    mirror: i,
    blockClass: r,
    blockSelector: n,
    needsMask: Y,
    inlineStylesheet: u,
    maskInputOptions: c,
    maskTextClass: o,
    maskTextFn: h,
    maskInputFn: p,
    dataURLOptions: b,
    inlineImages: m,
    inlineVideos: f,
    recordCanvas: G,
    keepIframeSrcFn: C,
    newlyAddedElement: W,
    cssCaptured: y,
    privacySetting: X
  });
  if (!Q)
    return console.warn(s, "not serialized"), null;
  let A;
  i.hasNode(s) ? A = i.getId(s) : Qc(Q, d) || !v && Q.type === ie.Text && !Q.textContent.replace(/^\s+|\s+$/gm, "").length ? A = vt : A = pl();
  const w = Object.assign(Q, { id: A });
  if (i.add(s, w), A === vt)
    return null;
  S && S(s);
  let te = !l, M = X, j = X === "strict";
  if (w.type === ie.Element) {
    if (te = te && !w.needBlock, j || (j = !!w.needBlock || !!w.needMask), M = j ? "strict" : M, j && Vs(w.tagName)) {
      const O = s.cloneNode();
      O.src = "", i.add(O, w);
    }
    delete w.needBlock, delete w.needMask;
    const E = le.shadowRoot(s);
    E && xt(E) && (w.isShadowHost = !0);
  }
  if ((w.type === ie.Document || w.type === ie.Element) && te) {
    d.headWhitespace && w.type === ie.Element && w.tagName === "head" && (v = !1);
    const E = {
      doc: t,
      mirror: i,
      blockClass: r,
      blockSelector: n,
      needsMask: Y,
      maskTextClass: o,
      maskTextSelector: a,
      skipChild: l,
      inlineStylesheet: u,
      maskInputOptions: c,
      maskTextFn: h,
      maskInputFn: p,
      slimDOMOptions: d,
      dataURLOptions: b,
      inlineImages: m,
      inlineVideos: f,
      recordCanvas: G,
      preserveWhiteSpace: v,
      onSerialize: S,
      onIframeLoad: V,
      iframeLoadTimeout: I,
      onStylesheetLoad: g,
      stylesheetLoadTimeout: R,
      keepIframeSrcFn: C,
      cssCaptured: !1,
      privacySetting: M
    };
    if (!(w.type === ie.Element && w.tagName === "textarea" && w.attributes.value !== void 0)) {
      w.type === ie.Element && w.attributes._cssText !== void 0 && typeof w.attributes._cssText == "string" && (E.cssCaptured = !0);
      for (const pe of Array.from(le.childNodes(s))) {
        const ae = ot(pe, E);
        ae && w.childNodes.push(ae);
      }
    }
    let O = null;
    if (ol(s) && (O = le.shadowRoot(s)))
      for (const pe of Array.from(le.childNodes(O))) {
        const ae = ot(pe, E);
        ae && (xt(O) && (ae.isShadow = !0), w.childNodes.push(ae));
      }
  }
  const ee = le.parentNode(s);
  return ee && wt(ee) && xt(ee) && (w.isShadow = !0), w.type === ie.Element && w.tagName === "iframe" && Hc(
    s,
    () => {
      const E = s.contentDocument;
      if (E && V) {
        const O = ot(E, {
          doc: E,
          mirror: i,
          blockClass: r,
          blockSelector: n,
          needsMask: Y,
          maskTextClass: o,
          maskTextSelector: a,
          skipChild: !1,
          inlineStylesheet: u,
          maskInputOptions: c,
          maskTextFn: h,
          maskInputFn: p,
          slimDOMOptions: d,
          dataURLOptions: b,
          inlineImages: m,
          inlineVideos: f,
          recordCanvas: G,
          preserveWhiteSpace: v,
          onSerialize: S,
          onIframeLoad: V,
          iframeLoadTimeout: I,
          onStylesheetLoad: g,
          stylesheetLoadTimeout: R,
          keepIframeSrcFn: C,
          privacySetting: X
        });
        O && V(
          s,
          O
        );
      }
    },
    I
  ), w.type === ie.Element && w.tagName === "link" && typeof w.attributes.rel == "string" && (w.attributes.rel === "stylesheet" || w.attributes.rel === "preload" && typeof w.attributes.href == "string" && ul(w.attributes.href) === "css") && Mc(
    s,
    () => {
      if (g) {
        const E = ot(s, {
          doc: t,
          mirror: i,
          blockClass: r,
          blockSelector: n,
          needsMask: Y,
          maskTextClass: o,
          maskTextSelector: a,
          skipChild: !1,
          inlineStylesheet: u,
          maskInputOptions: c,
          maskTextFn: h,
          maskInputFn: p,
          slimDOMOptions: d,
          dataURLOptions: b,
          inlineImages: m,
          inlineVideos: f,
          recordCanvas: G,
          preserveWhiteSpace: v,
          onSerialize: S,
          onIframeLoad: V,
          iframeLoadTimeout: I,
          onStylesheetLoad: g,
          stylesheetLoadTimeout: R,
          keepIframeSrcFn: C,
          privacySetting: X
        });
        E && g(
          s,
          E
        );
      }
    },
    R
  ), w;
}
function jc(s, e) {
  const {
    mirror: t = new cl(),
    blockClass: i = "highlight-block",
    blockSelector: r = null,
    maskTextClass: n = "highlight-mask",
    maskTextSelector: o = null,
    inlineStylesheet: a = !0,
    inlineImages: l = !1,
    inlineVideos: u = !1,
    recordCanvas: c = !1,
    maskAllInputs: h = !1,
    maskTextFn: p,
    maskInputFn: d,
    slimDOM: b = !1,
    dataURLOptions: m,
    preserveWhiteSpace: f,
    onSerialize: G,
    onIframeLoad: S,
    iframeLoadTimeout: V,
    onStylesheetLoad: I,
    stylesheetLoadTimeout: g,
    keepIframeSrcFn: R = () => !1,
    privacySetting: C = "default"
  } = e || {};
  return ot(s, {
    doc: s,
    mirror: t,
    blockClass: i,
    blockSelector: r,
    maskTextClass: n,
    maskTextSelector: o,
    skipChild: !1,
    inlineStylesheet: a,
    maskInputOptions: h === !0 ? {
      color: !0,
      date: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0,
      textarea: !0,
      select: !0,
      password: !0
    } : h === !1 ? {
      password: !0
    } : h,
    maskTextFn: p,
    maskInputFn: d,
    slimDOMOptions: b || b === "all" ? (
      // if true: set of sensible options that should not throw away any information
      {
        script: !0,
        comment: !0,
        headFavicon: !0,
        headWhitespace: !0,
        headMetaDescKeywords: b === "all",
        // destructive
        headMetaSocial: !0,
        headMetaRobots: !0,
        headMetaHttpEquiv: !0,
        headMetaAuthorship: !0,
        headMetaVerification: !0
      }
    ) : b || {},
    dataURLOptions: m,
    inlineImages: l,
    inlineVideos: u,
    recordCanvas: c,
    preserveWhiteSpace: f,
    onSerialize: G,
    onIframeLoad: S,
    iframeLoadTimeout: V,
    onStylesheetLoad: I,
    stylesheetLoadTimeout: g,
    keepIframeSrcFn: R,
    newlyAddedElement: !1,
    privacySetting: C
  });
}
function Dc(s) {
  if (s.__esModule) return s;
  var e = s.default;
  if (typeof e == "function") {
    var t = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(s).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(s, i);
    Object.defineProperty(t, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return s[i];
      }
    });
  }), t;
}
var ar = { exports: {} }, L = String, yl = function() {
  return { isColorSupported: !1, reset: L, bold: L, dim: L, italic: L, underline: L, inverse: L, hidden: L, strikethrough: L, black: L, red: L, green: L, yellow: L, blue: L, magenta: L, cyan: L, white: L, gray: L, bgBlack: L, bgRed: L, bgGreen: L, bgYellow: L, bgBlue: L, bgMagenta: L, bgCyan: L, bgWhite: L, blackBright: L, redBright: L, greenBright: L, yellowBright: L, blueBright: L, magentaBright: L, cyanBright: L, whiteBright: L, bgBlackBright: L, bgRedBright: L, bgGreenBright: L, bgYellowBright: L, bgBlueBright: L, bgMagentaBright: L, bgCyanBright: L, bgWhiteBright: L };
};
ar.exports = yl();
ar.exports.createColors = yl;
var Ac = ar.exports;
const _c = {}, $c = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _c
}, Symbol.toStringTag, { value: "Module" })), Ve = /* @__PURE__ */ Dc($c);
let _r = Ac, $r = Ve, Ss = class gl extends Error {
  constructor(e, t, i, r, n, o) {
    super(e), this.name = "CssSyntaxError", this.reason = e, n && (this.file = n), r && (this.source = r), o && (this.plugin = o), typeof t != "undefined" && typeof i != "undefined" && (typeof t == "number" ? (this.line = t, this.column = i) : (this.line = t.line, this.column = t.column, this.endLine = i.line, this.endColumn = i.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, gl);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line != "undefined" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source) return "";
    let t = this.source;
    e == null && (e = _r.isColorSupported);
    let i = (c) => c, r = (c) => c, n = (c) => c;
    if (e) {
      let { bold: c, gray: h, red: p } = _r.createColors(!0);
      r = (d) => c(p(d)), i = (d) => h(d), $r && (n = (d) => $r(d));
    }
    let o = t.split(/\r?\n/), a = Math.max(this.line - 3, 0), l = Math.min(this.line + 2, o.length), u = String(l).length;
    return o.slice(a, l).map((c, h) => {
      let p = a + 1 + h, d = " " + (" " + p).slice(-u) + " | ";
      if (p === this.line) {
        if (c.length > 160) {
          let m = 20, f = Math.max(0, this.column - m), G = Math.max(
            this.column + m,
            this.endColumn + m
          ), S = c.slice(f, G), V = i(d.replace(/\d/g, " ")) + c.slice(0, Math.min(this.column - 1, m - 1)).replace(/[^\t]/g, " ");
          return r(">") + i(d) + n(S) + `
 ` + V + r("^");
        }
        let b = i(d.replace(/\d/g, " ")) + c.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return r(">") + i(d) + n(c) + `
 ` + b + r("^");
      }
      return " " + i(d) + n(c);
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
};
var cr = Ss;
Ss.default = Ss;
const qr = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: !1
};
function qc(s) {
  return s[0].toUpperCase() + s.slice(1);
}
let Is = class {
  constructor(e) {
    this.builder = e;
  }
  atrule(e, t) {
    let i = "@" + e.name, r = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName != "undefined" ? i += e.raws.afterName : r && (i += " "), e.nodes)
      this.block(e, i + r);
    else {
      let n = (e.raws.between || "") + (t ? ";" : "");
      this.builder(i + r + n, e);
    }
  }
  beforeAfter(e, t) {
    let i;
    e.type === "decl" ? i = this.raw(e, null, "beforeDecl") : e.type === "comment" ? i = this.raw(e, null, "beforeComment") : t === "before" ? i = this.raw(e, null, "beforeRule") : i = this.raw(e, null, "beforeClose");
    let r = e.parent, n = 0;
    for (; r && r.type !== "root"; )
      n += 1, r = r.parent;
    if (i.includes(`
`)) {
      let o = this.raw(e, null, "indent");
      if (o.length)
        for (let a = 0; a < n; a++) i += o;
    }
    return i;
  }
  block(e, t) {
    let i = this.raw(e, "between", "beforeOpen");
    this.builder(t + i + "{", e, "start");
    let r;
    e.nodes && e.nodes.length ? (this.body(e), r = this.raw(e, "after")) : r = this.raw(e, "after", "emptyBody"), r && this.builder(r), this.builder("}", e, "end");
  }
  body(e) {
    let t = e.nodes.length - 1;
    for (; t > 0 && e.nodes[t].type === "comment"; )
      t -= 1;
    let i = this.raw(e, "semicolon");
    for (let r = 0; r < e.nodes.length; r++) {
      let n = e.nodes[r], o = this.raw(n, "before");
      o && this.builder(o), this.stringify(n, t !== r || i);
    }
  }
  comment(e) {
    let t = this.raw(e, "left", "commentLeft"), i = this.raw(e, "right", "commentRight");
    this.builder("/*" + t + e.text + i + "*/", e);
  }
  decl(e, t) {
    let i = this.raw(e, "between", "colon"), r = e.prop + i + this.rawValue(e, "value");
    e.important && (r += e.raws.important || " !important"), t && (r += ";"), this.builder(r, e);
  }
  document(e) {
    this.body(e);
  }
  raw(e, t, i) {
    let r;
    if (i || (i = t), t && (r = e.raws[t], typeof r != "undefined"))
      return r;
    let n = e.parent;
    if (i === "before" && (!n || n.type === "root" && n.first === e || n && n.type === "document"))
      return "";
    if (!n) return qr[i];
    let o = e.root();
    if (o.rawCache || (o.rawCache = {}), typeof o.rawCache[i] != "undefined")
      return o.rawCache[i];
    if (i === "before" || i === "after")
      return this.beforeAfter(e, i);
    {
      let a = "raw" + qc(i);
      this[a] ? r = this[a](o, e) : o.walk((l) => {
        if (r = l.raws[t], typeof r != "undefined") return !1;
      });
    }
    return typeof r == "undefined" && (r = qr[i]), o.rawCache[i] = r, r;
  }
  rawBeforeClose(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length > 0 && typeof i.raws.after != "undefined")
        return t = i.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeComment(e, t) {
    let i;
    return e.walkComments((r) => {
      if (typeof r.raws.before != "undefined")
        return i = r.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
    }), typeof i == "undefined" ? i = this.raw(t, null, "beforeDecl") : i && (i = i.replace(/\S/g, "")), i;
  }
  rawBeforeDecl(e, t) {
    let i;
    return e.walkDecls((r) => {
      if (typeof r.raws.before != "undefined")
        return i = r.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
    }), typeof i == "undefined" ? i = this.raw(t, null, "beforeRule") : i && (i = i.replace(/\S/g, "")), i;
  }
  rawBeforeOpen(e) {
    let t;
    return e.walk((i) => {
      if (i.type !== "decl" && (t = i.raws.between, typeof t != "undefined"))
        return !1;
    }), t;
  }
  rawBeforeRule(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && (i.parent !== e || e.first !== i) && typeof i.raws.before != "undefined")
        return t = i.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawColon(e) {
    let t;
    return e.walkDecls((i) => {
      if (typeof i.raws.between != "undefined")
        return t = i.raws.between.replace(/[^\s:]/g, ""), !1;
    }), t;
  }
  rawEmptyBody(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length === 0 && (t = i.raws.after, typeof t != "undefined"))
        return !1;
    }), t;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let t;
    return e.walk((i) => {
      let r = i.parent;
      if (r && r !== e && r.parent && r.parent === e && typeof i.raws.before != "undefined") {
        let n = i.raws.before.split(`
`);
        return t = n[n.length - 1], t = t.replace(/\S/g, ""), !1;
      }
    }), t;
  }
  rawSemicolon(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length && i.last.type === "decl" && (t = i.raws.semicolon, typeof t != "undefined"))
        return !1;
    }), t;
  }
  rawValue(e, t) {
    let i = e[t], r = e.raws[t];
    return r && r.value === i ? r.raw : i;
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  stringify(e, t) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, t);
  }
};
var Zl = Is;
Is.default = Is;
let eu = Zl;
function Xs(s, e) {
  new eu(e).stringify(s);
}
var Hi = Xs;
Xs.default = Xs;
var Pt = {};
Pt.isClean = Symbol("isClean");
Pt.my = Symbol("my");
let tu = cr, iu = Zl, su = Hi, { isClean: Gt, my: ru } = Pt;
function Ws(s, e) {
  let t = new s.constructor();
  for (let i in s) {
    if (!Object.prototype.hasOwnProperty.call(s, i) || i === "proxyCache") continue;
    let r = s[i], n = typeof r;
    i === "parent" && n === "object" ? e && (t[i] = e) : i === "source" ? t[i] = r : Array.isArray(r) ? t[i] = r.map((o) => Ws(o, t)) : (n === "object" && r !== null && (r = Ws(r)), t[i] = r);
  }
  return t;
}
function xe(s, e) {
  if (e && typeof e.offset != "undefined")
    return e.offset;
  let t = 1, i = 1, r = 0;
  for (let n = 0; n < s.length; n++) {
    if (i === e.line && t === e.column) {
      r = n;
      break;
    }
    s[n] === `
` ? (t = 1, i += 1) : t += 1;
  }
  return r;
}
let Rs = class {
  get proxyOf() {
    return this;
  }
  constructor(e = {}) {
    this.raws = {}, this[Gt] = !1, this[ru] = !0;
    for (let t in e)
      if (t === "nodes") {
        this.nodes = [];
        for (let i of e[t])
          typeof i.clone == "function" ? this.append(i.clone()) : this.append(i);
      } else
        this[t] = e[t];
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let t = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${t.input.from}:${t.start.line}:${t.start.column}$&`
      );
    }
    return e;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  assign(e = {}) {
    for (let t in e)
      this[t] = e[t];
    return this;
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  clone(e = {}) {
    let t = Ws(this);
    for (let i in e)
      t[i] = e[i];
    return t;
  }
  cloneAfter(e = {}) {
    let t = this.clone(e);
    return this.parent.insertAfter(this, t), t;
  }
  cloneBefore(e = {}) {
    let t = this.clone(e);
    return this.parent.insertBefore(this, t), t;
  }
  error(e, t = {}) {
    if (this.source) {
      let { end: i, start: r } = this.rangeBy(t);
      return this.source.input.error(
        e,
        { column: r.column, line: r.line },
        { column: i.column, line: i.line },
        t
      );
    }
    return new tu(e);
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : t === "root" ? () => e.root().toProxy() : e[t];
      },
      set(e, t, i) {
        return e[t] === i || (e[t] = i, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || /* c8 ignore next */
        t === "text") && e.markDirty()), !0;
      }
    };
  }
  /* c8 ignore next 3 */
  markClean() {
    this[Gt] = !0;
  }
  markDirty() {
    if (this[Gt]) {
      this[Gt] = !1;
      let e = this;
      for (; e = e.parent; )
        e[Gt] = !1;
    }
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  positionBy(e = {}) {
    let t = this.source.start;
    if (e.index)
      t = this.positionInside(e.index);
    else if (e.word) {
      let i = "document" in this.source.input ? this.source.input.document : this.source.input.css, n = i.slice(
        xe(i, this.source.start),
        xe(i, this.source.end)
      ).indexOf(e.word);
      n !== -1 && (t = this.positionInside(n));
    }
    return t;
  }
  positionInside(e) {
    let t = this.source.start.column, i = this.source.start.line, r = "document" in this.source.input ? this.source.input.document : this.source.input.css, n = xe(r, this.source.start), o = n + e;
    for (let a = n; a < o; a++)
      r[a] === `
` ? (t = 1, i += 1) : t += 1;
    return { column: t, line: i, offset: o };
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  rangeBy(e = {}) {
    let t = "document" in this.source.input ? this.source.input.document : this.source.input.css, i = {
      column: this.source.start.column,
      line: this.source.start.line,
      offset: xe(t, this.source.start)
    }, r = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line,
      offset: typeof this.source.end.offset == "number" ? (
        // `source.end.offset` is exclusive, so we don't need to add 1
        this.source.end.offset
      ) : (
        // Since line/column in this.source.end is inclusive,
        // the `sourceOffset(... , this.source.end)` returns an inclusive offset.
        // So, we add 1 to convert it to exclusive.
        xe(t, this.source.end) + 1
      )
    } : {
      column: i.column + 1,
      line: i.line,
      offset: i.offset + 1
    };
    if (e.word) {
      let o = t.slice(
        xe(t, this.source.start),
        xe(t, this.source.end)
      ).indexOf(e.word);
      o !== -1 && (i = this.positionInside(o), r = this.positionInside(o + e.word.length));
    } else
      e.start ? i = {
        column: e.start.column,
        line: e.start.line,
        offset: xe(t, e.start)
      } : e.index && (i = this.positionInside(e.index)), e.end ? r = {
        column: e.end.column,
        line: e.end.line,
        offset: xe(t, e.end)
      } : typeof e.endIndex == "number" ? r = this.positionInside(e.endIndex) : e.index && (r = this.positionInside(e.index + 1));
    return (r.line < i.line || r.line === i.line && r.column <= i.column) && (r = {
      column: i.column + 1,
      line: i.line,
      offset: i.offset + 1
    }), { end: r, start: i };
  }
  raw(e, t) {
    return new iu().raw(this, e, t);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...e) {
    if (this.parent) {
      let t = this, i = !1;
      for (let r of e)
        r === this ? i = !0 : i ? (this.parent.insertAfter(t, r), t = r) : this.parent.insertBefore(t, r);
      i || this.remove();
    }
    return this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  toJSON(e, t) {
    let i = {}, r = t == null;
    t = t || /* @__PURE__ */ new Map();
    let n = 0;
    for (let o in this) {
      if (!Object.prototype.hasOwnProperty.call(this, o) || o === "parent" || o === "proxyCache") continue;
      let a = this[o];
      if (Array.isArray(a))
        i[o] = a.map((l) => typeof l == "object" && l.toJSON ? l.toJSON(null, t) : l);
      else if (typeof a == "object" && a.toJSON)
        i[o] = a.toJSON(null, t);
      else if (o === "source") {
        if (a == null) continue;
        let l = t.get(a.input);
        l == null && (l = n, t.set(a.input, n), n++), i[o] = {
          end: a.end,
          inputId: l,
          start: a.start
        };
      } else
        i[o] = a;
    }
    return r && (i.inputs = [...t.keys()].map((o) => o.toJSON())), i;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(e = su) {
    e.stringify && (e = e.stringify);
    let t = "";
    return e(this, (i) => {
      t += i;
    }), t;
  }
  warn(e, t, i = {}) {
    let r = { node: this };
    for (let n in i) r[n] = i[n];
    return e.warn(t, r);
  }
};
var Mi = Rs;
Rs.default = Rs;
let nu = Mi, Cs = class extends nu {
  constructor(e) {
    super(e), this.type = "comment";
  }
};
var Oi = Cs;
Cs.default = Cs;
let lu = Mi, ws = class extends lu {
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
  constructor(e) {
    e && typeof e.value != "undefined" && typeof e.value != "string" && (e = re(x({}, e), { value: String(e.value) })), super(e), this.type = "decl";
  }
};
var Pi = ws;
ws.default = ws;
let Gl = Oi, Vl = Pi, ou = Mi, { isClean: Sl, my: Il } = Pt, ur, Xl, Wl, hr;
function Rl(s) {
  return s.map((e) => (e.nodes && (e.nodes = Rl(e.nodes)), delete e.source, e));
}
function Cl(s) {
  if (s[Sl] = !1, s.proxyOf.nodes)
    for (let e of s.proxyOf.nodes)
      Cl(e);
}
let Ne = class wl extends ou {
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
  append(...e) {
    for (let t of e) {
      let i = this.normalize(t, this.last);
      for (let r of i) this.proxyOf.nodes.push(r);
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let t of this.nodes) t.cleanRaws(e);
  }
  each(e) {
    if (!this.proxyOf.nodes) return;
    let t = this.getIterator(), i, r;
    for (; this.indexes[t] < this.proxyOf.nodes.length && (i = this.indexes[t], r = e(this.proxyOf.nodes[i], i), r !== !1); )
      this.indexes[t] += 1;
    return delete this.indexes[t], r;
  }
  every(e) {
    return this.nodes.every(e);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : e[t] ? t === "each" || typeof t == "string" && t.startsWith("walk") ? (...i) => e[t](
          ...i.map((r) => typeof r == "function" ? (n, o) => r(n.toProxy(), o) : r)
        ) : t === "every" || t === "some" ? (i) => e[t](
          (r, ...n) => i(r.toProxy(), ...n)
        ) : t === "root" ? () => e.root().toProxy() : t === "nodes" ? e.nodes.map((i) => i.toProxy()) : t === "first" || t === "last" ? e[t].toProxy() : e[t] : e[t];
      },
      set(e, t, i) {
        return e[t] === i || (e[t] = i, (t === "name" || t === "params" || t === "selector") && e.markDirty()), !0;
      }
    };
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  insertAfter(e, t) {
    let i = this.index(e), r = this.normalize(t, this.proxyOf.nodes[i]).reverse();
    i = this.index(e);
    for (let o of r) this.proxyOf.nodes.splice(i + 1, 0, o);
    let n;
    for (let o in this.indexes)
      n = this.indexes[o], i < n && (this.indexes[o] = n + r.length);
    return this.markDirty(), this;
  }
  insertBefore(e, t) {
    let i = this.index(e), r = i === 0 ? "prepend" : !1, n = this.normalize(
      t,
      this.proxyOf.nodes[i],
      r
    ).reverse();
    i = this.index(e);
    for (let a of n) this.proxyOf.nodes.splice(i, 0, a);
    let o;
    for (let a in this.indexes)
      o = this.indexes[a], i <= o && (this.indexes[a] = o + n.length);
    return this.markDirty(), this;
  }
  normalize(e, t) {
    if (typeof e == "string")
      e = Rl(Xl(e).nodes);
    else if (typeof e == "undefined")
      e = [];
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let r of e)
        r.parent && r.parent.removeChild(r, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let r of e)
        r.parent && r.parent.removeChild(r, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value == "undefined")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new Vl(e)];
    } else if (e.selector || e.selectors)
      e = [new hr(e)];
    else if (e.name)
      e = [new ur(e)];
    else if (e.text)
      e = [new Gl(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((r) => (r[Il] || wl.rebuild(r), r = r.proxyOf, r.parent && r.parent.removeChild(r), r[Sl] && Cl(r), r.raws || (r.raws = {}), typeof r.raws.before == "undefined" && t && typeof t.raws.before != "undefined" && (r.raws.before = t.raws.before.replace(/\S/g, "")), r.parent = this.proxyOf, r));
  }
  prepend(...e) {
    e = e.reverse();
    for (let t of e) {
      let i = this.normalize(t, this.first, "prepend").reverse();
      for (let r of i) this.proxyOf.nodes.unshift(r);
      for (let r in this.indexes)
        this.indexes[r] = this.indexes[r] + i.length;
    }
    return this.markDirty(), this;
  }
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes) e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let t;
    for (let i in this.indexes)
      t = this.indexes[i], t >= e && (this.indexes[i] = t - 1);
    return this.markDirty(), this;
  }
  replaceValues(e, t, i) {
    return i || (i = t, t = {}), this.walkDecls((r) => {
      t.props && !t.props.includes(r.prop) || t.fast && !r.value.includes(t.fast) || (r.value = r.value.replace(e, i));
    }), this.markDirty(), this;
  }
  some(e) {
    return this.nodes.some(e);
  }
  walk(e) {
    return this.each((t, i) => {
      let r;
      try {
        r = e(t, i);
      } catch (n) {
        throw t.addToError(n);
      }
      return r !== !1 && t.walk && (r = t.walk(e)), r;
    });
  }
  walkAtRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((i, r) => {
      if (i.type === "atrule" && e.test(i.name))
        return t(i, r);
    }) : this.walk((i, r) => {
      if (i.type === "atrule" && i.name === e)
        return t(i, r);
    }) : (t = e, this.walk((i, r) => {
      if (i.type === "atrule")
        return t(i, r);
    }));
  }
  walkComments(e) {
    return this.walk((t, i) => {
      if (t.type === "comment")
        return e(t, i);
    });
  }
  walkDecls(e, t) {
    return t ? e instanceof RegExp ? this.walk((i, r) => {
      if (i.type === "decl" && e.test(i.prop))
        return t(i, r);
    }) : this.walk((i, r) => {
      if (i.type === "decl" && i.prop === e)
        return t(i, r);
    }) : (t = e, this.walk((i, r) => {
      if (i.type === "decl")
        return t(i, r);
    }));
  }
  walkRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((i, r) => {
      if (i.type === "rule" && e.test(i.selector))
        return t(i, r);
    }) : this.walk((i, r) => {
      if (i.type === "rule" && i.selector === e)
        return t(i, r);
    }) : (t = e, this.walk((i, r) => {
      if (i.type === "rule")
        return t(i, r);
    }));
  }
};
Ne.registerParse = (s) => {
  Xl = s;
};
Ne.registerRule = (s) => {
  hr = s;
};
Ne.registerAtRule = (s) => {
  ur = s;
};
Ne.registerRoot = (s) => {
  Wl = s;
};
var _e = Ne;
Ne.default = Ne;
Ne.rebuild = (s) => {
  s.type === "atrule" ? Object.setPrototypeOf(s, ur.prototype) : s.type === "rule" ? Object.setPrototypeOf(s, hr.prototype) : s.type === "decl" ? Object.setPrototypeOf(s, Vl.prototype) : s.type === "comment" ? Object.setPrototypeOf(s, Gl.prototype) : s.type === "root" && Object.setPrototypeOf(s, Wl.prototype), s[Il] = !0, s.nodes && s.nodes.forEach((e) => {
    Ne.rebuild(e);
  });
};
let xl = _e, xi = class extends xl {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
};
var dr = xi;
xi.default = xi;
xl.registerAtRule(xi);
let au = _e, kl, Ll, Yt = class extends au {
  constructor(e) {
    super(x({ type: "document" }, e)), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new kl(new Ll(), this, e).stringify();
  }
};
Yt.registerLazyResult = (s) => {
  kl = s;
};
Yt.registerProcessor = (s) => {
  Ll = s;
};
var pr = Yt;
Yt.default = Yt;
let cu = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", uu = (s = 21) => {
  let e = "", t = s | 0;
  for (; t--; )
    e += cu[Math.random() * 64 | 0];
  return e;
};
var hu = { nanoid: uu };
let { existsSync: du, readFileSync: pu } = Ve, { dirname: ls, join: mu } = Ve, { SourceMapConsumer: en, SourceMapGenerator: tn } = Ve;
function fu(s) {
  return Buffer ? Buffer.from(s, "base64").toString() : window.atob(s);
}
let xs = class {
  constructor(e, t) {
    if (t.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let i = t.map ? t.map.prev : void 0, r = this.loadMap(t.from, i);
    !this.mapFile && t.from && (this.mapFile = t.from), this.mapFile && (this.root = ls(this.mapFile)), r && (this.text = r);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new en(this.text)), this.consumerCache;
  }
  decodeInline(e) {
    let t = /^data:application\/json;charset=utf-?8;base64,/, i = /^data:application\/json;base64,/, r = /^data:application\/json;charset=utf-?8,/, n = /^data:application\/json,/, o = e.match(r) || e.match(n);
    if (o)
      return decodeURIComponent(e.substr(o[0].length));
    let a = e.match(t) || e.match(i);
    if (a)
      return fu(e.substr(a[0].length));
    let l = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + l);
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
  loadAnnotation(e) {
    let t = e.match(/\/\*\s*# sourceMappingURL=/g);
    if (!t) return;
    let i = e.lastIndexOf(t.pop()), r = e.indexOf("*/", i);
    i > -1 && r > -1 && (this.annotation = this.getAnnotationURL(e.substring(i, r)));
  }
  loadFile(e) {
    if (this.root = ls(e), du(e))
      return this.mapFile = e, pu(e, "utf-8").toString().trim();
  }
  loadMap(e, t) {
    if (t === !1) return !1;
    if (t) {
      if (typeof t == "string")
        return t;
      if (typeof t == "function") {
        let i = t(e);
        if (i) {
          let r = this.loadFile(i);
          if (!r)
            throw new Error(
              "Unable to load previous source map: " + i.toString()
            );
          return r;
        }
      } else {
        if (t instanceof en)
          return tn.fromSourceMap(t).toString();
        if (t instanceof tn)
          return t.toString();
        if (this.isMap(t))
          return JSON.stringify(t);
        throw new Error(
          "Unsupported previous source map format: " + t.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let i = this.annotation;
        return e && (i = mu(ls(e), i)), this.loadFile(i);
      }
    }
  }
  startWith(e, t) {
    return e ? e.substr(0, t.length) === t : !1;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var Jl = xs;
xs.default = xs;
let { nanoid: bu } = hu, { isAbsolute: ks, resolve: Ls } = Ve, { SourceMapConsumer: yu, SourceMapGenerator: gu } = Ve, { fileURLToPath: sn, pathToFileURL: qt } = Ve, rn = cr, Zu = Jl, os = Ve, as = Symbol("lineToIndexCache"), Gu = !!(yu && gu), nn = !!(Ls && ks);
function ln(s) {
  if (s[as]) return s[as];
  let e = s.css.split(`
`), t = new Array(e.length), i = 0;
  for (let r = 0, n = e.length; r < n; r++)
    t[r] = i, i += e[r].length + 1;
  return s[as] = t, t;
}
let ki = class {
  get from() {
    return this.file || this.id;
  }
  constructor(e, t = {}) {
    if (e === null || typeof e == "undefined" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, this.document = this.css, t.document && (this.document = t.document.toString()), t.from && (!nn || /^\w+:\/\//.test(t.from) || ks(t.from) ? this.file = t.from : this.file = Ls(t.from)), nn && Gu) {
      let i = new Zu(this.css, t);
      if (i.text) {
        this.map = i;
        let r = i.consumer().file;
        !this.file && r && (this.file = this.mapResolve(r));
      }
    }
    this.file || (this.id = "<input css " + bu(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(e, t, i, r = {}) {
    let n, o, a, l, u;
    if (t && typeof t == "object") {
      let h = t, p = i;
      if (typeof h.offset == "number") {
        l = h.offset;
        let d = this.fromOffset(l);
        t = d.line, i = d.col;
      } else
        t = h.line, i = h.column, l = this.fromLineAndColumn(t, i);
      if (typeof p.offset == "number") {
        a = p.offset;
        let d = this.fromOffset(a);
        o = d.line, n = d.col;
      } else
        o = p.line, n = p.column, a = this.fromLineAndColumn(p.line, p.column);
    } else if (i)
      l = this.fromLineAndColumn(t, i);
    else {
      l = t;
      let h = this.fromOffset(l);
      t = h.line, i = h.col;
    }
    let c = this.origin(t, i, o, n);
    return c ? u = new rn(
      e,
      c.endLine === void 0 ? c.line : { column: c.column, line: c.line },
      c.endLine === void 0 ? c.column : { column: c.endColumn, line: c.endLine },
      c.source,
      c.file,
      r.plugin
    ) : u = new rn(
      e,
      o === void 0 ? t : { column: i, line: t },
      o === void 0 ? i : { column: n, line: o },
      this.css,
      this.file,
      r.plugin
    ), u.input = { column: i, endColumn: n, endLine: o, endOffset: a, line: t, offset: l, source: this.css }, this.file && (qt && (u.input.url = qt(this.file).toString()), u.input.file = this.file), u;
  }
  fromLineAndColumn(e, t) {
    return ln(this)[e - 1] + t - 1;
  }
  fromOffset(e) {
    let t = ln(this), i = t[t.length - 1], r = 0;
    if (e >= i)
      r = t.length - 1;
    else {
      let n = t.length - 2, o;
      for (; r < n; )
        if (o = r + (n - r >> 1), e < t[o])
          n = o - 1;
        else if (e >= t[o + 1])
          r = o + 1;
        else {
          r = o;
          break;
        }
    }
    return {
      col: e - t[r] + 1,
      line: r + 1
    };
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : Ls(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  origin(e, t, i, r) {
    if (!this.map) return !1;
    let n = this.map.consumer(), o = n.originalPositionFor({ column: t, line: e });
    if (!o.source) return !1;
    let a;
    typeof i == "number" && (a = n.originalPositionFor({ column: r, line: i }));
    let l;
    ks(o.source) ? l = qt(o.source) : l = new URL(
      o.source,
      this.map.consumer().sourceRoot || qt(this.map.mapFile)
    );
    let u = {
      column: o.column,
      endColumn: a && a.column,
      endLine: a && a.line,
      line: o.line,
      url: l.toString()
    };
    if (l.protocol === "file:")
      if (sn)
        u.file = sn(l);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let c = n.sourceContentFor(o.source);
    return c && (u.source = c), u;
  }
  toJSON() {
    let e = {};
    for (let t of ["hasBOM", "css", "file", "id"])
      this[t] != null && (e[t] = this[t]);
    return this.map && (e.map = x({}, this.map), e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
};
var Ei = ki;
ki.default = ki;
os && os.registerInput && os.registerInput(ki);
let vl = _e, Yl, Nl, ut = class extends vl {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(e, t, i) {
    let r = super.normalize(e);
    if (t) {
      if (i === "prepend")
        this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;
      else if (this.first !== t)
        for (let n of r)
          n.raws.before = t.raws.before;
    }
    return r;
  }
  removeChild(e, t) {
    let i = this.index(e);
    return !t && i === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[i].raws.before), super.removeChild(e);
  }
  toResult(e = {}) {
    return new Yl(new Nl(), this, e).stringify();
  }
};
ut.registerLazyResult = (s) => {
  Yl = s;
};
ut.registerProcessor = (s) => {
  Nl = s;
};
var Et = ut;
ut.default = ut;
vl.registerRoot(ut);
let Nt = {
  comma(s) {
    return Nt.split(s, [","], !0);
  },
  space(s) {
    let e = [" ", `
`, "	"];
    return Nt.split(s, e);
  },
  split(s, e, t) {
    let i = [], r = "", n = !1, o = 0, a = !1, l = "", u = !1;
    for (let c of s)
      u ? u = !1 : c === "\\" ? u = !0 : a ? c === l && (a = !1) : c === '"' || c === "'" ? (a = !0, l = c) : c === "(" ? o += 1 : c === ")" ? o > 0 && (o -= 1) : o === 0 && e.includes(c) && (n = !0), n ? (r !== "" && i.push(r.trim()), r = "", n = !1) : r += c;
    return (t || r !== "") && i.push(r.trim()), i;
  }
};
var Tl = Nt;
Nt.default = Nt;
let Ul = _e, Vu = Tl, Li = class extends Ul {
  get selectors() {
    return Vu.comma(this.selector);
  }
  set selectors(e) {
    let t = this.selector ? this.selector.match(/,\s*/) : null, i = t ? t[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(i);
  }
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
};
var mr = Li;
Li.default = Li;
Ul.registerRule(Li);
let Su = dr, Iu = Oi, Xu = Pi, Wu = Ei, Ru = Jl, Cu = Et, wu = mr;
function Tt(s, e) {
  if (Array.isArray(s)) return s.map((o) => Tt(o));
  let r = s, { inputs: t } = r, i = Qe(r, ["inputs"]);
  if (t) {
    e = [];
    for (let o of t) {
      let a = re(x({}, o), { __proto__: Wu.prototype });
      a.map && (a.map = re(x({}, a.map), {
        __proto__: Ru.prototype
      })), e.push(a);
    }
  }
  if (i.nodes && (i.nodes = s.nodes.map((o) => Tt(o, e))), i.source) {
    let n = i.source, { inputId: o } = n, a = Qe(n, ["inputId"]);
    i.source = a, o != null && (i.source.input = e[o]);
  }
  if (i.type === "root")
    return new Cu(i);
  if (i.type === "decl")
    return new Xu(i);
  if (i.type === "rule")
    return new wu(i);
  if (i.type === "comment")
    return new Iu(i);
  if (i.type === "atrule")
    return new Su(i);
  throw new Error("Unknown node type: " + s.type);
}
var xu = Tt;
Tt.default = Tt;
let { dirname: Zi, relative: Kl, resolve: Fl, sep: zl } = Ve, { SourceMapConsumer: Hl, SourceMapGenerator: Gi } = Ve, { pathToFileURL: on } = Ve, ku = Ei, Lu = !!(Hl && Gi), Ju = !!(Zi && Fl && Kl && zl), vu = class {
  constructor(e, t, i, r) {
    this.stringify = e, this.mapOpts = i.map || {}, this.root = t, this.opts = i, this.css = r, this.originalCSS = r, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let t = `
`;
    this.css.includes(`\r
`) && (t = `\r
`), this.css += t + "/*# sourceMappingURL=" + e + " */";
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let t = this.toUrl(this.path(e.file)), i = e.root || Zi(e.file), r;
      this.mapOpts.sourcesContent === !1 ? (r = new Hl(e.text), r.sourcesContent && (r.sourcesContent = null)) : r = e.consumer(), this.map.applySourceMap(r, t, this.toUrl(this.path(i)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let t = this.root.nodes.length - 1; t >= 0; t--)
          e = this.root.nodes[t], e.type === "comment" && e.text.startsWith("# sourceMappingURL=") && this.root.removeChild(t);
      } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), Ju && Lu && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (t) => {
        e += t;
      }), [e];
    }
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = Gi.fromSourceMap(e, {
        ignoreInvalidMapping: !0
      });
    } else
      this.map = new Gi({
        file: this.outputFile(),
        ignoreInvalidMapping: !0
      }), this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new Gi({
      file: this.outputFile(),
      ignoreInvalidMapping: !0
    });
    let e = 1, t = 1, i = "<no source>", r = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    }, n, o;
    this.stringify(this.root, (a, l, u) => {
      if (this.css += a, l && u !== "end" && (r.generated.line = e, r.generated.column = t - 1, l.source && l.source.start ? (r.source = this.sourcePath(l), r.original.line = l.source.start.line, r.original.column = l.source.start.column - 1, this.map.addMapping(r)) : (r.source = i, r.original.line = 1, r.original.column = 0, this.map.addMapping(r))), o = a.match(/\n/g), o ? (e += o.length, n = a.lastIndexOf(`
`), t = a.length - n) : t += a.length, l && u !== "start") {
        let c = l.parent || { raws: {} };
        (!(l.type === "decl" || l.type === "atrule" && !l.nodes) || l !== c.last || c.raws.semicolon) && (l.source && l.source.end ? (r.source = this.sourcePath(l), r.original.line = l.source.end.line, r.original.column = l.source.end.column - 1, r.generated.line = e, r.generated.column = t - 2, this.map.addMapping(r)) : (r.source = i, r.original.line = 1, r.original.column = 0, r.generated.line = e, r.generated.column = t - 1, this.map.addMapping(r)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation != "undefined" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  isInline() {
    if (typeof this.mapOpts.inline != "undefined")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e != "undefined" && e !== !0 ? !1 : this.previous().length ? this.previous().some((t) => t.inline) : !0;
  }
  isMap() {
    return typeof this.opts.map != "undefined" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent != "undefined" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(e) {
    if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e)) return e;
    let t = this.memoizedPaths.get(e);
    if (t) return t;
    let i = this.opts.to ? Zi(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (i = Zi(Fl(i, this.mapOpts.annotation)));
    let r = Kl(i, e);
    return this.memoizedPaths.set(e, r), r;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let t = e.source.input.map;
            this.previousMaps.includes(t) || this.previousMaps.push(t);
          }
        });
      else {
        let e = new ku(this.originalCSS, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((t) => {
        if (t.source) {
          let i = t.source.input.from;
          if (i && !e[i]) {
            e[i] = !0;
            let r = this.usesFileUrls ? this.toFileUrl(i) : this.toUrl(this.path(i));
            this.map.setSourceContent(r, t.source.input.css);
          }
        }
      });
    else if (this.css) {
      let t = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(t, this.css);
    }
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  toBase64(e) {
    return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  toFileUrl(e) {
    let t = this.memoizedFileURLs.get(e);
    if (t) return t;
    if (on) {
      let i = on(e).toString();
      return this.memoizedFileURLs.set(e, i), i;
    } else
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
  }
  toUrl(e) {
    let t = this.memoizedURLs.get(e);
    if (t) return t;
    zl === "\\" && (e = e.replace(/\\/g, "/"));
    let i = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(e, i), i;
  }
};
var Ml = vu;
const cs = 39, an = 34, ei = 92, cn = 47, ti = 10, Vt = 32, ii = 12, si = 9, ri = 13, Yu = 91, Nu = 93, Tu = 40, Uu = 41, Ku = 123, Fu = 125, zu = 59, Hu = 42, Mu = 58, Ou = 64, ni = /[\t\n\f\r "#'()/;[\\\]{}]/g, li = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, Pu = /.[\r\n"'(/\\]/, un = /[\da-f]/i;
var Eu = function(e, t = {}) {
  let i = e.css.valueOf(), r = t.ignoreErrors, n, o, a, l, u, c, h, p, d, b, m = i.length, f = 0, G = [], S = [];
  function V() {
    return f;
  }
  function I(W) {
    throw e.error("Unclosed " + W, f);
  }
  function g() {
    return S.length === 0 && f >= m;
  }
  function R(W) {
    if (S.length) return S.pop();
    if (f >= m) return;
    let y = W ? W.ignoreUnclosed : !1;
    switch (n = i.charCodeAt(f), n) {
      case ti:
      case Vt:
      case si:
      case ri:
      case ii: {
        l = f;
        do
          l += 1, n = i.charCodeAt(l);
        while (n === Vt || n === ti || n === si || n === ri || n === ii);
        c = ["space", i.slice(f, l)], f = l - 1;
        break;
      }
      case Yu:
      case Nu:
      case Ku:
      case Fu:
      case Mu:
      case zu:
      case Uu: {
        let X = String.fromCharCode(n);
        c = [X, X, f];
        break;
      }
      case Tu: {
        if (b = G.length ? G.pop()[1] : "", d = i.charCodeAt(f + 1), b === "url" && d !== cs && d !== an && d !== Vt && d !== ti && d !== si && d !== ii && d !== ri) {
          l = f;
          do {
            if (h = !1, l = i.indexOf(")", l + 1), l === -1)
              if (r || y) {
                l = f;
                break;
              } else
                I("bracket");
            for (p = l; i.charCodeAt(p - 1) === ei; )
              p -= 1, h = !h;
          } while (h);
          c = ["brackets", i.slice(f, l + 1), f, l], f = l;
        } else
          l = i.indexOf(")", f + 1), o = i.slice(f, l + 1), l === -1 || Pu.test(o) ? c = ["(", "(", f] : (c = ["brackets", o, f, l], f = l);
        break;
      }
      case cs:
      case an: {
        u = n === cs ? "'" : '"', l = f;
        do {
          if (h = !1, l = i.indexOf(u, l + 1), l === -1)
            if (r || y) {
              l = f + 1;
              break;
            } else
              I("string");
          for (p = l; i.charCodeAt(p - 1) === ei; )
            p -= 1, h = !h;
        } while (h);
        c = ["string", i.slice(f, l + 1), f, l], f = l;
        break;
      }
      case Ou: {
        ni.lastIndex = f + 1, ni.test(i), ni.lastIndex === 0 ? l = i.length - 1 : l = ni.lastIndex - 2, c = ["at-word", i.slice(f, l + 1), f, l], f = l;
        break;
      }
      case ei: {
        for (l = f, a = !0; i.charCodeAt(l + 1) === ei; )
          l += 1, a = !a;
        if (n = i.charCodeAt(l + 1), a && n !== cn && n !== Vt && n !== ti && n !== si && n !== ri && n !== ii && (l += 1, un.test(i.charAt(l)))) {
          for (; un.test(i.charAt(l + 1)); )
            l += 1;
          i.charCodeAt(l + 1) === Vt && (l += 1);
        }
        c = ["word", i.slice(f, l + 1), f, l], f = l;
        break;
      }
      default: {
        n === cn && i.charCodeAt(f + 1) === Hu ? (l = i.indexOf("*/", f + 2) + 1, l === 0 && (r || y ? l = i.length : I("comment")), c = ["comment", i.slice(f, l + 1), f, l], f = l) : (li.lastIndex = f + 1, li.test(i), li.lastIndex === 0 ? l = i.length - 1 : l = li.lastIndex - 2, c = ["word", i.slice(f, l + 1), f, l], G.push(c), f = l);
        break;
      }
    }
    return f++, c;
  }
  function C(W) {
    S.push(W);
  }
  return {
    back: C,
    endOfFile: g,
    nextToken: R,
    position: V
  };
};
let Bu = dr, Qu = Oi, ju = Pi, Du = Et, hn = mr, Au = Eu;
const dn = {
  empty: !0,
  space: !0
};
function _u(s) {
  for (let e = s.length - 1; e >= 0; e--) {
    let t = s[e], i = t[3] || t[2];
    if (i) return i;
  }
}
let $u = class {
  constructor(e) {
    this.input = e, this.root = new Du(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(e) {
    let t = new Bu();
    t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]);
    let i, r, n, o = !1, a = !1, l = [], u = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), i = e[0], i === "(" || i === "[" ? u.push(i === "(" ? ")" : "]") : i === "{" && u.length > 0 ? u.push("}") : i === u[u.length - 1] && u.pop(), u.length === 0)
        if (i === ";") {
          t.source.end = this.getPosition(e[2]), t.source.end.offset++, this.semicolon = !0;
          break;
        } else if (i === "{") {
          a = !0;
          break;
        } else if (i === "}") {
          if (l.length > 0) {
            for (n = l.length - 1, r = l[n]; r && r[0] === "space"; )
              r = l[--n];
            r && (t.source.end = this.getPosition(r[3] || r[2]), t.source.end.offset++);
          }
          this.end(e);
          break;
        } else
          l.push(e);
      else
        l.push(e);
      if (this.tokenizer.endOfFile()) {
        o = !0;
        break;
      }
    }
    t.raws.between = this.spacesAndCommentsFromEnd(l), l.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(l), this.raw(t, "params", l), o && (e = l[l.length - 1], t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++, this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), a && (t.nodes = [], this.current = t);
  }
  checkMissedSemicolon(e) {
    let t = this.colon(e);
    if (t === !1) return;
    let i = 0, r;
    for (let n = t - 1; n >= 0 && (r = e[n], !(r[0] !== "space" && (i += 1, i === 2))); n--)
      ;
    throw this.input.error(
      "Missed semicolon",
      r[0] === "word" ? r[3] + 1 : r[2]
    );
  }
  colon(e) {
    let t = 0, i, r, n;
    for (let [o, a] of e.entries()) {
      if (r = a, n = r[0], n === "(" && (t += 1), n === ")" && (t -= 1), t === 0 && n === ":")
        if (!i)
          this.doubleColon(r);
        else {
          if (i[0] === "word" && i[1] === "progid")
            continue;
          return o;
        }
      i = r;
    }
    return !1;
  }
  comment(e) {
    let t = new Qu();
    this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++;
    let i = e[1].slice(2, -2);
    if (/^\s*$/.test(i))
      t.text = "", t.raws.left = i, t.raws.right = "";
    else {
      let r = i.match(/^(\s*)([^]*\S)(\s*)$/);
      t.text = r[2], t.raws.left = r[1], t.raws.right = r[3];
    }
  }
  createTokenizer() {
    this.tokenizer = Au(this.input);
  }
  decl(e, t) {
    let i = new ju();
    this.init(i, e[0][2]);
    let r = e[e.length - 1];
    for (r[0] === ";" && (this.semicolon = !0, e.pop()), i.source.end = this.getPosition(
      r[3] || r[2] || _u(e)
    ), i.source.end.offset++; e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), i.raws.before += e.shift()[1];
    for (i.source.start = this.getPosition(e[0][2]), i.prop = ""; e.length; ) {
      let u = e[0][0];
      if (u === ":" || u === "space" || u === "comment")
        break;
      i.prop += e.shift()[1];
    }
    i.raws.between = "";
    let n;
    for (; e.length; )
      if (n = e.shift(), n[0] === ":") {
        i.raws.between += n[1];
        break;
      } else
        n[0] === "word" && /\w/.test(n[1]) && this.unknownWord([n]), i.raws.between += n[1];
    (i.prop[0] === "_" || i.prop[0] === "*") && (i.raws.before += i.prop[0], i.prop = i.prop.slice(1));
    let o = [], a;
    for (; e.length && (a = e[0][0], !(a !== "space" && a !== "comment")); )
      o.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let u = e.length - 1; u >= 0; u--) {
      if (n = e[u], n[1].toLowerCase() === "!important") {
        i.important = !0;
        let c = this.stringFrom(e, u);
        c = this.spacesFromEnd(e) + c, c !== " !important" && (i.raws.important = c);
        break;
      } else if (n[1].toLowerCase() === "important") {
        let c = e.slice(0), h = "";
        for (let p = u; p > 0; p--) {
          let d = c[p][0];
          if (h.trim().startsWith("!") && d !== "space")
            break;
          h = c.pop()[1] + h;
        }
        h.trim().startsWith("!") && (i.important = !0, i.raws.important = h, e = c);
      }
      if (n[0] !== "space" && n[0] !== "comment")
        break;
    }
    e.some((u) => u[0] !== "space" && u[0] !== "comment") && (i.raws.between += o.map((u) => u[1]).join(""), o = []), this.raw(i, "value", o.concat(e), t), i.value.includes(":") && !t && this.checkMissedSemicolon(e);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  emptyRule(e) {
    let t = new hn();
    this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t;
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let t = this.current.nodes[this.current.nodes.length - 1];
      t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "", t.source.end = this.getPosition(e[2]), t.source.end.offset += t.raws.ownSemicolon.length);
    }
  }
  // Helpers
  getPosition(e) {
    let t = this.input.fromOffset(e);
    return {
      column: t.col,
      line: t.line,
      offset: e
    };
  }
  init(e, t) {
    this.current.push(e), e.source = {
      input: this.input,
      start: this.getPosition(t)
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  other(e) {
    let t = !1, i = null, r = !1, n = null, o = [], a = e[1].startsWith("--"), l = [], u = e;
    for (; u; ) {
      if (i = u[0], l.push(u), i === "(" || i === "[")
        n || (n = u), o.push(i === "(" ? ")" : "]");
      else if (a && r && i === "{")
        n || (n = u), o.push("}");
      else if (o.length === 0)
        if (i === ";")
          if (r) {
            this.decl(l, a);
            return;
          } else
            break;
        else if (i === "{") {
          this.rule(l);
          return;
        } else if (i === "}") {
          this.tokenizer.back(l.pop()), t = !0;
          break;
        } else i === ":" && (r = !0);
      else i === o[o.length - 1] && (o.pop(), o.length === 0 && (n = null));
      u = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (t = !0), o.length > 0 && this.unclosedBracket(n), t && r) {
      if (!a)
        for (; l.length && (u = l[l.length - 1][0], !(u !== "space" && u !== "comment")); )
          this.tokenizer.back(l.pop());
      this.decl(l, a);
    } else
      this.unknownWord(l);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(e, t, i, r) {
    let n, o, a = i.length, l = "", u = !0, c, h;
    for (let p = 0; p < a; p += 1)
      n = i[p], o = n[0], o === "space" && p === a - 1 && !r ? u = !1 : o === "comment" ? (h = i[p - 1] ? i[p - 1][0] : "empty", c = i[p + 1] ? i[p + 1][0] : "empty", !dn[h] && !dn[c] ? l.slice(-1) === "," ? u = !1 : l += n[1] : u = !1) : l += n[1];
    if (!u) {
      let p = i.reduce((d, b) => d + b[1], "");
      e.raws[t] = { raw: p, value: l };
    }
    e[t] = l;
  }
  rule(e) {
    e.pop();
    let t = new hn();
    this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t;
  }
  spacesAndCommentsFromEnd(e) {
    let t, i = "";
    for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment")); )
      i = e.pop()[1] + i;
    return i;
  }
  // Errors
  spacesAndCommentsFromStart(e) {
    let t, i = "";
    for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment")); )
      i += e.shift()[1];
    return i;
  }
  spacesFromEnd(e) {
    let t, i = "";
    for (; e.length && (t = e[e.length - 1][0], t === "space"); )
      i = e.pop()[1] + i;
    return i;
  }
  stringFrom(e, t) {
    let i = "";
    for (let r = t; r < e.length; r++)
      i += e[r][1];
    return e.splice(t, e.length - t), i;
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word " + e[0][1],
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unnamedAtrule(e, t) {
    throw this.input.error(
      "At-rule without name",
      { offset: t[2] },
      { offset: t[2] + t[1].length }
    );
  }
};
var qu = $u;
let eh = _e, th = Ei, ih = qu;
function Ji(s, e) {
  let t = new th(s, e), i = new ih(t);
  try {
    i.parse();
  } catch (r) {
    throw process.env.NODE_ENV !== "production" && r.name === "CssSyntaxError" && e && e.from && (/\.scss$/i.test(e.from) ? r.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(e.from) ? r.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(e.from) && (r.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), r;
  }
  return i.root;
}
var fr = Ji;
Ji.default = Ji;
eh.registerParse(Ji);
let Js = class {
  constructor(e, t = {}) {
    if (this.type = "warning", this.text = e, t.node && t.node.source) {
      let i = t.node.rangeBy(t);
      this.line = i.start.line, this.column = i.start.column, this.endLine = i.end.line, this.endColumn = i.end.column;
    }
    for (let i in t) this[i] = t[i];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      index: this.index,
      plugin: this.plugin,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var Ol = Js;
Js.default = Js;
let sh = Ol, vs = class {
  get content() {
    return this.css;
  }
  constructor(e, t, i) {
    this.processor = e, this.messages = [], this.root = t, this.opts = i, this.css = "", this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, t = {}) {
    t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin);
    let i = new sh(e, t);
    return this.messages.push(i), i;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
};
var br = vs;
vs.default = vs;
let pn = {};
var Pl = function(e) {
  pn[e] || (pn[e] = !0, typeof console != "undefined" && console.warn && console.warn(e));
};
let rh = _e, nh = pr, lh = Ml, oh = fr, mn = br, ah = Et, ch = Hi, { isClean: Xe, my: uh } = Pt, hh = Pl;
const dh = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
}, ph = {
  AtRule: !0,
  AtRuleExit: !0,
  Comment: !0,
  CommentExit: !0,
  Declaration: !0,
  DeclarationExit: !0,
  Document: !0,
  DocumentExit: !0,
  Once: !0,
  OnceExit: !0,
  postcssPlugin: !0,
  prepare: !0,
  Root: !0,
  RootExit: !0,
  Rule: !0,
  RuleExit: !0
}, mh = {
  Once: !0,
  postcssPlugin: !0,
  prepare: !0
}, ht = 0;
function St(s) {
  return typeof s == "object" && typeof s.then == "function";
}
function El(s) {
  let e = !1, t = dh[s.type];
  return s.type === "decl" ? e = s.prop.toLowerCase() : s.type === "atrule" && (e = s.name.toLowerCase()), e && s.append ? [
    t,
    t + "-" + e,
    ht,
    t + "Exit",
    t + "Exit-" + e
  ] : e ? [t, t + "-" + e, t + "Exit", t + "Exit-" + e] : s.append ? [t, ht, t + "Exit"] : [t, t + "Exit"];
}
function fn(s) {
  let e;
  return s.type === "document" ? e = ["Document", ht, "DocumentExit"] : s.type === "root" ? e = ["Root", ht, "RootExit"] : e = El(s), {
    eventIndex: 0,
    events: e,
    iterator: 0,
    node: s,
    visitorIndex: 0,
    visitors: []
  };
}
function Ys(s) {
  return s[Xe] = !1, s.nodes && s.nodes.forEach((e) => Ys(e)), s;
}
let Ns = {}, dt = class Bl {
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
  constructor(e, t, i) {
    this.stringified = !1, this.processed = !1;
    let r;
    if (typeof t == "object" && t !== null && (t.type === "root" || t.type === "document"))
      r = Ys(t);
    else if (t instanceof Bl || t instanceof mn)
      r = Ys(t.root), t.map && (typeof i.map == "undefined" && (i.map = {}), i.map.inline || (i.map.inline = !1), i.map.prev = t.map);
    else {
      let n = oh;
      i.syntax && (n = i.syntax.parse), i.parser && (n = i.parser), n.parse && (n = n.parse);
      try {
        r = n(t, i);
      } catch (o) {
        this.processed = !0, this.error = o;
      }
      r && !r[uh] && rh.rebuild(r);
    }
    this.result = new mn(e, r, i), this.helpers = re(x({}, Ns), { postcss: Ns, result: this.result }), this.plugins = this.processor.plugins.map((n) => typeof n == "object" && n.prepare ? x(x({}, n), n.prepare(this.result)) : n);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, t) {
    let i = this.result.lastPlugin;
    try {
      if (t && t.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin)
        e.plugin = i.postcssPlugin, e.setMessage();
      else if (i.postcssVersion && process.env.NODE_ENV !== "production") {
        let r = i.postcssPlugin, n = i.postcssVersion, o = this.result.processor.version, a = n.split("."), l = o.split(".");
        (a[0] !== l[0] || parseInt(a[1]) > parseInt(l[1])) && console.error(
          "Unknown error from PostCSS plugin. Your current PostCSS version is " + o + ", but " + r + " uses " + n + ". Perhaps this is the source of the error below."
        );
      }
    } catch (r) {
      console && console.error && console.error(r);
    }
    return e;
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (t, i, r) => {
      this.listeners[i] || (this.listeners[i] = []), this.listeners[i].push([t, r]);
    };
    for (let t of this.plugins)
      if (typeof t == "object")
        for (let i in t) {
          if (!ph[i] && /^[A-Z]/.test(i))
            throw new Error(
              `Unknown event ${i} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!mh[i])
            if (typeof t[i] == "object")
              for (let r in t[i])
                r === "*" ? e(t, i, t[i][r]) : e(
                  t,
                  i + "-" + r.toLowerCase(),
                  t[i][r]
                );
            else typeof t[i] == "function" && e(t, i, t[i]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  runAsync() {
    return ne(this, null, function* () {
      this.plugin = 0;
      for (let e = 0; e < this.plugins.length; e++) {
        let t = this.plugins[e], i = this.runOnRoot(t);
        if (St(i))
          try {
            yield i;
          } catch (r) {
            throw this.handleError(r);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e = this.result.root;
        for (; !e[Xe]; ) {
          e[Xe] = !0;
          let t = [fn(e)];
          for (; t.length > 0; ) {
            let i = this.visitTick(t);
            if (St(i))
              try {
                yield i;
              } catch (r) {
                let n = t[t.length - 1].node;
                throw this.handleError(r, n);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [t, i] of this.listeners.OnceExit) {
            this.result.lastPlugin = t;
            try {
              if (e.type === "document") {
                let r = e.nodes.map(
                  (n) => i(n, this.helpers)
                );
                yield Promise.all(r);
              } else
                yield i(e, this.helpers);
            } catch (r) {
              throw this.handleError(r);
            }
          }
      }
      return this.processed = !0, this.stringify();
    });
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let t = this.result.root.nodes.map(
            (i) => e.Once(i, this.helpers)
          );
          return St(t[0]) ? Promise.all(t) : t;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (t) {
      throw this.handleError(t);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, t = ch;
    e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
    let r = new lh(t, this.result.root, this.result.opts).generate();
    return this.result.css = r[0], this.result.map = r[1], this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let t = this.runOnRoot(e);
      if (St(t))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Xe]; )
        e[Xe] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let t of e.nodes)
            this.visitSync(this.listeners.OnceExit, t);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  then(e, t) {
    return process.env.NODE_ENV !== "production" && ("from" in this.opts || hh(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this.css;
  }
  visitSync(e, t) {
    for (let [i, r] of e) {
      this.result.lastPlugin = i;
      let n;
      try {
        n = r(t, this.helpers);
      } catch (o) {
        throw this.handleError(o, t.proxyOf);
      }
      if (t.type !== "root" && t.type !== "document" && !t.parent)
        return !0;
      if (St(n))
        throw this.getAsyncError();
    }
  }
  visitTick(e) {
    let t = e[e.length - 1], { node: i, visitors: r } = t;
    if (i.type !== "root" && i.type !== "document" && !i.parent) {
      e.pop();
      return;
    }
    if (r.length > 0 && t.visitorIndex < r.length) {
      let [o, a] = r[t.visitorIndex];
      t.visitorIndex += 1, t.visitorIndex === r.length && (t.visitors = [], t.visitorIndex = 0), this.result.lastPlugin = o;
      try {
        return a(i.toProxy(), this.helpers);
      } catch (l) {
        throw this.handleError(l, i);
      }
    }
    if (t.iterator !== 0) {
      let o = t.iterator, a;
      for (; a = i.nodes[i.indexes[o]]; )
        if (i.indexes[o] += 1, !a[Xe]) {
          a[Xe] = !0, e.push(fn(a));
          return;
        }
      t.iterator = 0, delete i.indexes[o];
    }
    let n = t.events;
    for (; t.eventIndex < n.length; ) {
      let o = n[t.eventIndex];
      if (t.eventIndex += 1, o === ht) {
        i.nodes && i.nodes.length && (i[Xe] = !0, t.iterator = i.getIterator());
        return;
      } else if (this.listeners[o]) {
        t.visitors = this.listeners[o];
        return;
      }
    }
    e.pop();
  }
  walkSync(e) {
    e[Xe] = !0;
    let t = El(e);
    for (let i of t)
      if (i === ht)
        e.nodes && e.each((r) => {
          r[Xe] || this.walkSync(r);
        });
      else {
        let r = this.listeners[i];
        if (r && this.visitSync(r, e.toProxy()))
          return;
      }
  }
  warnings() {
    return this.sync().warnings();
  }
};
dt.registerPostcss = (s) => {
  Ns = s;
};
var Ql = dt;
dt.default = dt;
ah.registerLazyResult(dt);
nh.registerLazyResult(dt);
let fh = Ml, bh = fr;
const yh = br;
let gh = Hi, Zh = Pl, Ts = class {
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, t = bh;
    try {
      e = t(this._css, this._opts);
    } catch (i) {
      this.error = i;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
  constructor(e, t, i) {
    t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = i, this._map = void 0;
    let r, n = gh;
    this.result = new yh(this._processor, r, this._opts), this.result.css = t;
    let o = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return o.root;
      }
    });
    let a = new fh(n, r, this._opts, t);
    if (a.isMap()) {
      let [l, u] = a.generate();
      l && (this.result.css = l), u && (this.result.map = u);
    } else
      a.clearAnnotation(), this.result.css = a.css;
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(e, t) {
    return process.env.NODE_ENV !== "production" && ("from" in this._opts || Zh(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
};
var Gh = Ts;
Ts.default = Ts;
let Vh = pr, Sh = Ql, Ih = Gh, Xh = Et, Ut = class {
  constructor(e = []) {
    this.version = "8.5.6", this.plugins = this.normalize(e);
  }
  normalize(e) {
    let t = [];
    for (let i of e)
      if (i.postcss === !0 ? i = i() : i.postcss && (i = i.postcss), typeof i == "object" && Array.isArray(i.plugins))
        t = t.concat(i.plugins);
      else if (typeof i == "object" && i.postcssPlugin)
        t.push(i);
      else if (typeof i == "function")
        t.push(i);
      else if (typeof i == "object" && (i.parse || i.stringify)) {
        if (process.env.NODE_ENV !== "production")
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
      } else
        throw new Error(i + " is not a PostCSS plugin");
    return t;
  }
  process(e, t = {}) {
    return !this.plugins.length && !t.parser && !t.stringifier && !t.syntax ? new Ih(this, e, t) : new Sh(this, e, t);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
};
var Wh = Ut;
Ut.default = Ut;
Xh.registerProcessor(Ut);
Vh.registerProcessor(Ut);
let jl = dr, Dl = Oi, Rh = _e, Ch = cr, Al = Pi, _l = pr, wh = xu, xh = Ei, kh = Ql, Lh = Tl, Jh = Mi, vh = fr, yr = Wh, Yh = br, $l = Et, ql = mr, Nh = Hi, Th = Ol;
function z(...s) {
  return s.length === 1 && Array.isArray(s[0]) && (s = s[0]), new yr(s);
}
z.plugin = function(e, t) {
  let i = !1;
  function r(...o) {
    console && console.warn && !i && (i = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
      e + `: 里面 postcss.plugin 被弃用. 迁移指南:
https://www.w3ctech.com/topic/2226`
    ));
    let a = t(...o);
    return a.postcssPlugin = e, a.postcssVersion = new yr().version, a;
  }
  let n;
  return Object.defineProperty(r, "postcss", {
    get() {
      return n || (n = r()), n;
    }
  }), r.process = function(o, a, l) {
    return z([r(l)]).process(o, a);
  }, r;
};
z.stringify = Nh;
z.parse = vh;
z.fromJSON = wh;
z.list = Lh;
z.comment = (s) => new Dl(s);
z.atRule = (s) => new jl(s);
z.decl = (s) => new Al(s);
z.rule = (s) => new ql(s);
z.root = (s) => new $l(s);
z.document = (s) => new _l(s);
z.CssSyntaxError = Ch;
z.Declaration = Al;
z.Container = Rh;
z.Processor = yr;
z.Document = _l;
z.Comment = Dl;
z.Warning = Th;
z.AtRule = jl;
z.Result = Yh;
z.Input = xh;
z.Rule = ql;
z.Root = $l;
z.Node = Jh;
kh.registerPostcss(z);
z.default = z;
var Uh = Object.defineProperty, Kh = (s, e, t) => e in s ? Uh(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, ye = (s, e, t) => Kh(s, typeof e != "symbol" ? e + "" : e, t);
function Fh(s) {
  if (s.__esModule) return s;
  var e = s.default;
  if (typeof e == "function") {
    var t = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(s).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(s, i);
    Object.defineProperty(t, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return s[i];
      }
    });
  }), t;
}
var gr = { exports: {} }, J = String, eo = function() {
  return { isColorSupported: !1, reset: J, bold: J, dim: J, italic: J, underline: J, inverse: J, hidden: J, strikethrough: J, black: J, red: J, green: J, yellow: J, blue: J, magenta: J, cyan: J, white: J, gray: J, bgBlack: J, bgRed: J, bgGreen: J, bgYellow: J, bgBlue: J, bgMagenta: J, bgCyan: J, bgWhite: J, blackBright: J, redBright: J, greenBright: J, yellowBright: J, blueBright: J, magentaBright: J, cyanBright: J, whiteBright: J, bgBlackBright: J, bgRedBright: J, bgGreenBright: J, bgYellowBright: J, bgBlueBright: J, bgMagentaBright: J, bgCyanBright: J, bgWhiteBright: J };
};
gr.exports = eo();
gr.exports.createColors = eo;
var zh = gr.exports;
const Hh = {}, Mh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Hh
}, Symbol.toStringTag, { value: "Module" })), Se = /* @__PURE__ */ Fh(Mh);
let bn = zh, yn = Se, Us = class to extends Error {
  constructor(e, t, i, r, n, o) {
    super(e), this.name = "CssSyntaxError", this.reason = e, n && (this.file = n), r && (this.source = r), o && (this.plugin = o), typeof t != "undefined" && typeof i != "undefined" && (typeof t == "number" ? (this.line = t, this.column = i) : (this.line = t.line, this.column = t.column, this.endLine = i.line, this.endColumn = i.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, to);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line != "undefined" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source) return "";
    let t = this.source;
    e == null && (e = bn.isColorSupported);
    let i = (c) => c, r = (c) => c, n = (c) => c;
    if (e) {
      let { bold: c, gray: h, red: p } = bn.createColors(!0);
      r = (d) => c(p(d)), i = (d) => h(d), yn && (n = (d) => yn(d));
    }
    let o = t.split(/\r?\n/), a = Math.max(this.line - 3, 0), l = Math.min(this.line + 2, o.length), u = String(l).length;
    return o.slice(a, l).map((c, h) => {
      let p = a + 1 + h, d = " " + (" " + p).slice(-u) + " | ";
      if (p === this.line) {
        if (c.length > 160) {
          let m = 20, f = Math.max(0, this.column - m), G = Math.max(
            this.column + m,
            this.endColumn + m
          ), S = c.slice(f, G), V = i(d.replace(/\d/g, " ")) + c.slice(0, Math.min(this.column - 1, m - 1)).replace(/[^\t]/g, " ");
          return r(">") + i(d) + n(S) + `
 ` + V + r("^");
        }
        let b = i(d.replace(/\d/g, " ")) + c.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return r(">") + i(d) + n(c) + `
 ` + b + r("^");
      }
      return " " + i(d) + n(c);
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
};
var Zr = Us;
Us.default = Us;
const gn = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: !1
};
function Oh(s) {
  return s[0].toUpperCase() + s.slice(1);
}
let Ks = class {
  constructor(e) {
    this.builder = e;
  }
  atrule(e, t) {
    let i = "@" + e.name, r = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName != "undefined" ? i += e.raws.afterName : r && (i += " "), e.nodes)
      this.block(e, i + r);
    else {
      let n = (e.raws.between || "") + (t ? ";" : "");
      this.builder(i + r + n, e);
    }
  }
  beforeAfter(e, t) {
    let i;
    e.type === "decl" ? i = this.raw(e, null, "beforeDecl") : e.type === "comment" ? i = this.raw(e, null, "beforeComment") : t === "before" ? i = this.raw(e, null, "beforeRule") : i = this.raw(e, null, "beforeClose");
    let r = e.parent, n = 0;
    for (; r && r.type !== "root"; )
      n += 1, r = r.parent;
    if (i.includes(`
`)) {
      let o = this.raw(e, null, "indent");
      if (o.length)
        for (let a = 0; a < n; a++) i += o;
    }
    return i;
  }
  block(e, t) {
    let i = this.raw(e, "between", "beforeOpen");
    this.builder(t + i + "{", e, "start");
    let r;
    e.nodes && e.nodes.length ? (this.body(e), r = this.raw(e, "after")) : r = this.raw(e, "after", "emptyBody"), r && this.builder(r), this.builder("}", e, "end");
  }
  body(e) {
    let t = e.nodes.length - 1;
    for (; t > 0 && e.nodes[t].type === "comment"; )
      t -= 1;
    let i = this.raw(e, "semicolon");
    for (let r = 0; r < e.nodes.length; r++) {
      let n = e.nodes[r], o = this.raw(n, "before");
      o && this.builder(o), this.stringify(n, t !== r || i);
    }
  }
  comment(e) {
    let t = this.raw(e, "left", "commentLeft"), i = this.raw(e, "right", "commentRight");
    this.builder("/*" + t + e.text + i + "*/", e);
  }
  decl(e, t) {
    let i = this.raw(e, "between", "colon"), r = e.prop + i + this.rawValue(e, "value");
    e.important && (r += e.raws.important || " !important"), t && (r += ";"), this.builder(r, e);
  }
  document(e) {
    this.body(e);
  }
  raw(e, t, i) {
    let r;
    if (i || (i = t), t && (r = e.raws[t], typeof r != "undefined"))
      return r;
    let n = e.parent;
    if (i === "before" && (!n || n.type === "root" && n.first === e || n && n.type === "document"))
      return "";
    if (!n) return gn[i];
    let o = e.root();
    if (o.rawCache || (o.rawCache = {}), typeof o.rawCache[i] != "undefined")
      return o.rawCache[i];
    if (i === "before" || i === "after")
      return this.beforeAfter(e, i);
    {
      let a = "raw" + Oh(i);
      this[a] ? r = this[a](o, e) : o.walk((l) => {
        if (r = l.raws[t], typeof r != "undefined") return !1;
      });
    }
    return typeof r == "undefined" && (r = gn[i]), o.rawCache[i] = r, r;
  }
  rawBeforeClose(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length > 0 && typeof i.raws.after != "undefined")
        return t = i.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeComment(e, t) {
    let i;
    return e.walkComments((r) => {
      if (typeof r.raws.before != "undefined")
        return i = r.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
    }), typeof i == "undefined" ? i = this.raw(t, null, "beforeDecl") : i && (i = i.replace(/\S/g, "")), i;
  }
  rawBeforeDecl(e, t) {
    let i;
    return e.walkDecls((r) => {
      if (typeof r.raws.before != "undefined")
        return i = r.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
    }), typeof i == "undefined" ? i = this.raw(t, null, "beforeRule") : i && (i = i.replace(/\S/g, "")), i;
  }
  rawBeforeOpen(e) {
    let t;
    return e.walk((i) => {
      if (i.type !== "decl" && (t = i.raws.between, typeof t != "undefined"))
        return !1;
    }), t;
  }
  rawBeforeRule(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && (i.parent !== e || e.first !== i) && typeof i.raws.before != "undefined")
        return t = i.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawColon(e) {
    let t;
    return e.walkDecls((i) => {
      if (typeof i.raws.between != "undefined")
        return t = i.raws.between.replace(/[^\s:]/g, ""), !1;
    }), t;
  }
  rawEmptyBody(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length === 0 && (t = i.raws.after, typeof t != "undefined"))
        return !1;
    }), t;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let t;
    return e.walk((i) => {
      let r = i.parent;
      if (r && r !== e && r.parent && r.parent === e && typeof i.raws.before != "undefined") {
        let n = i.raws.before.split(`
`);
        return t = n[n.length - 1], t = t.replace(/\S/g, ""), !1;
      }
    }), t;
  }
  rawSemicolon(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length && i.last.type === "decl" && (t = i.raws.semicolon, typeof t != "undefined"))
        return !1;
    }), t;
  }
  rawValue(e, t) {
    let i = e[t], r = e.raws[t];
    return r && r.value === i ? r.raw : i;
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  stringify(e, t) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, t);
  }
};
var io = Ks;
Ks.default = Ks;
let Ph = io;
function Fs(s, e) {
  new Ph(e).stringify(s);
}
var Bi = Fs;
Fs.default = Fs;
var Bt = {};
Bt.isClean = Symbol("isClean");
Bt.my = Symbol("my");
let Eh = Zr, Bh = io, Qh = Bi, { isClean: It, my: jh } = Bt;
function zs(s, e) {
  let t = new s.constructor();
  for (let i in s) {
    if (!Object.prototype.hasOwnProperty.call(s, i) || i === "proxyCache") continue;
    let r = s[i], n = typeof r;
    i === "parent" && n === "object" ? e && (t[i] = e) : i === "source" ? t[i] = r : Array.isArray(r) ? t[i] = r.map((o) => zs(o, t)) : (n === "object" && r !== null && (r = zs(r)), t[i] = r);
  }
  return t;
}
function ke(s, e) {
  if (e && typeof e.offset != "undefined")
    return e.offset;
  let t = 1, i = 1, r = 0;
  for (let n = 0; n < s.length; n++) {
    if (i === e.line && t === e.column) {
      r = n;
      break;
    }
    s[n] === `
` ? (t = 1, i += 1) : t += 1;
  }
  return r;
}
let Hs = class {
  get proxyOf() {
    return this;
  }
  constructor(e = {}) {
    this.raws = {}, this[It] = !1, this[jh] = !0;
    for (let t in e)
      if (t === "nodes") {
        this.nodes = [];
        for (let i of e[t])
          typeof i.clone == "function" ? this.append(i.clone()) : this.append(i);
      } else
        this[t] = e[t];
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let t = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${t.input.from}:${t.start.line}:${t.start.column}$&`
      );
    }
    return e;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  assign(e = {}) {
    for (let t in e)
      this[t] = e[t];
    return this;
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  clone(e = {}) {
    let t = zs(this);
    for (let i in e)
      t[i] = e[i];
    return t;
  }
  cloneAfter(e = {}) {
    let t = this.clone(e);
    return this.parent.insertAfter(this, t), t;
  }
  cloneBefore(e = {}) {
    let t = this.clone(e);
    return this.parent.insertBefore(this, t), t;
  }
  error(e, t = {}) {
    if (this.source) {
      let { end: i, start: r } = this.rangeBy(t);
      return this.source.input.error(
        e,
        { column: r.column, line: r.line },
        { column: i.column, line: i.line },
        t
      );
    }
    return new Eh(e);
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : t === "root" ? () => e.root().toProxy() : e[t];
      },
      set(e, t, i) {
        return e[t] === i || (e[t] = i, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || /* c8 ignore next */
        t === "text") && e.markDirty()), !0;
      }
    };
  }
  /* c8 ignore next 3 */
  markClean() {
    this[It] = !0;
  }
  markDirty() {
    if (this[It]) {
      this[It] = !1;
      let e = this;
      for (; e = e.parent; )
        e[It] = !1;
    }
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  positionBy(e = {}) {
    let t = this.source.start;
    if (e.index)
      t = this.positionInside(e.index);
    else if (e.word) {
      let i = "document" in this.source.input ? this.source.input.document : this.source.input.css, n = i.slice(
        ke(i, this.source.start),
        ke(i, this.source.end)
      ).indexOf(e.word);
      n !== -1 && (t = this.positionInside(n));
    }
    return t;
  }
  positionInside(e) {
    let t = this.source.start.column, i = this.source.start.line, r = "document" in this.source.input ? this.source.input.document : this.source.input.css, n = ke(r, this.source.start), o = n + e;
    for (let a = n; a < o; a++)
      r[a] === `
` ? (t = 1, i += 1) : t += 1;
    return { column: t, line: i, offset: o };
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  rangeBy(e = {}) {
    let t = "document" in this.source.input ? this.source.input.document : this.source.input.css, i = {
      column: this.source.start.column,
      line: this.source.start.line,
      offset: ke(t, this.source.start)
    }, r = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line,
      offset: typeof this.source.end.offset == "number" ? (
        // `source.end.offset` is exclusive, so we don't need to add 1
        this.source.end.offset
      ) : (
        // Since line/column in this.source.end is inclusive,
        // the `sourceOffset(... , this.source.end)` returns an inclusive offset.
        // So, we add 1 to convert it to exclusive.
        ke(t, this.source.end) + 1
      )
    } : {
      column: i.column + 1,
      line: i.line,
      offset: i.offset + 1
    };
    if (e.word) {
      let o = t.slice(
        ke(t, this.source.start),
        ke(t, this.source.end)
      ).indexOf(e.word);
      o !== -1 && (i = this.positionInside(o), r = this.positionInside(o + e.word.length));
    } else
      e.start ? i = {
        column: e.start.column,
        line: e.start.line,
        offset: ke(t, e.start)
      } : e.index && (i = this.positionInside(e.index)), e.end ? r = {
        column: e.end.column,
        line: e.end.line,
        offset: ke(t, e.end)
      } : typeof e.endIndex == "number" ? r = this.positionInside(e.endIndex) : e.index && (r = this.positionInside(e.index + 1));
    return (r.line < i.line || r.line === i.line && r.column <= i.column) && (r = {
      column: i.column + 1,
      line: i.line,
      offset: i.offset + 1
    }), { end: r, start: i };
  }
  raw(e, t) {
    return new Bh().raw(this, e, t);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...e) {
    if (this.parent) {
      let t = this, i = !1;
      for (let r of e)
        r === this ? i = !0 : i ? (this.parent.insertAfter(t, r), t = r) : this.parent.insertBefore(t, r);
      i || this.remove();
    }
    return this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  toJSON(e, t) {
    let i = {}, r = t == null;
    t = t || /* @__PURE__ */ new Map();
    let n = 0;
    for (let o in this) {
      if (!Object.prototype.hasOwnProperty.call(this, o) || o === "parent" || o === "proxyCache") continue;
      let a = this[o];
      if (Array.isArray(a))
        i[o] = a.map((l) => typeof l == "object" && l.toJSON ? l.toJSON(null, t) : l);
      else if (typeof a == "object" && a.toJSON)
        i[o] = a.toJSON(null, t);
      else if (o === "source") {
        if (a == null) continue;
        let l = t.get(a.input);
        l == null && (l = n, t.set(a.input, n), n++), i[o] = {
          end: a.end,
          inputId: l,
          start: a.start
        };
      } else
        i[o] = a;
    }
    return r && (i.inputs = [...t.keys()].map((o) => o.toJSON())), i;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(e = Qh) {
    e.stringify && (e = e.stringify);
    let t = "";
    return e(this, (i) => {
      t += i;
    }), t;
  }
  warn(e, t, i = {}) {
    let r = { node: this };
    for (let n in i) r[n] = i[n];
    return e.warn(t, r);
  }
};
var Qi = Hs;
Hs.default = Hs;
let Dh = Qi, Ms = class extends Dh {
  constructor(e) {
    super(e), this.type = "comment";
  }
};
var ji = Ms;
Ms.default = Ms;
let Ah = Qi, Os = class extends Ah {
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
  constructor(e) {
    e && typeof e.value != "undefined" && typeof e.value != "string" && (e = re(x({}, e), { value: String(e.value) })), super(e), this.type = "decl";
  }
};
var Di = Os;
Os.default = Os;
let so = ji, ro = Di, _h = Qi, { isClean: no, my: lo } = Bt, Gr, oo, ao, Vr;
function co(s) {
  return s.map((e) => (e.nodes && (e.nodes = co(e.nodes)), delete e.source, e));
}
function uo(s) {
  if (s[no] = !1, s.proxyOf.nodes)
    for (let e of s.proxyOf.nodes)
      uo(e);
}
let Te = class ho extends _h {
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
  append(...e) {
    for (let t of e) {
      let i = this.normalize(t, this.last);
      for (let r of i) this.proxyOf.nodes.push(r);
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let t of this.nodes) t.cleanRaws(e);
  }
  each(e) {
    if (!this.proxyOf.nodes) return;
    let t = this.getIterator(), i, r;
    for (; this.indexes[t] < this.proxyOf.nodes.length && (i = this.indexes[t], r = e(this.proxyOf.nodes[i], i), r !== !1); )
      this.indexes[t] += 1;
    return delete this.indexes[t], r;
  }
  every(e) {
    return this.nodes.every(e);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : e[t] ? t === "each" || typeof t == "string" && t.startsWith("walk") ? (...i) => e[t](
          ...i.map((r) => typeof r == "function" ? (n, o) => r(n.toProxy(), o) : r)
        ) : t === "every" || t === "some" ? (i) => e[t](
          (r, ...n) => i(r.toProxy(), ...n)
        ) : t === "root" ? () => e.root().toProxy() : t === "nodes" ? e.nodes.map((i) => i.toProxy()) : t === "first" || t === "last" ? e[t].toProxy() : e[t] : e[t];
      },
      set(e, t, i) {
        return e[t] === i || (e[t] = i, (t === "name" || t === "params" || t === "selector") && e.markDirty()), !0;
      }
    };
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  insertAfter(e, t) {
    let i = this.index(e), r = this.normalize(t, this.proxyOf.nodes[i]).reverse();
    i = this.index(e);
    for (let o of r) this.proxyOf.nodes.splice(i + 1, 0, o);
    let n;
    for (let o in this.indexes)
      n = this.indexes[o], i < n && (this.indexes[o] = n + r.length);
    return this.markDirty(), this;
  }
  insertBefore(e, t) {
    let i = this.index(e), r = i === 0 ? "prepend" : !1, n = this.normalize(
      t,
      this.proxyOf.nodes[i],
      r
    ).reverse();
    i = this.index(e);
    for (let a of n) this.proxyOf.nodes.splice(i, 0, a);
    let o;
    for (let a in this.indexes)
      o = this.indexes[a], i <= o && (this.indexes[a] = o + n.length);
    return this.markDirty(), this;
  }
  normalize(e, t) {
    if (typeof e == "string")
      e = co(oo(e).nodes);
    else if (typeof e == "undefined")
      e = [];
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let r of e)
        r.parent && r.parent.removeChild(r, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let r of e)
        r.parent && r.parent.removeChild(r, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value == "undefined")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new ro(e)];
    } else if (e.selector || e.selectors)
      e = [new Vr(e)];
    else if (e.name)
      e = [new Gr(e)];
    else if (e.text)
      e = [new so(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((r) => (r[lo] || ho.rebuild(r), r = r.proxyOf, r.parent && r.parent.removeChild(r), r[no] && uo(r), r.raws || (r.raws = {}), typeof r.raws.before == "undefined" && t && typeof t.raws.before != "undefined" && (r.raws.before = t.raws.before.replace(/\S/g, "")), r.parent = this.proxyOf, r));
  }
  prepend(...e) {
    e = e.reverse();
    for (let t of e) {
      let i = this.normalize(t, this.first, "prepend").reverse();
      for (let r of i) this.proxyOf.nodes.unshift(r);
      for (let r in this.indexes)
        this.indexes[r] = this.indexes[r] + i.length;
    }
    return this.markDirty(), this;
  }
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes) e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let t;
    for (let i in this.indexes)
      t = this.indexes[i], t >= e && (this.indexes[i] = t - 1);
    return this.markDirty(), this;
  }
  replaceValues(e, t, i) {
    return i || (i = t, t = {}), this.walkDecls((r) => {
      t.props && !t.props.includes(r.prop) || t.fast && !r.value.includes(t.fast) || (r.value = r.value.replace(e, i));
    }), this.markDirty(), this;
  }
  some(e) {
    return this.nodes.some(e);
  }
  walk(e) {
    return this.each((t, i) => {
      let r;
      try {
        r = e(t, i);
      } catch (n) {
        throw t.addToError(n);
      }
      return r !== !1 && t.walk && (r = t.walk(e)), r;
    });
  }
  walkAtRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((i, r) => {
      if (i.type === "atrule" && e.test(i.name))
        return t(i, r);
    }) : this.walk((i, r) => {
      if (i.type === "atrule" && i.name === e)
        return t(i, r);
    }) : (t = e, this.walk((i, r) => {
      if (i.type === "atrule")
        return t(i, r);
    }));
  }
  walkComments(e) {
    return this.walk((t, i) => {
      if (t.type === "comment")
        return e(t, i);
    });
  }
  walkDecls(e, t) {
    return t ? e instanceof RegExp ? this.walk((i, r) => {
      if (i.type === "decl" && e.test(i.prop))
        return t(i, r);
    }) : this.walk((i, r) => {
      if (i.type === "decl" && i.prop === e)
        return t(i, r);
    }) : (t = e, this.walk((i, r) => {
      if (i.type === "decl")
        return t(i, r);
    }));
  }
  walkRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((i, r) => {
      if (i.type === "rule" && e.test(i.selector))
        return t(i, r);
    }) : this.walk((i, r) => {
      if (i.type === "rule" && i.selector === e)
        return t(i, r);
    }) : (t = e, this.walk((i, r) => {
      if (i.type === "rule")
        return t(i, r);
    }));
  }
};
Te.registerParse = (s) => {
  oo = s;
};
Te.registerRule = (s) => {
  Vr = s;
};
Te.registerAtRule = (s) => {
  Gr = s;
};
Te.registerRoot = (s) => {
  ao = s;
};
var $e = Te;
Te.default = Te;
Te.rebuild = (s) => {
  s.type === "atrule" ? Object.setPrototypeOf(s, Gr.prototype) : s.type === "rule" ? Object.setPrototypeOf(s, Vr.prototype) : s.type === "decl" ? Object.setPrototypeOf(s, ro.prototype) : s.type === "comment" ? Object.setPrototypeOf(s, so.prototype) : s.type === "root" && Object.setPrototypeOf(s, ao.prototype), s[lo] = !0, s.nodes && s.nodes.forEach((e) => {
    Te.rebuild(e);
  });
};
let po = $e, vi = class extends po {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
};
var Sr = vi;
vi.default = vi;
po.registerAtRule(vi);
let $h = $e, mo, fo, Kt = class extends $h {
  constructor(e) {
    super(x({ type: "document" }, e)), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new mo(new fo(), this, e).stringify();
  }
};
Kt.registerLazyResult = (s) => {
  mo = s;
};
Kt.registerProcessor = (s) => {
  fo = s;
};
var Ir = Kt;
Kt.default = Kt;
let qh = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", ed = (s = 21) => {
  let e = "", t = s | 0;
  for (; t--; )
    e += qh[Math.random() * 64 | 0];
  return e;
};
var td = { nanoid: ed };
let { existsSync: id, readFileSync: sd } = Se, { dirname: us, join: rd } = Se, { SourceMapConsumer: Zn, SourceMapGenerator: Gn } = Se;
function nd(s) {
  return Buffer ? Buffer.from(s, "base64").toString() : window.atob(s);
}
let Ps = class {
  constructor(e, t) {
    if (t.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let i = t.map ? t.map.prev : void 0, r = this.loadMap(t.from, i);
    !this.mapFile && t.from && (this.mapFile = t.from), this.mapFile && (this.root = us(this.mapFile)), r && (this.text = r);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new Zn(this.text)), this.consumerCache;
  }
  decodeInline(e) {
    let t = /^data:application\/json;charset=utf-?8;base64,/, i = /^data:application\/json;base64,/, r = /^data:application\/json;charset=utf-?8,/, n = /^data:application\/json,/, o = e.match(r) || e.match(n);
    if (o)
      return decodeURIComponent(e.substr(o[0].length));
    let a = e.match(t) || e.match(i);
    if (a)
      return nd(e.substr(a[0].length));
    let l = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + l);
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
  loadAnnotation(e) {
    let t = e.match(/\/\*\s*# sourceMappingURL=/g);
    if (!t) return;
    let i = e.lastIndexOf(t.pop()), r = e.indexOf("*/", i);
    i > -1 && r > -1 && (this.annotation = this.getAnnotationURL(e.substring(i, r)));
  }
  loadFile(e) {
    if (this.root = us(e), id(e))
      return this.mapFile = e, sd(e, "utf-8").toString().trim();
  }
  loadMap(e, t) {
    if (t === !1) return !1;
    if (t) {
      if (typeof t == "string")
        return t;
      if (typeof t == "function") {
        let i = t(e);
        if (i) {
          let r = this.loadFile(i);
          if (!r)
            throw new Error(
              "Unable to load previous source map: " + i.toString()
            );
          return r;
        }
      } else {
        if (t instanceof Zn)
          return Gn.fromSourceMap(t).toString();
        if (t instanceof Gn)
          return t.toString();
        if (this.isMap(t))
          return JSON.stringify(t);
        throw new Error(
          "Unsupported previous source map format: " + t.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let i = this.annotation;
        return e && (i = rd(us(e), i)), this.loadFile(i);
      }
    }
  }
  startWith(e, t) {
    return e ? e.substr(0, t.length) === t : !1;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var bo = Ps;
Ps.default = Ps;
let { nanoid: ld } = td, { isAbsolute: Es, resolve: Bs } = Se, { SourceMapConsumer: od, SourceMapGenerator: ad } = Se, { fileURLToPath: Vn, pathToFileURL: oi } = Se, Sn = Zr, cd = bo, hs = Se, ds = Symbol("lineToIndexCache"), ud = !!(od && ad), In = !!(Bs && Es);
function Xn(s) {
  if (s[ds]) return s[ds];
  let e = s.css.split(`
`), t = new Array(e.length), i = 0;
  for (let r = 0, n = e.length; r < n; r++)
    t[r] = i, i += e[r].length + 1;
  return s[ds] = t, t;
}
let Yi = class {
  get from() {
    return this.file || this.id;
  }
  constructor(e, t = {}) {
    if (e === null || typeof e == "undefined" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, this.document = this.css, t.document && (this.document = t.document.toString()), t.from && (!In || /^\w+:\/\//.test(t.from) || Es(t.from) ? this.file = t.from : this.file = Bs(t.from)), In && ud) {
      let i = new cd(this.css, t);
      if (i.text) {
        this.map = i;
        let r = i.consumer().file;
        !this.file && r && (this.file = this.mapResolve(r));
      }
    }
    this.file || (this.id = "<input css " + ld(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(e, t, i, r = {}) {
    let n, o, a, l, u;
    if (t && typeof t == "object") {
      let h = t, p = i;
      if (typeof h.offset == "number") {
        l = h.offset;
        let d = this.fromOffset(l);
        t = d.line, i = d.col;
      } else
        t = h.line, i = h.column, l = this.fromLineAndColumn(t, i);
      if (typeof p.offset == "number") {
        a = p.offset;
        let d = this.fromOffset(a);
        o = d.line, n = d.col;
      } else
        o = p.line, n = p.column, a = this.fromLineAndColumn(p.line, p.column);
    } else if (i)
      l = this.fromLineAndColumn(t, i);
    else {
      l = t;
      let h = this.fromOffset(l);
      t = h.line, i = h.col;
    }
    let c = this.origin(t, i, o, n);
    return c ? u = new Sn(
      e,
      c.endLine === void 0 ? c.line : { column: c.column, line: c.line },
      c.endLine === void 0 ? c.column : { column: c.endColumn, line: c.endLine },
      c.source,
      c.file,
      r.plugin
    ) : u = new Sn(
      e,
      o === void 0 ? t : { column: i, line: t },
      o === void 0 ? i : { column: n, line: o },
      this.css,
      this.file,
      r.plugin
    ), u.input = { column: i, endColumn: n, endLine: o, endOffset: a, line: t, offset: l, source: this.css }, this.file && (oi && (u.input.url = oi(this.file).toString()), u.input.file = this.file), u;
  }
  fromLineAndColumn(e, t) {
    return Xn(this)[e - 1] + t - 1;
  }
  fromOffset(e) {
    let t = Xn(this), i = t[t.length - 1], r = 0;
    if (e >= i)
      r = t.length - 1;
    else {
      let n = t.length - 2, o;
      for (; r < n; )
        if (o = r + (n - r >> 1), e < t[o])
          n = o - 1;
        else if (e >= t[o + 1])
          r = o + 1;
        else {
          r = o;
          break;
        }
    }
    return {
      col: e - t[r] + 1,
      line: r + 1
    };
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : Bs(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  origin(e, t, i, r) {
    if (!this.map) return !1;
    let n = this.map.consumer(), o = n.originalPositionFor({ column: t, line: e });
    if (!o.source) return !1;
    let a;
    typeof i == "number" && (a = n.originalPositionFor({ column: r, line: i }));
    let l;
    Es(o.source) ? l = oi(o.source) : l = new URL(
      o.source,
      this.map.consumer().sourceRoot || oi(this.map.mapFile)
    );
    let u = {
      column: o.column,
      endColumn: a && a.column,
      endLine: a && a.line,
      line: o.line,
      url: l.toString()
    };
    if (l.protocol === "file:")
      if (Vn)
        u.file = Vn(l);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let c = n.sourceContentFor(o.source);
    return c && (u.source = c), u;
  }
  toJSON() {
    let e = {};
    for (let t of ["hasBOM", "css", "file", "id"])
      this[t] != null && (e[t] = this[t]);
    return this.map && (e.map = x({}, this.map), e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
};
var Ai = Yi;
Yi.default = Yi;
hs && hs.registerInput && hs.registerInput(Yi);
let yo = $e, go, Zo, pt = class extends yo {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(e, t, i) {
    let r = super.normalize(e);
    if (t) {
      if (i === "prepend")
        this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;
      else if (this.first !== t)
        for (let n of r)
          n.raws.before = t.raws.before;
    }
    return r;
  }
  removeChild(e, t) {
    let i = this.index(e);
    return !t && i === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[i].raws.before), super.removeChild(e);
  }
  toResult(e = {}) {
    return new go(new Zo(), this, e).stringify();
  }
};
pt.registerLazyResult = (s) => {
  go = s;
};
pt.registerProcessor = (s) => {
  Zo = s;
};
var Qt = pt;
pt.default = pt;
yo.registerRoot(pt);
let Ft = {
  comma(s) {
    return Ft.split(s, [","], !0);
  },
  space(s) {
    let e = [" ", `
`, "	"];
    return Ft.split(s, e);
  },
  split(s, e, t) {
    let i = [], r = "", n = !1, o = 0, a = !1, l = "", u = !1;
    for (let c of s)
      u ? u = !1 : c === "\\" ? u = !0 : a ? c === l && (a = !1) : c === '"' || c === "'" ? (a = !0, l = c) : c === "(" ? o += 1 : c === ")" ? o > 0 && (o -= 1) : o === 0 && e.includes(c) && (n = !0), n ? (r !== "" && i.push(r.trim()), r = "", n = !1) : r += c;
    return (t || r !== "") && i.push(r.trim()), i;
  }
};
var Go = Ft;
Ft.default = Ft;
let Vo = $e, hd = Go, Ni = class extends Vo {
  get selectors() {
    return hd.comma(this.selector);
  }
  set selectors(e) {
    let t = this.selector ? this.selector.match(/,\s*/) : null, i = t ? t[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(i);
  }
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
};
var Xr = Ni;
Ni.default = Ni;
Vo.registerRule(Ni);
let dd = Sr, pd = ji, md = Di, fd = Ai, bd = bo, yd = Qt, gd = Xr;
function zt(s, e) {
  if (Array.isArray(s)) return s.map((o) => zt(o));
  let r = s, { inputs: t } = r, i = Qe(r, ["inputs"]);
  if (t) {
    e = [];
    for (let o of t) {
      let a = re(x({}, o), { __proto__: fd.prototype });
      a.map && (a.map = re(x({}, a.map), {
        __proto__: bd.prototype
      })), e.push(a);
    }
  }
  if (i.nodes && (i.nodes = s.nodes.map((o) => zt(o, e))), i.source) {
    let n = i.source, { inputId: o } = n, a = Qe(n, ["inputId"]);
    i.source = a, o != null && (i.source.input = e[o]);
  }
  if (i.type === "root")
    return new yd(i);
  if (i.type === "decl")
    return new md(i);
  if (i.type === "rule")
    return new gd(i);
  if (i.type === "comment")
    return new pd(i);
  if (i.type === "atrule")
    return new dd(i);
  throw new Error("Unknown node type: " + s.type);
}
var Zd = zt;
zt.default = zt;
let { dirname: Vi, relative: So, resolve: Io, sep: Xo } = Se, { SourceMapConsumer: Wo, SourceMapGenerator: Si } = Se, { pathToFileURL: Wn } = Se, Gd = Ai, Vd = !!(Wo && Si), Sd = !!(Vi && Io && So && Xo), Id = class {
  constructor(e, t, i, r) {
    this.stringify = e, this.mapOpts = i.map || {}, this.root = t, this.opts = i, this.css = r, this.originalCSS = r, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let t = `
`;
    this.css.includes(`\r
`) && (t = `\r
`), this.css += t + "/*# sourceMappingURL=" + e + " */";
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let t = this.toUrl(this.path(e.file)), i = e.root || Vi(e.file), r;
      this.mapOpts.sourcesContent === !1 ? (r = new Wo(e.text), r.sourcesContent && (r.sourcesContent = null)) : r = e.consumer(), this.map.applySourceMap(r, t, this.toUrl(this.path(i)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let t = this.root.nodes.length - 1; t >= 0; t--)
          e = this.root.nodes[t], e.type === "comment" && e.text.startsWith("# sourceMappingURL=") && this.root.removeChild(t);
      } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), Sd && Vd && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (t) => {
        e += t;
      }), [e];
    }
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = Si.fromSourceMap(e, {
        ignoreInvalidMapping: !0
      });
    } else
      this.map = new Si({
        file: this.outputFile(),
        ignoreInvalidMapping: !0
      }), this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new Si({
      file: this.outputFile(),
      ignoreInvalidMapping: !0
    });
    let e = 1, t = 1, i = "<no source>", r = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    }, n, o;
    this.stringify(this.root, (a, l, u) => {
      if (this.css += a, l && u !== "end" && (r.generated.line = e, r.generated.column = t - 1, l.source && l.source.start ? (r.source = this.sourcePath(l), r.original.line = l.source.start.line, r.original.column = l.source.start.column - 1, this.map.addMapping(r)) : (r.source = i, r.original.line = 1, r.original.column = 0, this.map.addMapping(r))), o = a.match(/\n/g), o ? (e += o.length, n = a.lastIndexOf(`
`), t = a.length - n) : t += a.length, l && u !== "start") {
        let c = l.parent || { raws: {} };
        (!(l.type === "decl" || l.type === "atrule" && !l.nodes) || l !== c.last || c.raws.semicolon) && (l.source && l.source.end ? (r.source = this.sourcePath(l), r.original.line = l.source.end.line, r.original.column = l.source.end.column - 1, r.generated.line = e, r.generated.column = t - 2, this.map.addMapping(r)) : (r.source = i, r.original.line = 1, r.original.column = 0, r.generated.line = e, r.generated.column = t - 1, this.map.addMapping(r)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation != "undefined" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  isInline() {
    if (typeof this.mapOpts.inline != "undefined")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e != "undefined" && e !== !0 ? !1 : this.previous().length ? this.previous().some((t) => t.inline) : !0;
  }
  isMap() {
    return typeof this.opts.map != "undefined" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent != "undefined" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(e) {
    if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e)) return e;
    let t = this.memoizedPaths.get(e);
    if (t) return t;
    let i = this.opts.to ? Vi(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (i = Vi(Io(i, this.mapOpts.annotation)));
    let r = So(i, e);
    return this.memoizedPaths.set(e, r), r;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let t = e.source.input.map;
            this.previousMaps.includes(t) || this.previousMaps.push(t);
          }
        });
      else {
        let e = new Gd(this.originalCSS, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((t) => {
        if (t.source) {
          let i = t.source.input.from;
          if (i && !e[i]) {
            e[i] = !0;
            let r = this.usesFileUrls ? this.toFileUrl(i) : this.toUrl(this.path(i));
            this.map.setSourceContent(r, t.source.input.css);
          }
        }
      });
    else if (this.css) {
      let t = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(t, this.css);
    }
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  toBase64(e) {
    return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  toFileUrl(e) {
    let t = this.memoizedFileURLs.get(e);
    if (t) return t;
    if (Wn) {
      let i = Wn(e).toString();
      return this.memoizedFileURLs.set(e, i), i;
    } else
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
  }
  toUrl(e) {
    let t = this.memoizedURLs.get(e);
    if (t) return t;
    Xo === "\\" && (e = e.replace(/\\/g, "/"));
    let i = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(e, i), i;
  }
};
var Ro = Id;
const ps = 39, Rn = 34, ai = 92, Cn = 47, ci = 10, Xt = 32, ui = 12, hi = 9, di = 13, Xd = 91, Wd = 93, Rd = 40, Cd = 41, wd = 123, xd = 125, kd = 59, Ld = 42, Jd = 58, vd = 64, pi = /[\t\n\f\r "#'()/;[\\\]{}]/g, mi = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, Yd = /.[\r\n"'(/\\]/, wn = /[\da-f]/i;
var Nd = function(e, t = {}) {
  let i = e.css.valueOf(), r = t.ignoreErrors, n, o, a, l, u, c, h, p, d, b, m = i.length, f = 0, G = [], S = [];
  function V() {
    return f;
  }
  function I(W) {
    throw e.error("Unclosed " + W, f);
  }
  function g() {
    return S.length === 0 && f >= m;
  }
  function R(W) {
    if (S.length) return S.pop();
    if (f >= m) return;
    let y = W ? W.ignoreUnclosed : !1;
    switch (n = i.charCodeAt(f), n) {
      case ci:
      case Xt:
      case hi:
      case di:
      case ui: {
        l = f;
        do
          l += 1, n = i.charCodeAt(l);
        while (n === Xt || n === ci || n === hi || n === di || n === ui);
        c = ["space", i.slice(f, l)], f = l - 1;
        break;
      }
      case Xd:
      case Wd:
      case wd:
      case xd:
      case Jd:
      case kd:
      case Cd: {
        let X = String.fromCharCode(n);
        c = [X, X, f];
        break;
      }
      case Rd: {
        if (b = G.length ? G.pop()[1] : "", d = i.charCodeAt(f + 1), b === "url" && d !== ps && d !== Rn && d !== Xt && d !== ci && d !== hi && d !== ui && d !== di) {
          l = f;
          do {
            if (h = !1, l = i.indexOf(")", l + 1), l === -1)
              if (r || y) {
                l = f;
                break;
              } else
                I("bracket");
            for (p = l; i.charCodeAt(p - 1) === ai; )
              p -= 1, h = !h;
          } while (h);
          c = ["brackets", i.slice(f, l + 1), f, l], f = l;
        } else
          l = i.indexOf(")", f + 1), o = i.slice(f, l + 1), l === -1 || Yd.test(o) ? c = ["(", "(", f] : (c = ["brackets", o, f, l], f = l);
        break;
      }
      case ps:
      case Rn: {
        u = n === ps ? "'" : '"', l = f;
        do {
          if (h = !1, l = i.indexOf(u, l + 1), l === -1)
            if (r || y) {
              l = f + 1;
              break;
            } else
              I("string");
          for (p = l; i.charCodeAt(p - 1) === ai; )
            p -= 1, h = !h;
        } while (h);
        c = ["string", i.slice(f, l + 1), f, l], f = l;
        break;
      }
      case vd: {
        pi.lastIndex = f + 1, pi.test(i), pi.lastIndex === 0 ? l = i.length - 1 : l = pi.lastIndex - 2, c = ["at-word", i.slice(f, l + 1), f, l], f = l;
        break;
      }
      case ai: {
        for (l = f, a = !0; i.charCodeAt(l + 1) === ai; )
          l += 1, a = !a;
        if (n = i.charCodeAt(l + 1), a && n !== Cn && n !== Xt && n !== ci && n !== hi && n !== di && n !== ui && (l += 1, wn.test(i.charAt(l)))) {
          for (; wn.test(i.charAt(l + 1)); )
            l += 1;
          i.charCodeAt(l + 1) === Xt && (l += 1);
        }
        c = ["word", i.slice(f, l + 1), f, l], f = l;
        break;
      }
      default: {
        n === Cn && i.charCodeAt(f + 1) === Ld ? (l = i.indexOf("*/", f + 2) + 1, l === 0 && (r || y ? l = i.length : I("comment")), c = ["comment", i.slice(f, l + 1), f, l], f = l) : (mi.lastIndex = f + 1, mi.test(i), mi.lastIndex === 0 ? l = i.length - 1 : l = mi.lastIndex - 2, c = ["word", i.slice(f, l + 1), f, l], G.push(c), f = l);
        break;
      }
    }
    return f++, c;
  }
  function C(W) {
    S.push(W);
  }
  return {
    back: C,
    endOfFile: g,
    nextToken: R,
    position: V
  };
};
let Td = Sr, Ud = ji, Kd = Di, Fd = Qt, xn = Xr, zd = Nd;
const kn = {
  empty: !0,
  space: !0
};
function Hd(s) {
  for (let e = s.length - 1; e >= 0; e--) {
    let t = s[e], i = t[3] || t[2];
    if (i) return i;
  }
}
let Md = class {
  constructor(e) {
    this.input = e, this.root = new Fd(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(e) {
    let t = new Td();
    t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]);
    let i, r, n, o = !1, a = !1, l = [], u = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), i = e[0], i === "(" || i === "[" ? u.push(i === "(" ? ")" : "]") : i === "{" && u.length > 0 ? u.push("}") : i === u[u.length - 1] && u.pop(), u.length === 0)
        if (i === ";") {
          t.source.end = this.getPosition(e[2]), t.source.end.offset++, this.semicolon = !0;
          break;
        } else if (i === "{") {
          a = !0;
          break;
        } else if (i === "}") {
          if (l.length > 0) {
            for (n = l.length - 1, r = l[n]; r && r[0] === "space"; )
              r = l[--n];
            r && (t.source.end = this.getPosition(r[3] || r[2]), t.source.end.offset++);
          }
          this.end(e);
          break;
        } else
          l.push(e);
      else
        l.push(e);
      if (this.tokenizer.endOfFile()) {
        o = !0;
        break;
      }
    }
    t.raws.between = this.spacesAndCommentsFromEnd(l), l.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(l), this.raw(t, "params", l), o && (e = l[l.length - 1], t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++, this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), a && (t.nodes = [], this.current = t);
  }
  checkMissedSemicolon(e) {
    let t = this.colon(e);
    if (t === !1) return;
    let i = 0, r;
    for (let n = t - 1; n >= 0 && (r = e[n], !(r[0] !== "space" && (i += 1, i === 2))); n--)
      ;
    throw this.input.error(
      "Missed semicolon",
      r[0] === "word" ? r[3] + 1 : r[2]
    );
  }
  colon(e) {
    let t = 0, i, r, n;
    for (let [o, a] of e.entries()) {
      if (r = a, n = r[0], n === "(" && (t += 1), n === ")" && (t -= 1), t === 0 && n === ":")
        if (!i)
          this.doubleColon(r);
        else {
          if (i[0] === "word" && i[1] === "progid")
            continue;
          return o;
        }
      i = r;
    }
    return !1;
  }
  comment(e) {
    let t = new Ud();
    this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++;
    let i = e[1].slice(2, -2);
    if (/^\s*$/.test(i))
      t.text = "", t.raws.left = i, t.raws.right = "";
    else {
      let r = i.match(/^(\s*)([^]*\S)(\s*)$/);
      t.text = r[2], t.raws.left = r[1], t.raws.right = r[3];
    }
  }
  createTokenizer() {
    this.tokenizer = zd(this.input);
  }
  decl(e, t) {
    let i = new Kd();
    this.init(i, e[0][2]);
    let r = e[e.length - 1];
    for (r[0] === ";" && (this.semicolon = !0, e.pop()), i.source.end = this.getPosition(
      r[3] || r[2] || Hd(e)
    ), i.source.end.offset++; e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), i.raws.before += e.shift()[1];
    for (i.source.start = this.getPosition(e[0][2]), i.prop = ""; e.length; ) {
      let u = e[0][0];
      if (u === ":" || u === "space" || u === "comment")
        break;
      i.prop += e.shift()[1];
    }
    i.raws.between = "";
    let n;
    for (; e.length; )
      if (n = e.shift(), n[0] === ":") {
        i.raws.between += n[1];
        break;
      } else
        n[0] === "word" && /\w/.test(n[1]) && this.unknownWord([n]), i.raws.between += n[1];
    (i.prop[0] === "_" || i.prop[0] === "*") && (i.raws.before += i.prop[0], i.prop = i.prop.slice(1));
    let o = [], a;
    for (; e.length && (a = e[0][0], !(a !== "space" && a !== "comment")); )
      o.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let u = e.length - 1; u >= 0; u--) {
      if (n = e[u], n[1].toLowerCase() === "!important") {
        i.important = !0;
        let c = this.stringFrom(e, u);
        c = this.spacesFromEnd(e) + c, c !== " !important" && (i.raws.important = c);
        break;
      } else if (n[1].toLowerCase() === "important") {
        let c = e.slice(0), h = "";
        for (let p = u; p > 0; p--) {
          let d = c[p][0];
          if (h.trim().startsWith("!") && d !== "space")
            break;
          h = c.pop()[1] + h;
        }
        h.trim().startsWith("!") && (i.important = !0, i.raws.important = h, e = c);
      }
      if (n[0] !== "space" && n[0] !== "comment")
        break;
    }
    e.some((u) => u[0] !== "space" && u[0] !== "comment") && (i.raws.between += o.map((u) => u[1]).join(""), o = []), this.raw(i, "value", o.concat(e), t), i.value.includes(":") && !t && this.checkMissedSemicolon(e);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  emptyRule(e) {
    let t = new xn();
    this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t;
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let t = this.current.nodes[this.current.nodes.length - 1];
      t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "", t.source.end = this.getPosition(e[2]), t.source.end.offset += t.raws.ownSemicolon.length);
    }
  }
  // Helpers
  getPosition(e) {
    let t = this.input.fromOffset(e);
    return {
      column: t.col,
      line: t.line,
      offset: e
    };
  }
  init(e, t) {
    this.current.push(e), e.source = {
      input: this.input,
      start: this.getPosition(t)
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  other(e) {
    let t = !1, i = null, r = !1, n = null, o = [], a = e[1].startsWith("--"), l = [], u = e;
    for (; u; ) {
      if (i = u[0], l.push(u), i === "(" || i === "[")
        n || (n = u), o.push(i === "(" ? ")" : "]");
      else if (a && r && i === "{")
        n || (n = u), o.push("}");
      else if (o.length === 0)
        if (i === ";")
          if (r) {
            this.decl(l, a);
            return;
          } else
            break;
        else if (i === "{") {
          this.rule(l);
          return;
        } else if (i === "}") {
          this.tokenizer.back(l.pop()), t = !0;
          break;
        } else i === ":" && (r = !0);
      else i === o[o.length - 1] && (o.pop(), o.length === 0 && (n = null));
      u = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (t = !0), o.length > 0 && this.unclosedBracket(n), t && r) {
      if (!a)
        for (; l.length && (u = l[l.length - 1][0], !(u !== "space" && u !== "comment")); )
          this.tokenizer.back(l.pop());
      this.decl(l, a);
    } else
      this.unknownWord(l);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(e, t, i, r) {
    let n, o, a = i.length, l = "", u = !0, c, h;
    for (let p = 0; p < a; p += 1)
      n = i[p], o = n[0], o === "space" && p === a - 1 && !r ? u = !1 : o === "comment" ? (h = i[p - 1] ? i[p - 1][0] : "empty", c = i[p + 1] ? i[p + 1][0] : "empty", !kn[h] && !kn[c] ? l.slice(-1) === "," ? u = !1 : l += n[1] : u = !1) : l += n[1];
    if (!u) {
      let p = i.reduce((d, b) => d + b[1], "");
      e.raws[t] = { raw: p, value: l };
    }
    e[t] = l;
  }
  rule(e) {
    e.pop();
    let t = new xn();
    this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t;
  }
  spacesAndCommentsFromEnd(e) {
    let t, i = "";
    for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment")); )
      i = e.pop()[1] + i;
    return i;
  }
  // Errors
  spacesAndCommentsFromStart(e) {
    let t, i = "";
    for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment")); )
      i += e.shift()[1];
    return i;
  }
  spacesFromEnd(e) {
    let t, i = "";
    for (; e.length && (t = e[e.length - 1][0], t === "space"); )
      i = e.pop()[1] + i;
    return i;
  }
  stringFrom(e, t) {
    let i = "";
    for (let r = t; r < e.length; r++)
      i += e[r][1];
    return e.splice(t, e.length - t), i;
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word " + e[0][1],
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unnamedAtrule(e, t) {
    throw this.input.error(
      "At-rule without name",
      { offset: t[2] },
      { offset: t[2] + t[1].length }
    );
  }
};
var Od = Md;
let Pd = $e, Ed = Ai, Bd = Od;
function Ti(s, e) {
  let t = new Ed(s, e), i = new Bd(t);
  try {
    i.parse();
  } catch (r) {
    throw process.env.NODE_ENV !== "production" && r.name === "CssSyntaxError" && e && e.from && (/\.scss$/i.test(e.from) ? r.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(e.from) ? r.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(e.from) && (r.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), r;
  }
  return i.root;
}
var Wr = Ti;
Ti.default = Ti;
Pd.registerParse(Ti);
let Qs = class {
  constructor(e, t = {}) {
    if (this.type = "warning", this.text = e, t.node && t.node.source) {
      let i = t.node.rangeBy(t);
      this.line = i.start.line, this.column = i.start.column, this.endLine = i.end.line, this.endColumn = i.end.column;
    }
    for (let i in t) this[i] = t[i];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      index: this.index,
      plugin: this.plugin,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var Co = Qs;
Qs.default = Qs;
let Qd = Co, js = class {
  get content() {
    return this.css;
  }
  constructor(e, t, i) {
    this.processor = e, this.messages = [], this.root = t, this.opts = i, this.css = "", this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, t = {}) {
    t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin);
    let i = new Qd(e, t);
    return this.messages.push(i), i;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
};
var Rr = js;
js.default = js;
let Ln = {};
var wo = function(e) {
  Ln[e] || (Ln[e] = !0, typeof console != "undefined" && console.warn && console.warn(e));
};
let jd = $e, Dd = Ir, Ad = Ro, _d = Wr, Jn = Rr, $d = Qt, qd = Bi, { isClean: We, my: ep } = Bt, tp = wo;
const ip = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
}, sp = {
  AtRule: !0,
  AtRuleExit: !0,
  Comment: !0,
  CommentExit: !0,
  Declaration: !0,
  DeclarationExit: !0,
  Document: !0,
  DocumentExit: !0,
  Once: !0,
  OnceExit: !0,
  postcssPlugin: !0,
  prepare: !0,
  Root: !0,
  RootExit: !0,
  Rule: !0,
  RuleExit: !0
}, rp = {
  Once: !0,
  postcssPlugin: !0,
  prepare: !0
}, mt = 0;
function Wt(s) {
  return typeof s == "object" && typeof s.then == "function";
}
function xo(s) {
  let e = !1, t = ip[s.type];
  return s.type === "decl" ? e = s.prop.toLowerCase() : s.type === "atrule" && (e = s.name.toLowerCase()), e && s.append ? [
    t,
    t + "-" + e,
    mt,
    t + "Exit",
    t + "Exit-" + e
  ] : e ? [t, t + "-" + e, t + "Exit", t + "Exit-" + e] : s.append ? [t, mt, t + "Exit"] : [t, t + "Exit"];
}
function vn(s) {
  let e;
  return s.type === "document" ? e = ["Document", mt, "DocumentExit"] : s.type === "root" ? e = ["Root", mt, "RootExit"] : e = xo(s), {
    eventIndex: 0,
    events: e,
    iterator: 0,
    node: s,
    visitorIndex: 0,
    visitors: []
  };
}
function Ds(s) {
  return s[We] = !1, s.nodes && s.nodes.forEach((e) => Ds(e)), s;
}
let As = {}, ft = class ko {
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
  constructor(e, t, i) {
    this.stringified = !1, this.processed = !1;
    let r;
    if (typeof t == "object" && t !== null && (t.type === "root" || t.type === "document"))
      r = Ds(t);
    else if (t instanceof ko || t instanceof Jn)
      r = Ds(t.root), t.map && (typeof i.map == "undefined" && (i.map = {}), i.map.inline || (i.map.inline = !1), i.map.prev = t.map);
    else {
      let n = _d;
      i.syntax && (n = i.syntax.parse), i.parser && (n = i.parser), n.parse && (n = n.parse);
      try {
        r = n(t, i);
      } catch (o) {
        this.processed = !0, this.error = o;
      }
      r && !r[ep] && jd.rebuild(r);
    }
    this.result = new Jn(e, r, i), this.helpers = re(x({}, As), { postcss: As, result: this.result }), this.plugins = this.processor.plugins.map((n) => typeof n == "object" && n.prepare ? x(x({}, n), n.prepare(this.result)) : n);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, t) {
    let i = this.result.lastPlugin;
    try {
      if (t && t.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin)
        e.plugin = i.postcssPlugin, e.setMessage();
      else if (i.postcssVersion && process.env.NODE_ENV !== "production") {
        let r = i.postcssPlugin, n = i.postcssVersion, o = this.result.processor.version, a = n.split("."), l = o.split(".");
        (a[0] !== l[0] || parseInt(a[1]) > parseInt(l[1])) && console.error(
          "Unknown error from PostCSS plugin. Your current PostCSS version is " + o + ", but " + r + " uses " + n + ". Perhaps this is the source of the error below."
        );
      }
    } catch (r) {
      console && console.error && console.error(r);
    }
    return e;
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (t, i, r) => {
      this.listeners[i] || (this.listeners[i] = []), this.listeners[i].push([t, r]);
    };
    for (let t of this.plugins)
      if (typeof t == "object")
        for (let i in t) {
          if (!sp[i] && /^[A-Z]/.test(i))
            throw new Error(
              `Unknown event ${i} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!rp[i])
            if (typeof t[i] == "object")
              for (let r in t[i])
                r === "*" ? e(t, i, t[i][r]) : e(
                  t,
                  i + "-" + r.toLowerCase(),
                  t[i][r]
                );
            else typeof t[i] == "function" && e(t, i, t[i]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  runAsync() {
    return ne(this, null, function* () {
      this.plugin = 0;
      for (let e = 0; e < this.plugins.length; e++) {
        let t = this.plugins[e], i = this.runOnRoot(t);
        if (Wt(i))
          try {
            yield i;
          } catch (r) {
            throw this.handleError(r);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e = this.result.root;
        for (; !e[We]; ) {
          e[We] = !0;
          let t = [vn(e)];
          for (; t.length > 0; ) {
            let i = this.visitTick(t);
            if (Wt(i))
              try {
                yield i;
              } catch (r) {
                let n = t[t.length - 1].node;
                throw this.handleError(r, n);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [t, i] of this.listeners.OnceExit) {
            this.result.lastPlugin = t;
            try {
              if (e.type === "document") {
                let r = e.nodes.map(
                  (n) => i(n, this.helpers)
                );
                yield Promise.all(r);
              } else
                yield i(e, this.helpers);
            } catch (r) {
              throw this.handleError(r);
            }
          }
      }
      return this.processed = !0, this.stringify();
    });
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let t = this.result.root.nodes.map(
            (i) => e.Once(i, this.helpers)
          );
          return Wt(t[0]) ? Promise.all(t) : t;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (t) {
      throw this.handleError(t);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, t = qd;
    e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
    let r = new Ad(t, this.result.root, this.result.opts).generate();
    return this.result.css = r[0], this.result.map = r[1], this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let t = this.runOnRoot(e);
      if (Wt(t))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[We]; )
        e[We] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let t of e.nodes)
            this.visitSync(this.listeners.OnceExit, t);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  then(e, t) {
    return process.env.NODE_ENV !== "production" && ("from" in this.opts || tp(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this.css;
  }
  visitSync(e, t) {
    for (let [i, r] of e) {
      this.result.lastPlugin = i;
      let n;
      try {
        n = r(t, this.helpers);
      } catch (o) {
        throw this.handleError(o, t.proxyOf);
      }
      if (t.type !== "root" && t.type !== "document" && !t.parent)
        return !0;
      if (Wt(n))
        throw this.getAsyncError();
    }
  }
  visitTick(e) {
    let t = e[e.length - 1], { node: i, visitors: r } = t;
    if (i.type !== "root" && i.type !== "document" && !i.parent) {
      e.pop();
      return;
    }
    if (r.length > 0 && t.visitorIndex < r.length) {
      let [o, a] = r[t.visitorIndex];
      t.visitorIndex += 1, t.visitorIndex === r.length && (t.visitors = [], t.visitorIndex = 0), this.result.lastPlugin = o;
      try {
        return a(i.toProxy(), this.helpers);
      } catch (l) {
        throw this.handleError(l, i);
      }
    }
    if (t.iterator !== 0) {
      let o = t.iterator, a;
      for (; a = i.nodes[i.indexes[o]]; )
        if (i.indexes[o] += 1, !a[We]) {
          a[We] = !0, e.push(vn(a));
          return;
        }
      t.iterator = 0, delete i.indexes[o];
    }
    let n = t.events;
    for (; t.eventIndex < n.length; ) {
      let o = n[t.eventIndex];
      if (t.eventIndex += 1, o === mt) {
        i.nodes && i.nodes.length && (i[We] = !0, t.iterator = i.getIterator());
        return;
      } else if (this.listeners[o]) {
        t.visitors = this.listeners[o];
        return;
      }
    }
    e.pop();
  }
  walkSync(e) {
    e[We] = !0;
    let t = xo(e);
    for (let i of t)
      if (i === mt)
        e.nodes && e.each((r) => {
          r[We] || this.walkSync(r);
        });
      else {
        let r = this.listeners[i];
        if (r && this.visitSync(r, e.toProxy()))
          return;
      }
  }
  warnings() {
    return this.sync().warnings();
  }
};
ft.registerPostcss = (s) => {
  As = s;
};
var Lo = ft;
ft.default = ft;
$d.registerLazyResult(ft);
Dd.registerLazyResult(ft);
let np = Ro, lp = Wr;
const op = Rr;
let ap = Bi, cp = wo, _s = class {
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, t = lp;
    try {
      e = t(this._css, this._opts);
    } catch (i) {
      this.error = i;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
  constructor(e, t, i) {
    t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = i, this._map = void 0;
    let r, n = ap;
    this.result = new op(this._processor, r, this._opts), this.result.css = t;
    let o = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return o.root;
      }
    });
    let a = new np(n, r, this._opts, t);
    if (a.isMap()) {
      let [l, u] = a.generate();
      l && (this.result.css = l), u && (this.result.map = u);
    } else
      a.clearAnnotation(), this.result.css = a.css;
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(e, t) {
    return process.env.NODE_ENV !== "production" && ("from" in this._opts || cp(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
};
var up = _s;
_s.default = _s;
let hp = Ir, dp = Lo, pp = up, mp = Qt, Ht = class {
  constructor(e = []) {
    this.version = "8.5.6", this.plugins = this.normalize(e);
  }
  normalize(e) {
    let t = [];
    for (let i of e)
      if (i.postcss === !0 ? i = i() : i.postcss && (i = i.postcss), typeof i == "object" && Array.isArray(i.plugins))
        t = t.concat(i.plugins);
      else if (typeof i == "object" && i.postcssPlugin)
        t.push(i);
      else if (typeof i == "function")
        t.push(i);
      else if (typeof i == "object" && (i.parse || i.stringify)) {
        if (process.env.NODE_ENV !== "production")
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
      } else
        throw new Error(i + " is not a PostCSS plugin");
    return t;
  }
  process(e, t = {}) {
    return !this.plugins.length && !t.parser && !t.stringifier && !t.syntax ? new pp(this, e, t) : new dp(this, e, t);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
};
var fp = Ht;
Ht.default = Ht;
mp.registerProcessor(Ht);
hp.registerProcessor(Ht);
let Jo = Sr, vo = ji, bp = $e, yp = Zr, Yo = Di, No = Ir, gp = Zd, Zp = Ai, Gp = Lo, Vp = Go, Sp = Qi, Ip = Wr, Cr = fp, Xp = Rr, To = Qt, Uo = Xr, Wp = Bi, Rp = Co;
function H(...s) {
  return s.length === 1 && Array.isArray(s[0]) && (s = s[0]), new Cr(s);
}
H.plugin = function(e, t) {
  let i = !1;
  function r(...o) {
    console && console.warn && !i && (i = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
      e + `: 里面 postcss.plugin 被弃用. 迁移指南:
https://www.w3ctech.com/topic/2226`
    ));
    let a = t(...o);
    return a.postcssPlugin = e, a.postcssVersion = new Cr().version, a;
  }
  let n;
  return Object.defineProperty(r, "postcss", {
    get() {
      return n || (n = r()), n;
    }
  }), r.process = function(o, a, l) {
    return H([r(l)]).process(o, a);
  }, r;
};
H.stringify = Wp;
H.parse = Ip;
H.fromJSON = gp;
H.list = Vp;
H.comment = (s) => new vo(s);
H.atRule = (s) => new Jo(s);
H.decl = (s) => new Yo(s);
H.rule = (s) => new Uo(s);
H.root = (s) => new To(s);
H.document = (s) => new No(s);
H.CssSyntaxError = yp;
H.Declaration = Yo;
H.Container = bp;
H.Processor = Cr;
H.Document = No;
H.Comment = vo;
H.Warning = Rp;
H.AtRule = Jo;
H.Result = Xp;
H.Input = Zp;
H.Rule = Uo;
H.Root = To;
H.Node = Sp;
Gp.registerPostcss(H);
H.default = H;
class wr {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
  constructor(...e) {
    ye(this, "parentElement", null), ye(this, "parentNode", null), ye(this, "ownerDocument"), ye(this, "firstChild", null), ye(this, "lastChild", null), ye(this, "previousSibling", null), ye(this, "nextSibling", null), ye(this, "ELEMENT_NODE", 1), ye(this, "TEXT_NODE", 3), ye(this, "nodeType"), ye(this, "nodeName"), ye(this, "RRNodeType");
  }
  get childNodes() {
    const e = [];
    let t = this.firstChild;
    for (; t; )
      e.push(t), t = t.nextSibling;
    return e;
  }
  contains(e) {
    if (e instanceof wr) {
      if (e.ownerDocument !== this.ownerDocument) return !1;
      if (e === this) return !0;
    } else return !1;
    for (; e.parentNode; ) {
      if (e.parentNode === this) return !0;
      e = e.parentNode;
    }
    return !1;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  appendChild(e) {
    throw new Error(
      "RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method."
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  insertBefore(e, t) {
    throw new Error(
      "RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method."
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeChild(e) {
    throw new Error(
      "RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method."
    );
  }
  toString() {
    return "RRNode";
  }
}
const Yn = {
  Node: ["childNodes", "parentNode", "parentElement", "textContent"],
  ShadowRoot: ["host", "styleSheets"],
  Element: ["shadowRoot", "querySelector", "querySelectorAll"],
  MutationObserver: []
}, Nn = {
  Node: ["contains", "getRootNode"],
  ShadowRoot: ["getSelection"],
  Element: [],
  MutationObserver: ["constructor"]
}, fi = {}, Cp = () => !!globalThis.Zone;
function xr(s) {
  if (fi[s])
    return fi[s];
  const e = globalThis[s], t = e.prototype, i = s in Yn ? Yn[s] : void 0, r = !!(i && // @ts-expect-error 2345
  i.every(
    (a) => {
      var l, u;
      return !!((u = (l = Object.getOwnPropertyDescriptor(t, a)) == null ? void 0 : l.get) != null && u.toString().includes("[native code]"));
    }
  )), n = s in Nn ? Nn[s] : void 0, o = !!(n && n.every(
    // @ts-expect-error 2345
    (a) => {
      var l;
      return typeof t[a] == "function" && ((l = t[a]) == null ? void 0 : l.toString().includes("[native code]"));
    }
  ));
  if (r && o && !Cp())
    return fi[s] = e.prototype, e.prototype;
  try {
    const a = document.createElement("iframe");
    document.body.appendChild(a);
    const l = a.contentWindow;
    if (!l) return e.prototype;
    const u = l[s].prototype;
    return document.body.removeChild(a), u ? fi[s] = u : t;
  } catch (a) {
    return t;
  }
}
const ms = {};
function Oe(s, e, t) {
  var i;
  const r = `${s}.${String(t)}`;
  if (ms[r])
    return ms[r].call(
      e
    );
  const n = xr(s), o = (i = Object.getOwnPropertyDescriptor(
    n,
    t
  )) == null ? void 0 : i.get;
  return o ? (ms[r] = o, o.call(e)) : e[t];
}
const fs = {};
function Ko(s, e, t) {
  const i = `${s}.${String(t)}`;
  if (fs[i])
    return fs[i].bind(
      e
    );
  const n = xr(s)[t];
  return typeof n != "function" ? e[t] : (fs[i] = n, n.bind(e));
}
function wp(s) {
  return Oe("Node", s, "childNodes");
}
function xp(s) {
  return Oe("Node", s, "parentNode");
}
function kp(s) {
  return Oe("Node", s, "parentElement");
}
function Lp(s) {
  return Oe("Node", s, "textContent");
}
function Jp(s, e) {
  return Ko("Node", s, "contains")(e);
}
function vp(s) {
  return Ko("Node", s, "getRootNode")();
}
function Yp(s) {
  return !s || !("host" in s) ? null : Oe("ShadowRoot", s, "host");
}
function Np(s) {
  return s.styleSheets;
}
function Tp(s) {
  return !s || !("shadowRoot" in s) ? null : Oe("Element", s, "shadowRoot");
}
function Up(s, e) {
  return Oe("Element", s, "querySelector")(e);
}
function Kp(s, e) {
  return Oe("Element", s, "querySelectorAll")(e);
}
function Fo() {
  return xr("MutationObserver").constructor;
}
function qe(s, e, t) {
  try {
    if (!(e in s))
      return () => {
      };
    const i = s[e], r = t(i);
    return typeof r == "function" && (r.prototype = r.prototype || {}, Object.defineProperties(r, {
      __rrweb_original__: {
        enumerable: !1,
        value: i
      }
    })), s[e] = r, () => {
      s[e] = i;
    };
  } catch (i) {
    return () => {
    };
  }
}
const N = {
  childNodes: wp,
  parentNode: xp,
  parentElement: kp,
  textContent: Lp,
  contains: Jp,
  getRootNode: vp,
  host: Yp,
  styleSheets: Np,
  shadowRoot: Tp,
  querySelector: Up,
  querySelectorAll: Kp,
  mutationObserver: Fo,
  patch: qe
};
function he(s, e, t = document) {
  const i = { capture: !0 };
  return t.addEventListener(s, e, i), () => t.removeEventListener(s, e, i);
}
const rt = `Please stop import mirror directly. Instead of that,\r
now you can use replayer.getMirror() to access the mirror instance of a replayer,\r
or you can use record.mirror to access the mirror instance during recording.`;
let Tn = {
  map: {},
  getId() {
    return console.error(rt), -1;
  },
  getNode() {
    return console.error(rt), null;
  },
  removeNodeFromMap() {
    console.error(rt);
  },
  has() {
    return console.error(rt), !1;
  },
  reset() {
    console.error(rt);
  }
};
typeof window != "undefined" && window.Proxy && window.Reflect && (Tn = new Proxy(Tn, {
  get(s, e, t) {
    return e === "map" && console.error(rt), Reflect.get(s, e, t);
  }
}));
function Mt(s, e, t = {}) {
  let i = null, r = 0;
  return function(...n) {
    const o = Date.now();
    !r && t.leading === !1 && (r = o);
    const a = e - (o - r), l = this;
    a <= 0 || a > e ? (i && (clearTimeout(i), i = null), r = o, s.apply(l, n)) : !i && t.trailing !== !1 && (i = setTimeout(() => {
      r = t.leading === !1 ? 0 : Date.now(), i = null, s.apply(l, n);
    }, a));
  };
}
function _i(s, e, t, i, r = window) {
  const n = r.Object.getOwnPropertyDescriptor(s, e);
  return r.Object.defineProperty(
    s,
    e,
    i ? t : {
      set(o) {
        setTimeout(() => {
          t.set.call(this, o);
        }, 0), n && n.set && n.set.call(this, o);
      }
    }
  ), () => _i(s, e, n || {}, !0);
}
let Ui = Date.now;
/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString()) || (Ui = () => (/* @__PURE__ */ new Date()).getTime());
function zo(s) {
  var e, t, i, r;
  const n = s.document;
  return {
    left: n.scrollingElement ? n.scrollingElement.scrollLeft : s.pageXOffset !== void 0 ? s.pageXOffset : n.documentElement.scrollLeft || (n == null ? void 0 : n.body) && ((e = N.parentElement(n.body)) == null ? void 0 : e.scrollLeft) || ((t = n == null ? void 0 : n.body) == null ? void 0 : t.scrollLeft) || 0,
    top: n.scrollingElement ? n.scrollingElement.scrollTop : s.pageYOffset !== void 0 ? s.pageYOffset : (n == null ? void 0 : n.documentElement.scrollTop) || (n == null ? void 0 : n.body) && ((i = N.parentElement(n.body)) == null ? void 0 : i.scrollTop) || ((r = n == null ? void 0 : n.body) == null ? void 0 : r.scrollTop) || 0
  };
}
function Ho() {
  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
}
function Mo() {
  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
}
function Oo(s) {
  return s ? s.nodeType === s.ELEMENT_NODE ? s : N.parentElement(s) : null;
}
const Fp = (s) => {
  try {
    if (s instanceof HTMLElement)
      return s.tagName === "CANVAS";
  } catch (e) {
    return !1;
  }
  return !1;
};
function oe(s, e, t, i) {
  if (!s)
    return !1;
  const r = Oo(s);
  if (!r)
    return !1;
  try {
    if (typeof e == "string") {
      if (r.classList.contains(e) || i && r.closest("." + e) !== null) return !0;
    } else if (wi(r, e, i)) return !0;
  } catch (n) {
  }
  return !!(t && (r.matches(t) || i && r.closest(t) !== null));
}
function zp(s, e) {
  return e.getId(s) !== -1;
}
function bs(s, e, t) {
  return s.tagName === "TITLE" && t.headTitleMutations ? !0 : e.getId(s) === vt;
}
function Po(s, e) {
  if (wt(s))
    return !1;
  const t = e.getId(s);
  if (!e.has(t))
    return !0;
  const i = N.parentNode(s);
  return i && i.nodeType === s.DOCUMENT_NODE ? !1 : i ? Po(i, e) : !0;
}
function $s(s) {
  return !!s.changedTouches;
}
function Hp(s = window) {
  "NodeList" in s && !s.NodeList.prototype.forEach && (s.NodeList.prototype.forEach = Array.prototype.forEach), "DOMTokenList" in s && !s.DOMTokenList.prototype.forEach && (s.DOMTokenList.prototype.forEach = Array.prototype.forEach);
}
function Eo(s, e) {
  return !!(s.nodeName === "IFRAME" && e.getMeta(s));
}
function Bo(s, e) {
  return !!(s.nodeName === "LINK" && s.nodeType === s.ELEMENT_NODE && s.getAttribute && s.getAttribute("rel") === "stylesheet" && e.getMeta(s));
}
function qs(s) {
  return s ? s instanceof wr && "shadowRoot" in s ? !!s.shadowRoot : !!N.shadowRoot(s) : !1;
}
class Mp {
  constructor() {
    Z(this, "id", 1), Z(this, "styleIDMap", /* @__PURE__ */ new WeakMap()), Z(this, "idStyleMap", /* @__PURE__ */ new Map());
  }
  getId(e) {
    var t;
    return (t = this.styleIDMap.get(e)) != null ? t : -1;
  }
  has(e) {
    return this.styleIDMap.has(e);
  }
  /**
   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.
   */
  add(e, t) {
    if (this.has(e)) return this.getId(e);
    let i;
    return t === void 0 ? i = this.id++ : i = t, this.styleIDMap.set(e, i), this.idStyleMap.set(i, e), i;
  }
  getStyle(e) {
    return this.idStyleMap.get(e) || null;
  }
  reset() {
    this.styleIDMap = /* @__PURE__ */ new WeakMap(), this.idStyleMap = /* @__PURE__ */ new Map(), this.id = 1;
  }
  generateId() {
    return this.id++;
  }
}
function Qo(s) {
  var e;
  let t = null;
  return "getRootNode" in s && ((e = N.getRootNode(s)) == null ? void 0 : e.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && N.host(N.getRootNode(s)) && (t = N.host(N.getRootNode(s))), t;
}
function Op(s) {
  let e = s, t;
  for (; t = Qo(e); )
    e = t;
  return e;
}
function Pp(s) {
  const e = s.ownerDocument;
  if (!e) return !1;
  const t = Op(s);
  return N.contains(e, t);
}
function jo(s) {
  const e = s.ownerDocument;
  return e ? N.contains(e, s) || Pp(s) : !1;
}
var K = /* @__PURE__ */ ((s) => (s[s.DomContentLoaded = 0] = "DomContentLoaded", s[s.Load = 1] = "Load", s[s.FullSnapshot = 2] = "FullSnapshot", s[s.IncrementalSnapshot = 3] = "IncrementalSnapshot", s[s.Meta = 4] = "Meta", s[s.Custom = 5] = "Custom", s[s.Plugin = 6] = "Plugin", s))(K || {}), T = /* @__PURE__ */ ((s) => (s[s.Mutation = 0] = "Mutation", s[s.MouseMove = 1] = "MouseMove", s[s.MouseInteraction = 2] = "MouseInteraction", s[s.Scroll = 3] = "Scroll", s[s.ViewportResize = 4] = "ViewportResize", s[s.Input = 5] = "Input", s[s.TouchMove = 6] = "TouchMove", s[s.MediaInteraction = 7] = "MediaInteraction", s[s.StyleSheetRule = 8] = "StyleSheetRule", s[s.CanvasMutation = 9] = "CanvasMutation", s[s.Font = 10] = "Font", s[s.Log = 11] = "Log", s[s.Drag = 12] = "Drag", s[s.StyleDeclaration = 13] = "StyleDeclaration", s[s.Selection = 14] = "Selection", s[s.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", s[s.CustomElement = 16] = "CustomElement", s))(T || {}), de = /* @__PURE__ */ ((s) => (s[s.MouseUp = 0] = "MouseUp", s[s.MouseDown = 1] = "MouseDown", s[s.Click = 2] = "Click", s[s.ContextMenu = 3] = "ContextMenu", s[s.DblClick = 4] = "DblClick", s[s.Focus = 5] = "Focus", s[s.Blur = 6] = "Blur", s[s.TouchStart = 7] = "TouchStart", s[s.TouchMove_Departed = 8] = "TouchMove_Departed", s[s.TouchEnd = 9] = "TouchEnd", s[s.TouchCancel = 10] = "TouchCancel", s))(de || {}), ze = /* @__PURE__ */ ((s) => (s[s.Mouse = 0] = "Mouse", s[s.Pen = 1] = "Pen", s[s.Touch = 2] = "Touch", s))(ze || {}), bt = /* @__PURE__ */ ((s) => (s[s["2D"] = 0] = "2D", s[s.WebGL = 1] = "WebGL", s[s.WebGL2 = 2] = "WebGL2", s))(bt || {}), nt = /* @__PURE__ */ ((s) => (s[s.Play = 0] = "Play", s[s.Pause = 1] = "Pause", s[s.Seeked = 2] = "Seeked", s[s.VolumeChange = 3] = "VolumeChange", s[s.RateChange = 4] = "RateChange", s))(nt || {}), Do = /* @__PURE__ */ ((s) => (s[s.Document = 0] = "Document", s[s.DocumentType = 1] = "DocumentType", s[s.Element = 2] = "Element", s[s.Text = 3] = "Text", s[s.CDATA = 4] = "CDATA", s[s.Comment = 5] = "Comment", s))(Do || {});
function Un(s) {
  return "__ln" in s;
}
class Ep {
  constructor() {
    Z(this, "length", 0), Z(this, "head", null), Z(this, "tail", null);
  }
  get(e) {
    if (e >= this.length)
      throw new Error("Position outside of list range");
    let t = this.head;
    for (let i = 0; i < e; i++)
      t = (t == null ? void 0 : t.next) || null;
    return t;
  }
  addNode(e) {
    const t = {
      value: e,
      previous: null,
      next: null
    };
    if (e.__ln = t, e.previousSibling && Un(e.previousSibling)) {
      const i = e.previousSibling.__ln.next;
      t.next = i, t.previous = e.previousSibling.__ln, e.previousSibling.__ln.next = t, i && (i.previous = t);
    } else if (e.nextSibling && Un(e.nextSibling) && e.nextSibling.__ln.previous) {
      const i = e.nextSibling.__ln.previous;
      t.previous = i, t.next = e.nextSibling.__ln, e.nextSibling.__ln.previous = t, i && (i.next = t);
    } else
      this.head && (this.head.previous = t), t.next = this.head, this.head = t;
    t.next === null && (this.tail = t), this.length++;
  }
  removeNode(e) {
    const t = e.__ln;
    this.head && (t.previous ? (t.previous.next = t.next, t.next ? t.next.previous = t.previous : this.tail = t.previous) : (this.head = t.next, this.head ? this.head.previous = null : this.tail = null), e.__ln && delete e.__ln, this.length--);
  }
}
const Kn = (s, e) => `${s}@${e}`;
class Bp {
  constructor() {
    Z(this, "frozen", !1), Z(this, "locked", !1), Z(this, "texts", []), Z(this, "attributes", []), Z(this, "attributeMap", /* @__PURE__ */ new WeakMap()), Z(this, "removes", []), Z(this, "mapRemoves", []), Z(this, "movedMap", {}), Z(this, "addedSet", /* @__PURE__ */ new Set()), Z(this, "movedSet", /* @__PURE__ */ new Set()), Z(this, "droppedSet", /* @__PURE__ */ new Set()), Z(this, "removesSubTreeCache", /* @__PURE__ */ new Set()), Z(this, "mutationCb"), Z(this, "blockClass"), Z(this, "blockSelector"), Z(this, "maskTextClass"), Z(this, "maskTextSelector"), Z(this, "inlineStylesheet"), Z(this, "maskInputOptions"), Z(this, "maskTextFn"), Z(this, "maskInputFn"), Z(this, "keepIframeSrcFn"), Z(this, "recordCanvas"), Z(this, "inlineImages"), Z(this, "inlineVideos"), Z(this, "privacySetting"), Z(this, "slimDOMOptions"), Z(this, "dataURLOptions"), Z(this, "doc"), Z(this, "mirror"), Z(this, "iframeManager"), Z(this, "stylesheetManager"), Z(this, "shadowDomManager"), Z(this, "canvasManager"), Z(this, "processedNodeManager"), Z(this, "unattachedDoc"), Z(this, "processMutations", (e) => {
      e.forEach(this.processMutation), this.emit();
    }), Z(this, "emit", () => {
      if (this.frozen || this.locked)
        return;
      const e = [], t = /* @__PURE__ */ new Set(), i = new Ep(), r = (l) => {
        let u = l, c = vt;
        for (; c === vt; )
          u = u && u.nextSibling, c = u && this.mirror.getId(u);
        return c;
      }, n = (l) => {
        const u = N.parentNode(l);
        if (!u || !jo(l))
          return;
        let c = !1;
        if (l.nodeType === Node.TEXT_NODE) {
          const b = u.tagName;
          if (b === "TEXTAREA")
            return;
          b === "STYLE" && this.addedSet.has(u) && (c = !0);
        }
        const h = wt(u) ? this.mirror.getId(Qo(l)) : this.mirror.getId(u), p = r(l);
        if (h === -1 || p === -1)
          return i.addNode(l);
        const d = ot(l, {
          doc: this.doc,
          mirror: this.mirror,
          blockClass: this.blockClass,
          blockSelector: this.blockSelector,
          maskTextClass: this.maskTextClass,
          maskTextSelector: this.maskTextSelector,
          skipChild: !0,
          newlyAddedElement: !0,
          inlineStylesheet: this.inlineStylesheet,
          maskInputOptions: this.maskInputOptions,
          maskTextFn: this.maskTextFn,
          maskInputFn: this.maskInputFn,
          slimDOMOptions: this.slimDOMOptions,
          dataURLOptions: this.dataURLOptions,
          recordCanvas: this.recordCanvas,
          inlineImages: this.inlineImages,
          inlineVideos: this.inlineVideos,
          privacySetting: this.privacySetting,
          onSerialize: (b) => {
            Eo(b, this.mirror) && this.iframeManager.addIframe(b), Bo(b, this.mirror) && this.stylesheetManager.trackLinkElement(
              b
            ), qs(l) && this.shadowDomManager.addShadowRoot(N.shadowRoot(l), this.doc);
          },
          onIframeLoad: (b, m) => {
            this.iframeManager.attachIframe(b, m), this.shadowDomManager.observeAttachShadow(b);
          },
          onStylesheetLoad: (b, m) => {
            this.stylesheetManager.attachLinkElement(b, m);
          },
          cssCaptured: c
        });
        d && (e.push({
          parentId: h,
          nextId: p,
          node: d
        }), t.add(d.id));
      };
      for (; this.mapRemoves.length; )
        this.mirror.removeNodeFromMap(this.mapRemoves.shift());
      for (const l of this.movedSet)
        Fn(this.removesSubTreeCache, l) && !this.movedSet.has(N.parentNode(l)) || n(l);
      for (const l of this.addedSet)
        !zn(this.droppedSet, l) && !Fn(this.removesSubTreeCache, l) || zn(this.movedSet, l) ? n(l) : this.droppedSet.add(l);
      let o = null;
      for (; i.length; ) {
        let l = null;
        if (o) {
          const u = this.mirror.getId(N.parentNode(o.value)), c = r(o.value);
          u !== -1 && c !== -1 && (l = o);
        }
        if (!l) {
          let u = i.tail;
          for (; u; ) {
            const c = u;
            if (u = u.previous, c) {
              const h = this.mirror.getId(N.parentNode(c.value));
              if (r(c.value) === -1) continue;
              if (h !== -1) {
                l = c;
                break;
              } else {
                const d = c.value, b = N.parentNode(d);
                if (b && b.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                  const m = N.host(b);
                  if (this.mirror.getId(m) !== -1) {
                    l = c;
                    break;
                  }
                }
              }
            }
          }
        }
        if (!l) {
          for (; i.head; )
            i.removeNode(i.head.value);
          break;
        }
        o = l.previous, i.removeNode(l.value), n(l.value);
      }
      const a = {
        texts: this.texts.map((l) => {
          var u, c;
          const h = l.node, p = N.parentNode(h);
          p && p.tagName === "TEXTAREA" && this.genTextAreaValueMutation(p);
          let d = l.value;
          const b = this.privacySetting === "strict", m = this.privacySetting === "default" && hl(d), f = (c = (u = l.node) == null ? void 0 : u.parentElement) == null ? void 0 : c.getAttribute("data-hl-record");
          return (b || m) && !f && d && (d = lr(d)), {
            id: this.mirror.getId(h),
            value: d
          };
        }).filter((l) => !t.has(l.id)).filter((l) => this.mirror.has(l.id)),
        attributes: this.attributes.map((l) => {
          const { attributes: u } = l;
          if (typeof u.style == "string") {
            const c = JSON.stringify(l.styleDiff), h = JSON.stringify(l._unchangedStyles);
            c.length < u.style.length && (c + h).split("var(").length === u.style.split("var(").length && (u.style = l.styleDiff);
          }
          return {
            id: this.mirror.getId(l.node),
            attributes: u
          };
        }).filter((l) => !t.has(l.id)).filter((l) => this.mirror.has(l.id)),
        removes: this.removes,
        adds: e
      };
      !a.texts.length && !a.attributes.length && !a.removes.length && !a.adds.length || (this.texts = [], this.attributes = [], this.attributeMap = /* @__PURE__ */ new WeakMap(), this.removes = [], this.addedSet = /* @__PURE__ */ new Set(), this.movedSet = /* @__PURE__ */ new Set(), this.droppedSet = /* @__PURE__ */ new Set(), this.removesSubTreeCache = /* @__PURE__ */ new Set(), this.movedMap = {}, this.mutationCb(a));
    }), Z(this, "genTextAreaValueMutation", (e) => {
      let t = this.attributeMap.get(e);
      t || (t = {
        node: e,
        attributes: {},
        styleDiff: {},
        _unchangedStyles: {}
      }, this.attributes.push(t), this.attributeMap.set(e, t));
      const i = Array.from(
        N.childNodes(e),
        (r) => N.textContent(r) || ""
      ).join("");
      t.attributes.value = Wi({
        overwriteRecord: null,
        element: e,
        maskInputOptions: this.maskInputOptions,
        tagName: e.tagName,
        type: Ri(e),
        value: i,
        maskInputFn: this.maskInputFn
      });
    }), Z(this, "processMutation", (e) => {
      if (!bs(e.target, this.mirror, this.slimDOMOptions))
        switch (e.type) {
          case "characterData": {
            const t = N.textContent(e.target);
            !oe(e.target, this.blockClass, this.blockSelector, !1) && t !== e.oldValue && this.texts.push({
              value: bl(
                e.target,
                this.maskTextClass,
                this.maskTextSelector,
                !0
                // checkAncestors
              ) && t ? this.maskTextFn ? this.maskTextFn(t, Oo(e.target)) : t.replace(/[\S]/g, "*") : t,
              node: e.target
            });
            break;
          }
          case "attributes": {
            const t = e.target;
            let i = e.attributeName, r = e.target.getAttribute(i);
            if (i === "value") {
              const o = Ri(t);
              r = Wi({
                element: t,
                maskInputOptions: this.maskInputOptions,
                tagName: t.tagName,
                type: o,
                value: r,
                overwriteRecord: t.getAttribute("data-hl-record"),
                maskInputFn: this.maskInputFn
              });
            }
            if (oe(e.target, this.blockClass, this.blockSelector, !1) || r === e.oldValue)
              return;
            let n = this.attributeMap.get(e.target);
            if (t.tagName === "IFRAME" && i === "src" && !this.keepIframeSrcFn(r))
              if (!t.contentDocument)
                i = "rr_src";
              else
                return;
            if (n || (n = {
              node: e.target,
              attributes: {},
              styleDiff: {},
              _unchangedStyles: {}
            }, this.attributes.push(n), this.attributeMap.set(e.target, n)), i === "type" && t.tagName === "INPUT" && (e.oldValue || "").toLowerCase() === "password" && t.setAttribute("data-rr-is-password", "true"), !fl(t.tagName, i)) {
              if (e.target.tagName === "INPUT") {
                const a = e.target;
                if (a.type === "password") {
                  n.attributes.value = "*".repeat(a.value.length);
                  break;
                }
              }
              if (n.attributes[i] = ml(
                this.doc,
                ct(t.tagName),
                ct(i),
                r
              ), i === "style") {
                if (!this.unattachedDoc)
                  try {
                    this.unattachedDoc = document.implementation.createHTMLDocument();
                  } catch (l) {
                    this.unattachedDoc = this.doc;
                  }
                const a = this.unattachedDoc.createElement("span");
                e.oldValue && a.setAttribute("style", e.oldValue);
                for (const l of Array.from(t.style)) {
                  const u = t.style.getPropertyValue(l), c = t.style.getPropertyPriority(l);
                  u !== a.style.getPropertyValue(l) || c !== a.style.getPropertyPriority(l) ? c === "" ? n.styleDiff[l] = u : n.styleDiff[l] = [u, c] : n._unchangedStyles[l] = [u, c];
                }
                for (const l of Array.from(a.style))
                  t.style.getPropertyValue(l) === "" && (n.styleDiff[l] = !1);
              } else i === "open" && t.tagName === "DIALOG" && (t.matches("dialog:modal") ? n.attributes.rr_open_mode = "modal" : n.attributes.rr_open_mode = "non-modal");
            }
            break;
          }
          case "childList": {
            if (oe(e.target, this.blockClass, this.blockSelector, !0))
              return;
            if (e.target.tagName === "TEXTAREA") {
              this.genTextAreaValueMutation(e.target);
              return;
            }
            e.addedNodes.forEach((t) => this.genAdds(t, e.target)), e.removedNodes.forEach((t) => {
              const i = this.mirror.getId(t), r = wt(e.target) ? this.mirror.getId(N.host(e.target)) : this.mirror.getId(e.target);
              oe(e.target, this.blockClass, this.blockSelector, !1) || bs(t, this.mirror, this.slimDOMOptions) || !zp(t, this.mirror) || (this.addedSet.has(t) ? (er(this.addedSet, t), this.droppedSet.add(t)) : this.addedSet.has(e.target) && i === -1 || Po(e.target, this.mirror) || (this.movedSet.has(t) && this.movedMap[Kn(i, r)] ? er(this.movedSet, t) : (this.removes.push({
                parentId: r,
                id: i,
                isShadow: wt(e.target) && xt(e.target) ? !0 : void 0
              }), Qp(t, this.removesSubTreeCache))), this.mapRemoves.push(t));
            });
            break;
          }
        }
    }), Z(this, "genAdds", (e, t) => {
      if (!this.processedNodeManager.inOtherBuffer(e, this) && !(this.addedSet.has(e) || this.movedSet.has(e))) {
        if (this.mirror.hasNode(e)) {
          if (bs(e, this.mirror, this.slimDOMOptions))
            return;
          this.movedSet.add(e);
          let i = null;
          t && this.mirror.hasNode(t) && (i = this.mirror.getId(t)), i && i !== -1 && (this.movedMap[Kn(this.mirror.getId(e), i)] = !0);
        } else
          this.addedSet.add(e), this.droppedSet.delete(e);
        oe(e, this.blockClass, this.blockSelector, !1) || (N.childNodes(e).forEach((i) => this.genAdds(i)), qs(e) && N.childNodes(N.shadowRoot(e)).forEach((i) => {
          this.processedNodeManager.add(i, this), this.genAdds(i, e);
        }));
      }
    });
  }
  init(e) {
    [
      "mutationCb",
      "blockClass",
      "blockSelector",
      "maskTextClass",
      "maskTextSelector",
      "inlineStylesheet",
      "maskInputOptions",
      "maskTextFn",
      "maskInputFn",
      "keepIframeSrcFn",
      "recordCanvas",
      "inlineImages",
      "inlineVideos",
      "privacySetting",
      "slimDOMOptions",
      "dataURLOptions",
      "doc",
      "mirror",
      "iframeManager",
      "stylesheetManager",
      "shadowDomManager",
      "canvasManager",
      "processedNodeManager"
    ].forEach((t) => {
      this[t] = e[t];
    });
  }
  freeze() {
    this.frozen = !0, this.canvasManager.freeze();
  }
  unfreeze() {
    this.frozen = !1, this.canvasManager.unfreeze(), this.emit();
  }
  isFrozen() {
    return this.frozen;
  }
  lock() {
    this.locked = !0, this.canvasManager.lock();
  }
  unlock() {
    this.locked = !1, this.canvasManager.unlock(), this.emit();
  }
  reset() {
    this.shadowDomManager.reset(), this.canvasManager.reset();
  }
}
function er(s, e) {
  s.delete(e), N.childNodes(e).forEach((t) => er(s, t));
}
function Qp(s, e) {
  const t = [s];
  for (; t.length; ) {
    const i = t.pop();
    e.has(i) || (e.add(i), N.childNodes(i).forEach((r) => t.push(r)));
  }
}
function Fn(s, e, t) {
  return s.size === 0 ? !1 : jp(s, e);
}
function jp(s, e, t) {
  const i = N.parentNode(e);
  return i ? s.has(i) : !1;
}
function zn(s, e) {
  return s.size === 0 ? !1 : Ao(s, e);
}
function Ao(s, e) {
  const t = N.parentNode(e);
  return t ? s.has(t) ? !0 : Ao(s, t) : !1;
}
let kt;
function Dp(s) {
  kt = s;
}
function Ap() {
  kt = void 0;
}
const U = (s) => kt ? (...t) => {
  try {
    return s(...t);
  } catch (i) {
    if (kt && kt(i) === !0)
      return;
    throw i;
  }
} : s, je = [];
function jt(s) {
  try {
    if ("composedPath" in s) {
      const e = s.composedPath();
      if (e.length)
        return e[0];
    } else if ("path" in s && s.path.length)
      return s.path[0];
  } catch (e) {
  }
  return s && s.target;
}
function _o(s, e) {
  const t = new Bp();
  je.push(t), t.init(s);
  const i = new (Fo())(
    U(t.processMutations.bind(t))
  );
  return i.observe(e, {
    attributes: !0,
    attributeOldValue: !0,
    characterData: !0,
    characterDataOldValue: !0,
    childList: !0,
    subtree: !0
  }), i;
}
function _p({
  mousemoveCb: s,
  sampling: e,
  doc: t,
  mirror: i
}) {
  if (e.mousemove === !1)
    return () => {
    };
  const r = typeof e.mousemove == "number" ? e.mousemove : 50, n = typeof e.mousemoveCallback == "number" ? e.mousemoveCallback : 500;
  let o = [], a;
  const l = Mt(
    U(
      (h) => {
        const p = Date.now() - a;
        s(
          o.map((d) => (d.timeOffset -= p, d)),
          h
        ), o = [], a = null;
      }
    ),
    n
  ), u = U(
    Mt(
      U((h) => {
        const p = jt(h), { clientX: d, clientY: b } = $s(h) ? h.changedTouches[0] : h;
        a || (a = Ui()), o.push({
          x: d,
          y: b,
          id: i.getId(p),
          timeOffset: Ui() - a
        }), l(
          typeof DragEvent != "undefined" && h instanceof DragEvent ? T.Drag : h instanceof MouseEvent ? T.MouseMove : T.TouchMove
        );
      }),
      r,
      {
        trailing: !1
      }
    )
  ), c = [
    he("mousemove", u, t),
    he("touchmove", u, t),
    he("drag", u, t)
  ];
  return U(() => {
    c.forEach((h) => h());
  });
}
function $p({
  mouseInteractionCb: s,
  doc: e,
  mirror: t,
  blockClass: i,
  blockSelector: r,
  sampling: n
}) {
  if (n.mouseInteraction === !1)
    return () => {
    };
  const o = n.mouseInteraction === !0 || n.mouseInteraction === void 0 ? {} : n.mouseInteraction, a = [];
  let l = null;
  const u = (c) => (h) => {
    const p = jt(h);
    if (oe(p, i, r, !0) || // We ignore canvas elements for rage click detection because we cannot infer what inside the canvas is getting interacted with.
    Fp(p))
      return;
    let d = null, b = c;
    if ("pointerType" in h) {
      switch (h.pointerType) {
        case "mouse":
          d = ze.Mouse;
          break;
        case "touch":
          d = ze.Touch;
          break;
        case "pen":
          d = ze.Pen;
          break;
      }
      d === ze.Touch && (de[c] === de.MouseDown ? b = "TouchStart" : de[c] === de.MouseUp && (b = "TouchEnd"));
    } else $s(h) && (d = ze.Touch);
    d !== null ? (l = d, (b.startsWith("Touch") && d === ze.Touch || b.startsWith("Mouse") && d === ze.Mouse) && (d = null)) : de[c] === de.Click && (d = l, l = null);
    const m = $s(h) ? h.changedTouches[0] : h;
    if (!m)
      return;
    const f = t.getId(p), { clientX: G, clientY: S } = m;
    U(s)(x({
      type: de[b],
      id: f,
      x: G,
      y: S
    }, d !== null && { pointerType: d }));
  };
  return Object.keys(de).filter(
    (c) => Number.isNaN(Number(c)) && !c.endsWith("_Departed") && o[c] !== !1
  ).forEach((c) => {
    let h = ct(c);
    const p = u(c);
    if (window.PointerEvent)
      switch (de[c]) {
        case de.MouseDown:
        case de.MouseUp:
          h = h.replace(
            "mouse",
            "pointer"
          );
          break;
        case de.TouchStart:
        case de.TouchEnd:
          return;
      }
    a.push(he(h, p, e));
  }), U(() => {
    a.forEach((c) => c());
  });
}
function $o({
  scrollCb: s,
  doc: e,
  mirror: t,
  blockClass: i,
  blockSelector: r,
  sampling: n
}) {
  const o = U(
    Mt(
      U((a) => {
        const l = jt(a);
        if (!l || oe(l, i, r, !0))
          return;
        const u = t.getId(l);
        if (l === e && e.defaultView) {
          const c = zo(e.defaultView);
          s({
            id: u,
            x: c.left,
            y: c.top
          });
        } else
          s({
            id: u,
            x: l.scrollLeft,
            y: l.scrollTop
          });
      }),
      n.scroll || 100
    )
  );
  return he("scroll", o, e);
}
function qp({ viewportResizeCb: s }, { win: e }) {
  let t = -1, i = -1;
  const r = U(
    Mt(
      U(() => {
        const n = Ho(), o = Mo();
        (t !== n || i !== o) && (s({
          width: Number(o),
          height: Number(n)
        }), t = n, i = o);
      }),
      200
    )
  );
  return he("resize", r, e);
}
const em = ["INPUT", "TEXTAREA", "SELECT"], Hn = /* @__PURE__ */ new WeakMap();
function tm({
  inputCb: s,
  doc: e,
  mirror: t,
  blockClass: i,
  blockSelector: r,
  ignoreClass: n,
  ignoreSelector: o,
  maskInputOptions: a,
  maskInputFn: l,
  sampling: u,
  userTriggeredOnInput: c
}) {
  function h(S) {
    let V = jt(S);
    const I = S.isTrusted, g = V && V.tagName;
    if (V && g === "OPTION" && (V = N.parentElement(V)), !V || !g || em.indexOf(g) < 0 || oe(V, i, r, !0) || V.classList.contains(n) || o && V.matches(o))
      return;
    let R = V.value, C = !1;
    const W = Ri(V) || "", y = V.getAttribute("data-hl-record");
    W === "radio" || W === "checkbox" ? C = V.checked : dl({
      maskInputOptions: a,
      type: W,
      tagName: g,
      overwriteRecord: y
    }) && (R = Wi({
      element: V,
      maskInputOptions: a,
      tagName: g,
      type: W,
      value: R,
      overwriteRecord: y,
      maskInputFn: l
    })), p(
      V,
      c ? { text: R, isChecked: C, userTriggered: I } : { text: R, isChecked: C }
    );
    const X = V.name;
    W === "radio" && X && C && e.querySelectorAll(`input[type="radio"][name="${X}"]`).forEach((Y) => {
      if (Y !== V) {
        const v = Y.value;
        p(
          Y,
          c ? { text: v, isChecked: !C, userTriggered: !1 } : { text: v, isChecked: !C }
        );
      }
    });
  }
  function p(S, V) {
    const I = Hn.get(S);
    if (!I || I.text !== V.text || I.isChecked !== V.isChecked) {
      Hn.set(S, V);
      const g = t.getId(S);
      U(s)(re(x({}, V), {
        id: g
      }));
    }
  }
  const b = (u.input === "last" ? ["change"] : ["input", "change"]).map(
    (S) => he(S, U(h), e)
  ), m = e.defaultView;
  if (!m)
    return () => {
      b.forEach((S) => S());
    };
  const f = m.Object.getOwnPropertyDescriptor(
    m.HTMLInputElement.prototype,
    "value"
  ), G = [
    [m.HTMLInputElement.prototype, "value"],
    [m.HTMLInputElement.prototype, "checked"],
    [m.HTMLSelectElement.prototype, "value"],
    [m.HTMLTextAreaElement.prototype, "value"],
    // Some UI library use selectedIndex to set select value
    [m.HTMLSelectElement.prototype, "selectedIndex"],
    [m.HTMLOptionElement.prototype, "selected"]
  ];
  return f && f.set && b.push(
    ...G.map(
      (S) => _i(
        S[0],
        S[1],
        {
          set() {
            U(h)({
              target: this,
              isTrusted: !1
              // userTriggered to false as this could well be programmatic
            });
          }
        },
        !1,
        m
      )
    )
  ), U(() => {
    b.forEach((S) => S());
  });
}
function Ki(s) {
  const e = [];
  function t(i, r) {
    if (bi("CSSGroupingRule") && i.parentRule instanceof CSSGroupingRule || bi("CSSMediaRule") && i.parentRule instanceof CSSMediaRule || bi("CSSSupportsRule") && i.parentRule instanceof CSSSupportsRule || bi("CSSConditionRule") && i.parentRule instanceof CSSConditionRule) {
      const o = Array.from(
        i.parentRule.cssRules
      ).indexOf(i);
      r.unshift(o);
    } else if (i.parentStyleSheet) {
      const o = Array.from(i.parentStyleSheet.cssRules).indexOf(i);
      r.unshift(o);
    }
    return r;
  }
  return t(s, e);
}
function He(s, e, t) {
  let i, r;
  return s ? (s.ownerNode ? i = e.getId(s.ownerNode) : r = t.getId(s), {
    styleId: r,
    id: i
  }) : {};
}
function im({ styleSheetRuleCb: s, mirror: e, stylesheetManager: t }, { win: i }) {
  if (!i.CSSStyleSheet || !i.CSSStyleSheet.prototype)
    return () => {
    };
  const r = i.CSSStyleSheet.prototype.insertRule;
  i.CSSStyleSheet.prototype.insertRule = new Proxy(r, {
    apply: U(
      (c, h, p) => {
        const [d, b] = p, { id: m, styleId: f } = He(
          h,
          e,
          t.styleMirror
        );
        return (m && m !== -1 || f && f !== -1) && s({
          id: m,
          styleId: f,
          adds: [{ rule: d, index: b }]
        }), c.apply(h, p);
      }
    )
  }), i.CSSStyleSheet.prototype.addRule = function(c, h, p = this.cssRules.length) {
    const d = `${c} { ${h} }`;
    return i.CSSStyleSheet.prototype.insertRule.apply(this, [d, p]);
  };
  const n = i.CSSStyleSheet.prototype.deleteRule;
  i.CSSStyleSheet.prototype.deleteRule = new Proxy(n, {
    apply: U(
      (c, h, p) => {
        const [d] = p, { id: b, styleId: m } = He(
          h,
          e,
          t.styleMirror
        );
        return (b && b !== -1 || m && m !== -1) && s({
          id: b,
          styleId: m,
          removes: [{ index: d }]
        }), c.apply(h, p);
      }
    )
  }), i.CSSStyleSheet.prototype.removeRule = function(c) {
    return i.CSSStyleSheet.prototype.deleteRule.apply(this, [c]);
  };
  let o;
  i.CSSStyleSheet.prototype.replace && (o = i.CSSStyleSheet.prototype.replace, i.CSSStyleSheet.prototype.replace = new Proxy(o, {
    apply: U(
      (c, h, p) => {
        const [d] = p, { id: b, styleId: m } = He(
          h,
          e,
          t.styleMirror
        );
        return (b && b !== -1 || m && m !== -1) && s({
          id: b,
          styleId: m,
          replace: d
        }), c.apply(h, p);
      }
    )
  }));
  let a;
  i.CSSStyleSheet.prototype.replaceSync && (a = i.CSSStyleSheet.prototype.replaceSync, i.CSSStyleSheet.prototype.replaceSync = new Proxy(a, {
    apply: U(
      (c, h, p) => {
        const [d] = p, { id: b, styleId: m } = He(
          h,
          e,
          t.styleMirror
        );
        return (b && b !== -1 || m && m !== -1) && s({
          id: b,
          styleId: m,
          replaceSync: d
        }), c.apply(h, p);
      }
    )
  }));
  const l = {};
  yi("CSSGroupingRule") ? l.CSSGroupingRule = i.CSSGroupingRule : (yi("CSSMediaRule") && (l.CSSMediaRule = i.CSSMediaRule), yi("CSSConditionRule") && (l.CSSConditionRule = i.CSSConditionRule), yi("CSSSupportsRule") && (l.CSSSupportsRule = i.CSSSupportsRule));
  const u = {};
  return Object.entries(l).forEach(([c, h]) => {
    u[c] = {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      insertRule: h.prototype.insertRule,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      deleteRule: h.prototype.deleteRule
    }, h.prototype.insertRule = new Proxy(
      u[c].insertRule,
      {
        apply: U(
          (p, d, b) => {
            const [m, f] = b, { id: G, styleId: S } = He(
              d.parentStyleSheet,
              e,
              t.styleMirror
            );
            return (G && G !== -1 || S && S !== -1) && s({
              id: G,
              styleId: S,
              adds: [
                {
                  rule: m,
                  index: [
                    ...Ki(d),
                    f || 0
                    // defaults to 0
                  ]
                }
              ]
            }), p.apply(d, b);
          }
        )
      }
    ), h.prototype.deleteRule = new Proxy(
      u[c].deleteRule,
      {
        apply: U(
          (p, d, b) => {
            const [m] = b, { id: f, styleId: G } = He(
              d.parentStyleSheet,
              e,
              t.styleMirror
            );
            return (f && f !== -1 || G && G !== -1) && s({
              id: f,
              styleId: G,
              removes: [
                { index: [...Ki(d), m] }
              ]
            }), p.apply(d, b);
          }
        )
      }
    );
  }), U(() => {
    i.CSSStyleSheet.prototype.insertRule = r, i.CSSStyleSheet.prototype.deleteRule = n, o && (i.CSSStyleSheet.prototype.replace = o), a && (i.CSSStyleSheet.prototype.replaceSync = a), Object.entries(l).forEach(([c, h]) => {
      h.prototype.insertRule = u[c].insertRule, h.prototype.deleteRule = u[c].deleteRule;
    });
  });
}
function qo({
  mirror: s,
  stylesheetManager: e
}, t) {
  var i, r, n;
  let o = null;
  t.nodeName === "#document" ? o = s.getId(t) : o = s.getId(N.host(t));
  const a = t.nodeName === "#document" ? (i = t.defaultView) == null ? void 0 : i.Document : (n = (r = t.ownerDocument) == null ? void 0 : r.defaultView) == null ? void 0 : n.ShadowRoot, l = a != null && a.prototype ? Object.getOwnPropertyDescriptor(
    a == null ? void 0 : a.prototype,
    "adoptedStyleSheets"
  ) : void 0;
  return o === null || o === -1 || !a || !l ? () => {
  } : (Object.defineProperty(t, "adoptedStyleSheets", {
    configurable: l.configurable,
    enumerable: l.enumerable,
    get() {
      var u;
      return (u = l.get) == null ? void 0 : u.call(this);
    },
    set(u) {
      var c;
      const h = (c = l.set) == null ? void 0 : c.call(this, u);
      if (o !== null && o !== -1)
        try {
          e.adoptStyleSheets(u, o);
        } catch (p) {
        }
      return h;
    }
  }), U(() => {
    Object.defineProperty(t, "adoptedStyleSheets", {
      configurable: l.configurable,
      enumerable: l.enumerable,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      get: l.get,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      set: l.set
    });
  }));
}
function sm({
  styleDeclarationCb: s,
  mirror: e,
  ignoreCSSAttributes: t,
  stylesheetManager: i
}, { win: r }) {
  const n = r.CSSStyleDeclaration.prototype.setProperty;
  r.CSSStyleDeclaration.prototype.setProperty = new Proxy(n, {
    apply: U(
      (a, l, u) => {
        var c;
        const [h, p, d] = u;
        if (t.has(h))
          return n.apply(l, [h, p, d]);
        const { id: b, styleId: m } = He(
          (c = l.parentRule) == null ? void 0 : c.parentStyleSheet,
          e,
          i.styleMirror
        );
        return (b && b !== -1 || m && m !== -1) && s({
          id: b,
          styleId: m,
          set: {
            property: h,
            value: p,
            priority: d
          },
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          index: Ki(l.parentRule)
        }), a.apply(l, u);
      }
    )
  });
  const o = r.CSSStyleDeclaration.prototype.removeProperty;
  return r.CSSStyleDeclaration.prototype.removeProperty = new Proxy(o, {
    apply: U(
      (a, l, u) => {
        var c;
        const [h] = u;
        if (t.has(h))
          return o.apply(l, [h]);
        const { id: p, styleId: d } = He(
          (c = l.parentRule) == null ? void 0 : c.parentStyleSheet,
          e,
          i.styleMirror
        );
        return (p && p !== -1 || d && d !== -1) && s({
          id: p,
          styleId: d,
          remove: {
            property: h
          },
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          index: Ki(l.parentRule)
        }), a.apply(l, u);
      }
    )
  }), U(() => {
    r.CSSStyleDeclaration.prototype.setProperty = n, r.CSSStyleDeclaration.prototype.removeProperty = o;
  });
}
function rm({
  mediaInteractionCb: s,
  blockClass: e,
  blockSelector: t,
  mirror: i,
  sampling: r,
  doc: n
}) {
  const o = U(
    (l) => Mt(
      U((u) => {
        const c = jt(u);
        if (!c || oe(c, e, t, !0))
          return;
        const { currentTime: h, volume: p, muted: d, playbackRate: b, loop: m } = c;
        s({
          type: l,
          id: i.getId(c),
          currentTime: h,
          volume: p,
          muted: d,
          playbackRate: b,
          loop: m
        });
      }),
      r.media || 500
    )
  ), a = [
    he("play", o(nt.Play), n),
    he("pause", o(nt.Pause), n),
    he("seeked", o(nt.Seeked), n),
    he("volumechange", o(nt.VolumeChange), n),
    he("ratechange", o(nt.RateChange), n)
  ];
  return U(() => {
    a.forEach((l) => l());
  });
}
function nm({ fontCb: s, doc: e }) {
  const t = e.defaultView;
  if (!t)
    return () => {
    };
  const i = [], r = /* @__PURE__ */ new WeakMap(), n = t.FontFace;
  t.FontFace = function(l, u, c) {
    const h = new n(l, u, c);
    return r.set(h, {
      family: l,
      buffer: typeof u != "string",
      descriptors: c,
      fontSource: typeof u == "string" ? u : JSON.stringify(Array.from(new Uint8Array(u)))
    }), h;
  };
  const o = qe(
    e.fonts,
    "add",
    function(a) {
      return function(l) {
        return setTimeout(
          U(() => {
            const u = r.get(l);
            u && (s(u), r.delete(l));
          }),
          0
        ), a.apply(this, [l]);
      };
    }
  );
  return i.push(() => {
    t.FontFace = n;
  }), i.push(o), U(() => {
    i.forEach((a) => a());
  });
}
function lm(s) {
  const { doc: e, mirror: t, blockClass: i, blockSelector: r, selectionCb: n } = s;
  let o = !0;
  const a = U(() => {
    const l = e.getSelection();
    if (!l || o && (l != null && l.isCollapsed)) return;
    o = l.isCollapsed || !1;
    const u = [], c = l.rangeCount || 0;
    for (let h = 0; h < c; h++) {
      const p = l.getRangeAt(h), { startContainer: d, startOffset: b, endContainer: m, endOffset: f } = p;
      oe(d, i, r, !0) || oe(m, i, r, !0) || u.push({
        start: t.getId(d),
        startOffset: b,
        end: t.getId(m),
        endOffset: f
      });
    }
    n({ ranges: u });
  });
  return a(), he("selectionchange", a);
}
function om({
  doc: s,
  customElementCb: e
}) {
  const t = s.defaultView;
  return !t || !t.customElements ? () => {
  } : qe(
    t.customElements,
    "define",
    function(r) {
      return function(n, o, a) {
        try {
          e({
            define: {
              name: n
            }
          });
        } catch (l) {
          console.warn(`Custom element callback failed for ${n}`);
        }
        return r.apply(this, [n, o, a]);
      };
    }
  );
}
function am(s, e) {
  const {
    mutationCb: t,
    mousemoveCb: i,
    mouseInteractionCb: r,
    scrollCb: n,
    viewportResizeCb: o,
    inputCb: a,
    mediaInteractionCb: l,
    styleSheetRuleCb: u,
    styleDeclarationCb: c,
    canvasMutationCb: h,
    fontCb: p,
    selectionCb: d,
    customElementCb: b
  } = s;
  s.mutationCb = (...m) => {
    e.mutation && e.mutation(...m), t(...m);
  }, s.mousemoveCb = (...m) => {
    e.mousemove && e.mousemove(...m), i(...m);
  }, s.mouseInteractionCb = (...m) => {
    e.mouseInteraction && e.mouseInteraction(...m), r(...m);
  }, s.scrollCb = (...m) => {
    e.scroll && e.scroll(...m), n(...m);
  }, s.viewportResizeCb = (...m) => {
    e.viewportResize && e.viewportResize(...m), o(...m);
  }, s.inputCb = (...m) => {
    e.input && e.input(...m), a(...m);
  }, s.mediaInteractionCb = (...m) => {
    e.mediaInteaction && e.mediaInteaction(...m), l(...m);
  }, s.styleSheetRuleCb = (...m) => {
    e.styleSheetRule && e.styleSheetRule(...m), u(...m);
  }, s.styleDeclarationCb = (...m) => {
    e.styleDeclaration && e.styleDeclaration(...m), c(...m);
  }, s.canvasMutationCb = (...m) => {
    e.canvasMutation && e.canvasMutation(...m), h(...m);
  }, s.fontCb = (...m) => {
    e.font && e.font(...m), p(...m);
  }, s.selectionCb = (...m) => {
    e.selection && e.selection(...m), d(...m);
  }, s.customElementCb = (...m) => {
    e.customElement && e.customElement(...m), b(...m);
  };
}
function cm(s, e = {}) {
  const t = s.doc.defaultView;
  if (!t)
    return () => {
    };
  am(s, e);
  let i;
  s.recordDOM && (i = _o(s, s.doc));
  const r = _p(s), n = $p(s), o = $o(s), a = qp(s, {
    win: t
  }), l = tm(s), u = rm(s);
  let c = () => {
  }, h = () => {
  }, p = () => {
  }, d = () => {
  };
  s.recordDOM && (c = im(s, { win: t }), h = qo(s, s.doc), p = sm(s, {
    win: t
  }), s.collectFonts && (d = nm(s)));
  const b = lm(s), m = om(s), f = [];
  for (const G of s.plugins)
    f.push(
      G.observer(G.callback, t, G.options)
    );
  return U(() => {
    je.forEach((G) => G.reset()), i == null || i.disconnect(), r(), n(), o(), a(), l(), u(), c(), h(), p(), d(), b(), m(), f.forEach((G) => G());
  });
}
function bi(s) {
  return typeof window[s] != "undefined";
}
function yi(s) {
  return !!(typeof window[s] != "undefined" && // Note: Generally, this check _shouldn't_ be necessary
  // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here
  window[s].prototype && "insertRule" in window[s].prototype && "deleteRule" in window[s].prototype);
}
class Mn {
  constructor(e) {
    Z(this, "iframeIdToRemoteIdMap", /* @__PURE__ */ new WeakMap()), Z(this, "iframeRemoteIdToIdMap", /* @__PURE__ */ new WeakMap()), this.generateIdFn = e;
  }
  getId(e, t, i, r) {
    const n = i || this.getIdToRemoteIdMap(e), o = r || this.getRemoteIdToIdMap(e);
    let a = n.get(t);
    return a || (a = this.generateIdFn(), n.set(t, a), o.set(a, t)), a;
  }
  getIds(e, t) {
    const i = this.getIdToRemoteIdMap(e), r = this.getRemoteIdToIdMap(e);
    return t.map(
      (n) => this.getId(e, n, i, r)
    );
  }
  getRemoteId(e, t, i) {
    const r = i || this.getRemoteIdToIdMap(e);
    if (typeof t != "number") return t;
    const n = r.get(t);
    return n || -1;
  }
  getRemoteIds(e, t) {
    const i = this.getRemoteIdToIdMap(e);
    return t.map((r) => this.getRemoteId(e, r, i));
  }
  reset(e) {
    if (!e) {
      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap(), this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
      return;
    }
    this.iframeIdToRemoteIdMap.delete(e), this.iframeRemoteIdToIdMap.delete(e);
  }
  getIdToRemoteIdMap(e) {
    let t = this.iframeIdToRemoteIdMap.get(e);
    return t || (t = /* @__PURE__ */ new Map(), this.iframeIdToRemoteIdMap.set(e, t)), t;
  }
  getRemoteIdToIdMap(e) {
    let t = this.iframeRemoteIdToIdMap.get(e);
    return t || (t = /* @__PURE__ */ new Map(), this.iframeRemoteIdToIdMap.set(e, t)), t;
  }
}
class um {
  constructor(e) {
    Z(this, "iframes", /* @__PURE__ */ new WeakMap()), Z(this, "crossOriginIframeMap", /* @__PURE__ */ new WeakMap()), Z(this, "crossOriginIframeMirror", new Mn(pl)), Z(this, "crossOriginIframeStyleMirror"), Z(this, "crossOriginIframeRootIdMap", /* @__PURE__ */ new WeakMap()), Z(this, "mirror"), Z(this, "mutationCb"), Z(this, "wrappedEmit"), Z(this, "loadListener"), Z(this, "stylesheetManager"), Z(this, "recordCrossOriginIframes"), this.mutationCb = e.mutationCb, this.wrappedEmit = e.wrappedEmit, this.stylesheetManager = e.stylesheetManager, this.recordCrossOriginIframes = e.recordCrossOriginIframes, this.crossOriginIframeStyleMirror = new Mn(
      this.stylesheetManager.styleMirror.generateId.bind(
        this.stylesheetManager.styleMirror
      )
    ), this.mirror = e.mirror, this.recordCrossOriginIframes && window.addEventListener("message", this.handleMessage.bind(this));
  }
  addIframe(e) {
    this.iframes.set(e, !0), e.contentWindow && this.crossOriginIframeMap.set(e.contentWindow, e);
  }
  addLoadListener(e) {
    this.loadListener = e;
  }
  attachIframe(e, t) {
    var i, r;
    this.mutationCb({
      adds: [
        {
          parentId: this.mirror.getId(e),
          nextId: null,
          node: t
        }
      ],
      removes: [],
      texts: [],
      attributes: [],
      isAttachIframe: !0
    }), this.recordCrossOriginIframes && ((i = e.contentWindow) == null || i.addEventListener(
      "message",
      this.handleMessage.bind(this)
    )), (r = this.loadListener) == null || r.call(this, e), e.contentDocument && e.contentDocument.adoptedStyleSheets && e.contentDocument.adoptedStyleSheets.length > 0 && this.stylesheetManager.adoptStyleSheets(
      e.contentDocument.adoptedStyleSheets,
      this.mirror.getId(e.contentDocument)
    );
  }
  handleMessage(e) {
    const t = e;
    if (t.data.type !== "rrweb" || // To filter out the rrweb messages which are forwarded by some sites.
    t.origin !== t.data.origin)
      return;
    const i = e.source;
    if (!i) return;
    const r = this.crossOriginIframeMap.get(i);
    if (!r) return;
    const n = this.transformCrossOriginEvent(
      r,
      t.data.event
    );
    n && this.wrappedEmit(
      n,
      t.data.isCheckout
    );
  }
  transformCrossOriginEvent(e, t) {
    var i;
    switch (t.type) {
      case K.FullSnapshot: {
        this.crossOriginIframeMirror.reset(e), this.crossOriginIframeStyleMirror.reset(e), this.replaceIdOnNode(t.data.node, e);
        const r = t.data.node.id;
        return this.crossOriginIframeRootIdMap.set(e, r), this.patchRootIdOnNode(t.data.node, r), {
          timestamp: t.timestamp,
          type: K.IncrementalSnapshot,
          data: {
            source: T.Mutation,
            adds: [
              {
                parentId: this.mirror.getId(e),
                nextId: null,
                node: t.data.node
              }
            ],
            removes: [],
            texts: [],
            attributes: [],
            isAttachIframe: !0
          }
        };
      }
      case K.Meta:
      case K.Load:
      case K.DomContentLoaded:
        return !1;
      case K.Plugin:
        return t;
      case K.Custom:
        return this.replaceIds(
          t.data.payload,
          e,
          ["id", "parentId", "previousId", "nextId"]
        ), t;
      case K.IncrementalSnapshot:
        switch (t.data.source) {
          case T.Mutation:
            return t.data.adds.forEach((r) => {
              this.replaceIds(r, e, [
                "parentId",
                "nextId",
                "previousId"
              ]), this.replaceIdOnNode(r.node, e);
              const n = this.crossOriginIframeRootIdMap.get(e);
              n && this.patchRootIdOnNode(r.node, n);
            }), t.data.removes.forEach((r) => {
              this.replaceIds(r, e, ["parentId", "id"]);
            }), t.data.attributes.forEach((r) => {
              this.replaceIds(r, e, ["id"]);
            }), t.data.texts.forEach((r) => {
              this.replaceIds(r, e, ["id"]);
            }), t;
          case T.Drag:
          case T.TouchMove:
          case T.MouseMove:
            return t.data.positions.forEach((r) => {
              this.replaceIds(r, e, ["id"]);
            }), t;
          case T.ViewportResize:
            return !1;
          case T.MediaInteraction:
          case T.MouseInteraction:
          case T.Scroll:
          case T.CanvasMutation:
          case T.Input:
            return this.replaceIds(t.data, e, ["id"]), t;
          case T.StyleSheetRule:
          case T.StyleDeclaration:
            return this.replaceIds(t.data, e, ["id"]), this.replaceStyleIds(t.data, e, ["styleId"]), t;
          case T.Font:
            return t;
          case T.Selection:
            return t.data.ranges.forEach((r) => {
              this.replaceIds(r, e, ["start", "end"]);
            }), t;
          case T.AdoptedStyleSheet:
            return this.replaceIds(t.data, e, ["id"]), this.replaceStyleIds(t.data, e, ["styleIds"]), (i = t.data.styles) == null || i.forEach((r) => {
              this.replaceStyleIds(r, e, ["styleId"]);
            }), t;
        }
    }
    return !1;
  }
  replace(e, t, i, r) {
    for (const n of r)
      !Array.isArray(t[n]) && typeof t[n] != "number" || (Array.isArray(t[n]) ? t[n] = e.getIds(
        i,
        t[n]
      ) : t[n] = e.getId(i, t[n]));
    return t;
  }
  replaceIds(e, t, i) {
    return this.replace(this.crossOriginIframeMirror, e, t, i);
  }
  replaceStyleIds(e, t, i) {
    return this.replace(this.crossOriginIframeStyleMirror, e, t, i);
  }
  replaceIdOnNode(e, t) {
    this.replaceIds(e, t, ["id", "rootId"]), "childNodes" in e && e.childNodes.forEach((i) => {
      this.replaceIdOnNode(i, t);
    });
  }
  patchRootIdOnNode(e, t) {
    e.type !== Do.Document && !e.rootId && (e.rootId = t), "childNodes" in e && e.childNodes.forEach((i) => {
      this.patchRootIdOnNode(i, t);
    });
  }
}
class hm {
  constructor(e) {
    Z(this, "shadowDoms", /* @__PURE__ */ new WeakSet()), Z(this, "mutationCb"), Z(this, "scrollCb"), Z(this, "bypassOptions"), Z(this, "mirror"), Z(this, "restoreHandlers", []), this.mutationCb = e.mutationCb, this.scrollCb = e.scrollCb, this.bypassOptions = e.bypassOptions, this.mirror = e.mirror, this.init();
  }
  init() {
    this.reset(), this.patchAttachShadow(Element, document);
  }
  addShadowRoot(e, t) {
    if (!xt(e) || this.shadowDoms.has(e)) return;
    this.shadowDoms.add(e);
    const i = _o(
      re(x({}, this.bypassOptions), {
        doc: t,
        mutationCb: this.mutationCb,
        mirror: this.mirror,
        shadowDomManager: this
      }),
      e
    );
    this.restoreHandlers.push(() => i.disconnect()), this.restoreHandlers.push(
      $o(re(x({}, this.bypassOptions), {
        scrollCb: this.scrollCb,
        // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813
        // scroll is not allowed to pass the boundary, so we need to listen the shadow document
        doc: e,
        mirror: this.mirror
      }))
    ), setTimeout(() => {
      e.adoptedStyleSheets && e.adoptedStyleSheets.length > 0 && this.bypassOptions.stylesheetManager.adoptStyleSheets(
        e.adoptedStyleSheets,
        this.mirror.getId(N.host(e))
      ), this.restoreHandlers.push(
        qo(
          {
            mirror: this.mirror,
            stylesheetManager: this.bypassOptions.stylesheetManager
          },
          e
        )
      );
    }, 0);
  }
  /**
   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.
   */
  observeAttachShadow(e) {
    !e.contentWindow || !e.contentDocument || this.patchAttachShadow(
      e.contentWindow.Element,
      e.contentDocument
    );
  }
  /**
   * Patch 'attachShadow' to observe newly added shadow doms.
   */
  patchAttachShadow(e, t) {
    const i = this;
    this.restoreHandlers.push(
      qe(
        e.prototype,
        "attachShadow",
        function(r) {
          return function(n) {
            const o = r.call(this, n), a = N.shadowRoot(this);
            return a && jo(this) && i.addShadowRoot(a, t), o;
          };
        }
      )
    );
  }
  reset() {
    this.restoreHandlers.forEach((e) => {
      try {
        e();
      } catch (t) {
      }
    }), this.restoreHandlers = [], this.shadowDoms = /* @__PURE__ */ new WeakSet();
  }
}
var at = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", dm = typeof Uint8Array == "undefined" ? [] : new Uint8Array(256);
for (var gi = 0; gi < at.length; gi++)
  dm[at.charCodeAt(gi)] = gi;
var pm = function(s) {
  var e = new Uint8Array(s), t, i = e.length, r = "";
  for (t = 0; t < i; t += 3)
    r += at[e[t] >> 2], r += at[(e[t] & 3) << 4 | e[t + 1] >> 4], r += at[(e[t + 1] & 15) << 2 | e[t + 2] >> 6], r += at[e[t + 2] & 63];
  return i % 3 === 2 ? r = r.substring(0, r.length - 1) + "=" : i % 3 === 1 && (r = r.substring(0, r.length - 2) + "=="), r;
};
const On = /* @__PURE__ */ new Map();
function mm(s, e) {
  let t = On.get(s);
  return t || (t = /* @__PURE__ */ new Map(), On.set(s, t)), t.has(e) || t.set(e, []), t.get(e);
}
const ea = (s, e, t) => {
  if (!s || !(ia(s, e) || typeof s == "object"))
    return;
  const i = s.constructor.name, r = mm(t, i);
  let n = r.indexOf(s);
  return n === -1 && (n = r.length, r.push(s)), n;
};
function Ii(s, e, t) {
  if (s instanceof Array)
    return s.map((i) => Ii(i, e, t));
  if (s === null)
    return s;
  if (s instanceof Float32Array || s instanceof Float64Array || s instanceof Int32Array || s instanceof Uint32Array || s instanceof Uint8Array || s instanceof Uint16Array || s instanceof Int16Array || s instanceof Int8Array || s instanceof Uint8ClampedArray)
    return {
      rr_type: s.constructor.name,
      args: [Object.values(s)]
    };
  if (
    // SharedArrayBuffer disabled on most browsers due to spectre.
    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer
    // value instanceof SharedArrayBuffer ||
    s instanceof ArrayBuffer
  ) {
    const i = s.constructor.name, r = pm(s);
    return {
      rr_type: i,
      base64: r
    };
  } else {
    if (s instanceof DataView)
      return {
        rr_type: s.constructor.name,
        args: [
          Ii(s.buffer, e, t),
          s.byteOffset,
          s.byteLength
        ]
      };
    if (s instanceof HTMLImageElement) {
      const i = s.constructor.name, { src: r } = s;
      return {
        rr_type: i,
        src: r
      };
    } else if (s instanceof HTMLCanvasElement) {
      const i = "HTMLImageElement", r = s.toDataURL();
      return {
        rr_type: i,
        src: r
      };
    } else {
      if (s instanceof ImageData)
        return {
          rr_type: s.constructor.name,
          args: [Ii(s.data, e, t), s.width, s.height]
        };
      if (ia(s, e) || typeof s == "object") {
        const i = s.constructor.name, r = ea(s, e, t);
        return {
          rr_type: i,
          index: r
        };
      }
    }
  }
  return s;
}
const ta = (s, e, t) => s.map((i) => Ii(i, e, t)), ia = (s, e) => !![
  "WebGLActiveInfo",
  "WebGLBuffer",
  "WebGLFramebuffer",
  "WebGLProgram",
  "WebGLRenderbuffer",
  "WebGLShader",
  "WebGLShaderPrecisionFormat",
  "WebGLTexture",
  "WebGLUniformLocation",
  "WebGLVertexArrayObject",
  // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.
  "WebGLVertexArrayObjectOES"
].filter(
  (r) => typeof e[r] == "function"
).find(
  (r) => s instanceof e[r]
);
function fm(s, e, t, i) {
  const r = [], n = Object.getOwnPropertyNames(
    e.CanvasRenderingContext2D.prototype
  );
  for (const o of n)
    try {
      if (typeof e.CanvasRenderingContext2D.prototype[o] != "function")
        continue;
      const a = qe(
        e.CanvasRenderingContext2D.prototype,
        o,
        function(l) {
          return function(...u) {
            return oe(this.canvas, t, i, !0) || setTimeout(() => {
              const c = ta(u, e, this);
              s(this.canvas, {
                type: bt["2D"],
                property: o,
                args: c
              });
            }, 0), l.apply(this, u);
          };
        }
      );
      r.push(a);
    } catch (a) {
      const l = _i(
        e.CanvasRenderingContext2D.prototype,
        o,
        {
          set(u) {
            s(this.canvas, {
              type: bt["2D"],
              property: o,
              args: [u],
              setter: !0
            });
          }
        }
      );
      r.push(l);
    }
  return () => {
    r.forEach((o) => o());
  };
}
function bm(s) {
  return s === "experimental-webgl" ? "webgl" : s;
}
function Pn(s, e, t, i) {
  const r = [];
  try {
    const n = qe(
      s.HTMLCanvasElement.prototype,
      "getContext",
      function(o) {
        return function(a, ...l) {
          if (!oe(this, e, t, !0)) {
            const u = bm(a);
            if ("__context" in this || (this.__context = u), i && ["webgl", "webgl2"].includes(u))
              if (l[0] && typeof l[0] == "object") {
                const c = l[0];
                c.preserveDrawingBuffer || (c.preserveDrawingBuffer = !0);
              } else
                l.splice(0, 1, {
                  preserveDrawingBuffer: !0
                });
          }
          return o.apply(this, [a, ...l]);
        };
      }
    );
    r.push(n);
  } catch (n) {
    console.error("failed to patch HTMLCanvasElement.prototype.getContext");
  }
  return () => {
    r.forEach((n) => n());
  };
}
function En(s, e, t, i, r, n) {
  const o = [], a = Object.getOwnPropertyNames(s);
  for (const l of a)
    if (
      //prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky
      ![
        "isContextLost",
        "canvas",
        "drawingBufferWidth",
        "drawingBufferHeight"
      ].includes(l)
    )
      try {
        if (typeof s[l] != "function")
          continue;
        const u = qe(
          s,
          l,
          function(c) {
            return function(...h) {
              const p = c.apply(this, h);
              if (ea(p, n, this), "tagName" in this.canvas && !oe(
                this.canvas,
                i,
                r,
                !0
              )) {
                const d = ta(h, n, this), b = {
                  type: e,
                  property: l,
                  args: d
                };
                t(this.canvas, b);
              }
              return p;
            };
          }
        );
        o.push(u);
      } catch (u) {
        const c = _i(s, l, {
          set(h) {
            t(this.canvas, {
              type: e,
              property: l,
              args: [h],
              setter: !0
            });
          }
        });
        o.push(c);
      }
  return o;
}
function ym(s, e, t, i) {
  const r = [];
  return r.push(
    ...En(
      e.WebGLRenderingContext.prototype,
      bt.WebGL,
      s,
      t,
      i,
      e
    )
  ), typeof e.WebGL2RenderingContext != "undefined" && r.push(
    ...En(
      e.WebGL2RenderingContext.prototype,
      bt.WebGL2,
      s,
      t,
      i,
      e
    )
  ), () => {
    r.forEach((n) => n());
  };
}
const sa = "KGZ1bmN0aW9uKCkgewogICJ1c2Ugc3RyaWN0IjsKICB2YXIgY2hhcnMgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7CiAgdmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAidW5kZWZpbmVkIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTsKICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7CiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpOwogIH0KICB2YXIgZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHsKICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaTIsIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gIiI7CiAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpIHsKICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyXSA+PiAyXTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMl0gJiAzKSA8PCA0IHwgYnl0ZXNbaTIgKyAxXSA+PiA0XTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdOwogICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTIgKyAyXSAmIDYzXTsKICAgIH0KICAgIGlmIChsZW4gJSAzID09PSAyKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgIj0iOwogICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgIj09IjsKICAgIH0KICAgIHJldHVybiBiYXNlNjQ7CiAgfTsKICBjb25zdCBsYXN0QmxvYk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7CiAgY29uc3QgdHJhbnNwYXJlbnRCbG9iTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpIHsKICAgIGNvbnN0IGlkID0gYCR7d2lkdGh9LSR7aGVpZ2h0fWA7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBpZiAodHJhbnNwYXJlbnRCbG9iTWFwLmhhcyhpZCkpIHJldHVybiB0cmFuc3BhcmVudEJsb2JNYXAuZ2V0KGlkKTsKICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgb2Zmc2NyZWVuLmdldENvbnRleHQoIjJkIik7CiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7CiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpOwogICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpOwogICAgICB0cmFuc3BhcmVudEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICByZXR1cm4gYmFzZTY0OwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuICIiOwogICAgfQogIH0KICBjb25zdCB3b3JrZXIgPSBzZWxmOwogIGxldCBsb2dEZWJ1ZyA9IGZhbHNlOwogIGNvbnN0IGRlYnVnID0gKC4uLmFyZ3MpID0+IHsKICAgIGlmIChsb2dEZWJ1ZykgewogICAgICBjb25zb2xlLmRlYnVnKC4uLmFyZ3MpOwogICAgfQogIH07CiAgd29ya2VyLm9ubWVzc2FnZSA9IGFzeW5jIGZ1bmN0aW9uKGUpIHsKICAgIGxvZ0RlYnVnID0gISFlLmRhdGEubG9nRGVidWc7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBjb25zdCB7IGlkLCBiaXRtYXAsIHdpZHRoLCBoZWlnaHQsIGR4LCBkeSwgZHcsIGRoLCBkYXRhVVJMT3B0aW9ucyB9ID0gZS5kYXRhOwogICAgICBjb25zdCB0cmFuc3BhcmVudEJhc2U2NCA9IGdldFRyYW5zcGFyZW50QmxvYkZvcigKICAgICAgICB3aWR0aCwKICAgICAgICBoZWlnaHQsCiAgICAgICAgZGF0YVVSTE9wdGlvbnMKICAgICAgKTsKICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoIjJkIik7CiAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTsKICAgICAgYml0bWFwLmNsb3NlKCk7CiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7CiAgICAgIGNvbnN0IHR5cGUgPSBibG9iLnR5cGU7CiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpOwogICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpOwogICAgICBpZiAoIWxhc3RCbG9iTWFwLmhhcyhpZCkgJiYgYXdhaXQgdHJhbnNwYXJlbnRCYXNlNjQgPT09IGJhc2U2NCkgewogICAgICAgIGRlYnVnKCJbaGlnaGxpZ2h0LXdvcmtlcl0gY2FudmFzIGJpdG1hcCBpcyB0cmFuc3BhcmVudCIsIHsKICAgICAgICAgIGlkLAogICAgICAgICAgYmFzZTY0CiAgICAgICAgfSk7CiAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICAgIHJldHVybiB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZCwgc3RhdHVzOiAidHJhbnNwYXJlbnQiIH0pOwogICAgICB9CiAgICAgIGlmIChsYXN0QmxvYk1hcC5nZXQoaWQpID09PSBiYXNlNjQpIHsKICAgICAgICBkZWJ1ZygiW2hpZ2hsaWdodC13b3JrZXJdIGNhbnZhcyBiaXRtYXAgaXMgdW5jaGFuZ2VkIiwgewogICAgICAgICAgaWQsCiAgICAgICAgICBiYXNlNjQKICAgICAgICB9KTsKICAgICAgfQogICAgICBjb25zdCBtc2cgPSB7CiAgICAgICAgaWQsCiAgICAgICAgdHlwZSwKICAgICAgICBiYXNlNjQsCiAgICAgICAgd2lkdGgsCiAgICAgICAgaGVpZ2h0LAogICAgICAgIGR4LAogICAgICAgIGR5LAogICAgICAgIGR3LAogICAgICAgIGRoCiAgICAgIH07CiAgICAgIGRlYnVnKCJbaGlnaGxpZ2h0LXdvcmtlcl0gY2FudmFzIGJpdG1hcCBwcm9jZXNzZWQiLCBtc2cpOwogICAgICB3b3JrZXIucG9zdE1lc3NhZ2UobXNnKTsKICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgfSBlbHNlIHsKICAgICAgZGVidWcoIltoaWdobGlnaHQtd29ya2VyXSBubyBvZmZzY3JlZW5jYW52YXMgc3VwcG9ydCIsIHsKICAgICAgICBpZDogZS5kYXRhLmlkCiAgICAgIH0pOwogICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCwgc3RhdHVzOiAidW5zdXBwb3J0ZWQiIH0pOwogICAgfQogIH07Cn0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWJpdG1hcC1kYXRhLXVybC13b3JrZXItRHd0SzhBMHouanMubWFwCg==", gm = (s) => Uint8Array.from(atob(s), (e) => e.charCodeAt(0)), Bn = typeof self != "undefined" && self.Blob && new Blob([gm(sa)], { type: "text/javascript;charset=utf-8" });
function Zm(s) {
  let e;
  try {
    if (e = Bn && (self.URL || self.webkitURL).createObjectURL(Bn), !e) throw "";
    const t = new Worker(e, {
      name: s == null ? void 0 : s.name
    });
    return t.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(e);
    }), t;
  } catch (t) {
    return new Worker(
      "data:text/javascript;base64," + sa,
      {
        name: s == null ? void 0 : s.name
      }
    );
  } finally {
    e && (self.URL || self.webkitURL).revokeObjectURL(e);
  }
}
class Gm {
  constructor(e) {
    Z(this, "pendingCanvasMutations", /* @__PURE__ */ new Map()), Z(this, "rafStamps", { latestId: 0, invokeId: null }), Z(this, "mirror"), Z(this, "logger"), Z(this, "worker"), Z(this, "snapshotInProgressMap", /* @__PURE__ */ new Map()), Z(this, "lastSnapshotTime", /* @__PURE__ */ new Map()), Z(this, "options"), Z(this, "mutationCb"), Z(this, "resetObservers"), Z(this, "frozen", !1), Z(this, "locked", !1), Z(this, "processMutation", (h, p) => {
      (this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId || !this.rafStamps.invokeId) && (this.rafStamps.invokeId = this.rafStamps.latestId), this.pendingCanvasMutations.has(h) || this.pendingCanvasMutations.set(h, []), this.pendingCanvasMutations.get(h).push(p);
    });
    const {
      sampling: t,
      win: i,
      blockClass: r,
      blockSelector: n,
      recordCanvas: o,
      recordLocalVideos: a,
      recordRemoteVideos: l,
      initialSnapshotDelay: u,
      dataURLOptions: c
    } = e;
    this.mutationCb = e.mutationCb, this.mirror = e.mirror, this.logger = e.logger, this.worker = new Zm(), this.worker.onmessage = (h) => {
      const { id: p } = h.data;
      if (this.snapshotInProgressMap.set(p, !1), !("base64" in h.data)) {
        this.debug(null, "canvas worker received empty message", {
          id: p,
          data: h.data,
          status: h.data.status
        });
        return;
      }
      const { base64: d, type: b, dx: m, dy: f, dw: G, dh: S } = h.data, V = {
        id: p,
        type: bt["2D"],
        commands: [
          {
            property: "clearRect",
            // wipe canvas
            args: [m, f, G, S]
          },
          {
            property: "drawImage",
            // draws (semi-transparent) image
            args: [
              {
                rr_type: "ImageBitmap",
                args: [
                  {
                    rr_type: "Blob",
                    data: [{ rr_type: "ArrayBuffer", base64: d }],
                    type: b
                  }
                ]
              },
              m,
              f,
              G,
              S
            ]
          }
        ]
      };
      this.debug(null, "canvas worker recording mutation", V), this.mutationCb(V);
    }, this.options = e, o && t === "all" ? (this.debug(null, "initializing canvas mutation observer", { sampling: t }), this.initCanvasMutationObserver(i, r, n)) : o && typeof t == "number" && (this.debug(null, "initializing canvas fps observer", { sampling: t }), this.initCanvasFPSObserver(
      a,
      l,
      t,
      i,
      r,
      n,
      {
        initialSnapshotDelay: u,
        dataURLOptions: c
      },
      e.resizeFactor,
      e.maxSnapshotDimension
    ));
  }
  reset() {
    this.pendingCanvasMutations.clear(), this.resetObservers && this.resetObservers();
  }
  freeze() {
    this.frozen = !0;
  }
  unfreeze() {
    this.frozen = !1;
  }
  lock() {
    this.locked = !0;
  }
  unlock() {
    this.locked = !1;
  }
  debug(e, ...t) {
    if (!this.logger) return;
    const i = this.mirror.getId(e);
    let r = "[highlight-canvas-manager]";
    e && (r = `[highlight-canvas] [id:${i}]`, e.tagName.toLowerCase() === "canvas" && (r += ` [ctx:${e.__context}]`)), this.logger.debug(r, e, ...t);
  }
  snapshot(e) {
    return ne(this, null, function* () {
      var t;
      const i = this.mirror.getId(e);
      if (this.snapshotInProgressMap.get(i)) {
        this.debug(e, "snapshotting already in progress for", i);
        return;
      }
      const r = 1e3 / (typeof this.options.samplingManual == "number" ? this.options.samplingManual : 1), n = this.lastSnapshotTime.get(i);
      if (!(n && (/* @__PURE__ */ new Date()).getTime() - n < r)) {
        if (this.debug(e, "starting snapshotting"), e.width === 0 || e.height === 0) {
          this.debug(e, "not yet ready", {
            width: e.width,
            height: e.height
          });
          return;
        }
        this.lastSnapshotTime.set(i, (/* @__PURE__ */ new Date()).getTime()), this.snapshotInProgressMap.set(i, !0);
        try {
          if (this.options.clearWebGLBuffer !== !1 && ["webgl", "webgl2"].includes(e.__context)) {
            const c = e.getContext(e.__context);
            ((t = c == null ? void 0 : c.getContextAttributes()) == null ? void 0 : t.preserveDrawingBuffer) === !1 && (c.clear(c.COLOR_BUFFER_BIT), this.debug(e, "cleared webgl canvas to load it into memory", {
              attributes: c == null ? void 0 : c.getContextAttributes()
            }));
          }
          if (e.width === 0 || e.height === 0) {
            this.debug(e, "not yet ready", {
              width: e.width,
              height: e.height
            });
            return;
          }
          let o = this.options.resizeFactor || 1;
          if (this.options.maxSnapshotDimension) {
            const c = Math.max(e.width, e.height);
            o = Math.min(o, this.options.maxSnapshotDimension / c);
          }
          const a = e.width * o, l = e.height * o, u = yield createImageBitmap(e, {
            resizeWidth: a,
            resizeHeight: l
          });
          this.debug(e, "created image bitmap", {
            width: u.width,
            height: u.height
          }), this.worker.postMessage(
            {
              id: i,
              bitmap: u,
              width: a,
              height: l,
              dx: 0,
              dy: 0,
              dw: e.width,
              dh: e.height,
              dataURLOptions: this.options.dataURLOptions,
              logDebug: !!this.logger
            },
            [u]
          ), this.debug(e, "sent message");
        } catch (o) {
          this.debug(e, "failed to snapshot", o);
        } finally {
          this.snapshotInProgressMap.set(i, !1);
        }
      }
    });
  }
  initCanvasFPSObserver(e, t, i, r, n, o, a, l, u) {
    const c = Pn(
      r,
      n,
      o,
      !0
    ), h = 1e3 / i;
    let p = 0, d;
    const b = /* @__PURE__ */ new Map(), m = (V, I) => {
      const g = [];
      V.querySelectorAll(I).forEach((W) => g.push(W));
      const R = document.createNodeIterator(V, Node.ELEMENT_NODE);
      let C;
      for (; C = R.nextNode(); )
        C != null && C.shadowRoot && g.push(...m(C.shadowRoot, I));
      return g;
    }, f = (V) => {
      const I = [];
      return m(r.document, "canvas").forEach((g) => {
        if (!oe(g, n, o, !0)) {
          this.debug(g, "discovered canvas"), I.push(g);
          const R = this.mirror.getId(g);
          b.has(R) || b.set(R, V);
        }
      }), I;
    }, G = (V) => {
      const I = [];
      return (e || t) && m(r.document, "video").forEach((g) => {
        if (!(!t && g.src !== "" && g.src.indexOf("blob:") === -1) && !(!e && (g.src === "" || g.src.indexOf("blob:") !== -1)) && !oe(g, n, o, !0)) {
          I.push(g);
          const R = this.mirror.getId(g);
          b.has(R) || b.set(R, V);
        }
      }), I;
    }, S = (V) => ne(this, null, function* () {
      if (p && V - p < h) {
        d = requestAnimationFrame(S);
        return;
      }
      p = V;
      const I = (R) => {
        const C = this.mirror.getId(R), W = b.get(C), y = !a.initialSnapshotDelay || V - W > a.initialSnapshotDelay;
        return this.debug(R, {
          delay: a.initialSnapshotDelay,
          delta: V - W,
          hadLoadingTime: y
        }), y;
      }, g = [];
      g.push(
        ...f(V).filter(I).map((R) => this.snapshot(R))
      ), g.push(
        ...G(V).filter(I).map((R) => ne(this, null, function* () {
          this.debug(R, "starting video snapshotting");
          const C = this.mirror.getId(R);
          if (this.snapshotInProgressMap.get(C)) {
            this.debug(
              R,
              "video snapshotting already in progress for",
              C
            );
            return;
          }
          this.snapshotInProgressMap.set(C, !0);
          try {
            const { width: W, height: y } = R.getBoundingClientRect(), { actualWidth: X, actualHeight: Y } = {
              actualWidth: R.videoWidth,
              actualHeight: R.videoHeight
            }, v = Math.max(X, Y);
            if (v === 0) {
              this.debug(R, "not yet ready", {
                width: R.width,
                height: R.height,
                actualWidth: X,
                actualHeight: Y,
                boxWidth: W,
                boxHeight: y
              });
              return;
            }
            let Q = l || 1;
            u && (Q = Math.min(Q, u / v));
            const A = X * Q, w = Y * Q, te = yield createImageBitmap(R, {
              resizeWidth: A,
              resizeHeight: w
            }), M = Math.max(W, y) / v, j = X * M, ee = Y * M, E = (W - j) / 2, O = (y - ee) / 2;
            this.debug(R, "created image bitmap", {
              actualWidth: X,
              actualHeight: Y,
              boxWidth: W,
              boxHeight: y,
              outputWidth: j,
              outputHeight: ee,
              resizeWidth: A,
              resizeHeight: w,
              scale: Q,
              outputScale: M,
              offsetX: E,
              offsetY: O
            }), this.worker.postMessage(
              {
                id: C,
                bitmap: te,
                width: A,
                height: w,
                dx: E,
                dy: O,
                dw: j,
                dh: ee,
                dataURLOptions: a.dataURLOptions,
                logDebug: !!this.logger
              },
              [te]
            ), this.debug(R, "send message");
          } catch (W) {
            this.debug(R, "failed to snapshot", W);
          } finally {
            this.snapshotInProgressMap.set(C, !1);
          }
        }))
      ), yield Promise.all(g).catch(console.error), d = requestAnimationFrame(S);
    });
    d = requestAnimationFrame(S), this.resetObservers = () => {
      c(), d && cancelAnimationFrame(d);
    };
  }
  initCanvasMutationObserver(e, t, i) {
    this.startRAFTimestamping(), this.startPendingCanvasMutationFlusher();
    const r = Pn(
      e,
      t,
      i,
      !1
    ), n = fm(
      this.processMutation.bind(this),
      e,
      t,
      i
    ), o = ym(
      this.processMutation.bind(this),
      e,
      t,
      i
    );
    this.resetObservers = () => {
      r(), n(), o();
    };
  }
  startPendingCanvasMutationFlusher() {
    requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  startRAFTimestamping() {
    const e = (t) => {
      this.rafStamps.latestId = t, requestAnimationFrame(e);
    };
    requestAnimationFrame(e);
  }
  flushPendingCanvasMutations() {
    this.pendingCanvasMutations.forEach(
      (e, t) => {
        const i = this.mirror.getId(t);
        this.flushPendingCanvasMutationFor(t, i);
      }
    ), requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  flushPendingCanvasMutationFor(e, t) {
    if (this.frozen || this.locked)
      return;
    const i = this.pendingCanvasMutations.get(e);
    if (!i || t === -1) return;
    const r = i.map((o) => {
      const u = o, { type: a } = u;
      return Qe(u, ["type"]);
    }), { type: n } = i[0];
    this.mutationCb({ id: t, type: n, commands: r }), this.pendingCanvasMutations.delete(e);
  }
}
class Vm {
  constructor(e) {
    Z(this, "trackedLinkElements", /* @__PURE__ */ new WeakSet()), Z(this, "mutationCb"), Z(this, "adoptedStyleSheetCb"), Z(this, "styleMirror", new Mp()), this.mutationCb = e.mutationCb, this.adoptedStyleSheetCb = e.adoptedStyleSheetCb;
  }
  attachLinkElement(e, t) {
    "_cssText" in t.attributes && this.mutationCb({
      adds: [],
      removes: [],
      texts: [],
      attributes: [
        {
          id: t.id,
          attributes: t.attributes
        }
      ]
    }), this.trackLinkElement(e);
  }
  trackLinkElement(e) {
    this.trackedLinkElements.has(e) || (this.trackedLinkElements.add(e), this.trackStylesheetInLinkElement(e));
  }
  adoptStyleSheets(e, t) {
    if (e.length === 0) return;
    const i = {
      id: t,
      styleIds: []
    }, r = [];
    for (const n of e) {
      let o;
      this.styleMirror.has(n) ? o = this.styleMirror.getId(n) : (o = this.styleMirror.add(n), r.push({
        styleId: o,
        rules: Array.from(n.rules || CSSRule, (a, l) => ({
          rule: al(a, n.href),
          index: l
        }))
      })), i.styleIds.push(o);
    }
    r.length > 0 && (i.styles = r), this.adoptedStyleSheetCb(i);
  }
  reset() {
    this.styleMirror.reset(), this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
  }
  // TODO: take snapshot on stylesheet reload by applying event listener
  trackStylesheetInLinkElement(e) {
  }
}
class Sm {
  constructor() {
    Z(this, "nodeMap", /* @__PURE__ */ new WeakMap()), Z(this, "active", !1);
  }
  inOtherBuffer(e, t) {
    const i = this.nodeMap.get(e);
    return i && Array.from(i).some((r) => r !== t);
  }
  add(e, t) {
    this.active || (this.active = !0, requestAnimationFrame(() => {
      this.nodeMap = /* @__PURE__ */ new WeakMap(), this.active = !1;
    })), this.nodeMap.set(e, (this.nodeMap.get(e) || /* @__PURE__ */ new Set()).add(t));
  }
  destroy() {
  }
}
let q, Xi, Lt, Fi = !1;
try {
  if (Array.from([1], (s) => s * 2)[0] !== 2) {
    const s = document.createElement("iframe");
    document.body.appendChild(s), Array.from = ((Or = s.contentWindow) == null ? void 0 : Or.Array.from) || Array.from, document.body.removeChild(s);
  }
} catch (s) {
  console.debug("Unable to override Array.from", s);
}
const Ge = yc();
function Ye(s = {}) {
  var e, t, i, r, n, o, a, l;
  const {
    emit: u,
    checkoutEveryNms: c,
    checkoutEveryNth: h,
    blockClass: p = "highlight-block",
    blockSelector: d = null,
    ignoreClass: b = "highlight-ignore",
    ignoreSelector: m = null,
    maskTextClass: f = "highlight-mask",
    maskTextSelector: G = null,
    inlineStylesheet: S = !0,
    maskAllInputs: V,
    maskInputOptions: I,
    slimDOMOptions: g,
    maskInputFn: R,
    maskTextFn: C = lr,
    hooks: W,
    packFn: y,
    sampling: X = {},
    mousemoveWait: Y,
    recordDOM: v = !0,
    recordCanvas: Q = !1,
    recordCrossOriginIframes: A = !1,
    recordAfter: w = s.recordAfter === "DOMContentLoaded" ? s.recordAfter : "load",
    userTriggeredOnInput: te = !1,
    collectFonts: M = !1,
    inlineImages: j = !1,
    inlineVideos: ee = !1,
    plugins: E,
    keepIframeSrcFn: O = () => !1,
    privacySetting: pe = "default",
    ignoreCSSAttributes: ae = /* @__PURE__ */ new Set([]),
    errorHandler: be,
    logger: se
  } = s, ge = x(x({}, s.dataURLOptions), (t = (e = s.sampling) == null ? void 0 : e.canvas) == null ? void 0 : t.dataURLOptions);
  Dp(be);
  const Pe = A ? window.parent === window : !0;
  let we = !1;
  if (!Pe)
    try {
      window.parent.document && (we = !1);
    } catch (F) {
      we = !0;
    }
  if (Pe && !u)
    throw new Error("emit function is required");
  if (!Pe && !we)
    return () => {
    };
  Y !== void 0 && X.mousemove === void 0 && (X.mousemove = Y), Ge.reset();
  const yt = V === !0 ? {
    color: !0,
    date: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
    textarea: !0,
    select: !0,
    password: !0
  } : I !== void 0 ? I : { password: !0 }, et = g === !0 || g === "all" ? {
    script: !0,
    comment: !0,
    headFavicon: !0,
    headWhitespace: !0,
    headMetaSocial: !0,
    headMetaRobots: !0,
    headMetaHttpEquiv: !0,
    headMetaVerification: !0,
    // the following are off for slimDOMOptions === true,
    // as they destroy some (hidden) info:
    headMetaAuthorship: g === "all",
    headMetaDescKeywords: g === "all",
    headTitleMutations: g === "all"
  } : g || {};
  Hp();
  let gt, tt = 0;
  const it = (F) => {
    for (const Ze of E || [])
      Ze.eventProcessor && (F = Ze.eventProcessor(F));
    return y && // Disable packing events which will be emitted to parent frames.
    !we && (F = y(F)), F;
  };
  q = (F, Ze) => {
    var _;
    const $ = F;
    if ($.timestamp = Ui(), (_ = je[0]) != null && _.isFrozen() && $.type !== K.FullSnapshot && !($.type === K.IncrementalSnapshot && $.data.source === T.Mutation) && je.forEach((Ie) => Ie.unfreeze()), Pe)
      u == null || u(it($), Ze);
    else if (we) {
      const Ie = {
        type: "rrweb",
        event: it($),
        origin: window.location.origin,
        isCheckout: Ze
      };
      window.parent.postMessage(Ie, "*");
    }
    if ($.type === K.FullSnapshot)
      gt = $, tt = 0;
    else if ($.type === K.IncrementalSnapshot) {
      if ($.data.source === T.Mutation && $.data.isAttachIframe)
        return;
      tt++;
      const Ie = h && tt >= h, P = c && $.timestamp - gt.timestamp > c;
      (Ie || P) && Xi(!0);
    }
  };
  const Ue = (F) => {
    q({
      type: K.IncrementalSnapshot,
      data: x({
        source: T.Mutation
      }, F)
    });
  }, vr = (F) => q({
    type: K.IncrementalSnapshot,
    data: x({
      source: T.Scroll
    }, F)
  }), Yr = (F) => q({
    type: K.IncrementalSnapshot,
    data: x({
      source: T.CanvasMutation
    }, F)
  }), da = (F) => q({
    type: K.IncrementalSnapshot,
    data: x({
      source: T.AdoptedStyleSheet
    }, F)
  }), Ee = new Vm({
    mutationCb: Ue,
    adoptedStyleSheetCb: da
  }), Be = new um({
    mirror: Ge,
    mutationCb: Ue,
    stylesheetManager: Ee,
    recordCrossOriginIframes: A,
    wrappedEmit: q
  });
  for (const F of E || [])
    F.getMirror && F.getMirror({
      nodeMirror: Ge,
      crossOriginIframeMirror: Be.crossOriginIframeMirror,
      crossOriginIframeStyleMirror: Be.crossOriginIframeStyleMirror
    });
  const $i = new Sm();
  Lt = new Gm({
    recordCanvas: Q,
    recordLocalVideos: j,
    recordRemoteVideos: ee,
    mutationCb: Yr,
    win: window,
    blockClass: p,
    blockSelector: d,
    mirror: Ge,
    sampling: (i = X == null ? void 0 : X.canvas) == null ? void 0 : i.fps,
    samplingManual: (r = X == null ? void 0 : X.canvas) == null ? void 0 : r.fpsManual,
    clearWebGLBuffer: (n = X == null ? void 0 : X.canvas) == null ? void 0 : n.clearWebGLBuffer,
    initialSnapshotDelay: (o = X == null ? void 0 : X.canvas) == null ? void 0 : o.initialSnapshotDelay,
    dataURLOptions: ge,
    resizeFactor: (a = X == null ? void 0 : X.canvas) == null ? void 0 : a.resizeFactor,
    maxSnapshotDimension: (l = X == null ? void 0 : X.canvas) == null ? void 0 : l.maxSnapshotDimension,
    logger: se
  });
  const Dt = new hm({
    mutationCb: Ue,
    scrollCb: vr,
    bypassOptions: {
      blockClass: p,
      blockSelector: d,
      maskTextClass: f,
      maskTextSelector: G,
      inlineStylesheet: S,
      maskInputOptions: yt,
      dataURLOptions: ge,
      maskTextFn: C,
      maskInputFn: R,
      recordCanvas: Q,
      inlineImages: j,
      inlineVideos: ee,
      privacySetting: pe,
      sampling: X,
      slimDOMOptions: et,
      iframeManager: Be,
      stylesheetManager: Ee,
      canvasManager: Lt,
      keepIframeSrcFn: O,
      processedNodeManager: $i
    },
    mirror: Ge
  });
  Xi = (F = !1) => {
    if (!v)
      return;
    q(
      {
        type: K.Meta,
        data: {
          href: window.location.href,
          width: Mo(),
          height: Ho()
        }
      },
      F
    ), Ee.reset(), Dt.init(), je.forEach((_) => _.lock());
    const Ze = jc(document, {
      mirror: Ge,
      blockClass: p,
      blockSelector: d,
      maskTextClass: f,
      maskTextSelector: G,
      inlineStylesheet: S,
      maskAllInputs: yt,
      maskTextFn: C,
      maskInputFn: R,
      slimDOM: et,
      dataURLOptions: ge,
      recordCanvas: Q,
      inlineImages: j,
      inlineVideos: ee,
      privacySetting: pe,
      onSerialize: (_) => {
        Eo(_, Ge) && Be.addIframe(_), Bo(_, Ge) && Ee.trackLinkElement(_), qs(_) && Dt.addShadowRoot(N.shadowRoot(_), document);
      },
      onIframeLoad: (_, $) => {
        Be.attachIframe(_, $), Dt.observeAttachShadow(_);
      },
      onStylesheetLoad: (_, $) => {
        Ee.attachLinkElement(_, $);
      },
      keepIframeSrcFn: O
    });
    if (!Ze)
      return console.warn("Failed to snapshot the document");
    q(
      {
        type: K.FullSnapshot,
        data: {
          node: Ze,
          initialOffset: zo(window)
        }
      },
      F
    ), je.forEach((_) => _.unlock()), document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0 && Ee.adoptStyleSheets(
      document.adoptedStyleSheets,
      Ge.getId(document)
    );
  };
  try {
    const F = [], Ze = ($) => {
      var Ie;
      return U(cm)(
        {
          mutationCb: Ue,
          mousemoveCb: (P, qi) => q({
            type: K.IncrementalSnapshot,
            data: {
              source: qi,
              positions: P
            }
          }),
          mouseInteractionCb: (P) => q({
            type: K.IncrementalSnapshot,
            data: x({
              source: T.MouseInteraction
            }, P)
          }),
          scrollCb: vr,
          viewportResizeCb: (P) => q({
            type: K.IncrementalSnapshot,
            data: x({
              source: T.ViewportResize
            }, P)
          }),
          inputCb: (P) => q({
            type: K.IncrementalSnapshot,
            data: x({
              source: T.Input
            }, P)
          }),
          mediaInteractionCb: (P) => q({
            type: K.IncrementalSnapshot,
            data: x({
              source: T.MediaInteraction
            }, P)
          }),
          styleSheetRuleCb: (P) => q({
            type: K.IncrementalSnapshot,
            data: x({
              source: T.StyleSheetRule
            }, P)
          }),
          styleDeclarationCb: (P) => q({
            type: K.IncrementalSnapshot,
            data: x({
              source: T.StyleDeclaration
            }, P)
          }),
          canvasMutationCb: Yr,
          fontCb: (P) => q({
            type: K.IncrementalSnapshot,
            data: x({
              source: T.Font
            }, P)
          }),
          selectionCb: (P) => {
            q({
              type: K.IncrementalSnapshot,
              data: x({
                source: T.Selection
              }, P)
            });
          },
          customElementCb: (P) => {
            q({
              type: K.IncrementalSnapshot,
              data: x({
                source: T.CustomElement
              }, P)
            });
          },
          blockClass: p,
          ignoreClass: b,
          ignoreSelector: m,
          maskTextClass: f,
          maskTextSelector: G,
          maskInputOptions: yt,
          inlineStylesheet: S,
          sampling: X,
          recordDOM: v,
          recordCanvas: Q,
          inlineImages: j,
          inlineVideos: ee,
          userTriggeredOnInput: te,
          collectFonts: M,
          doc: $,
          maskInputFn: R,
          maskTextFn: C,
          keepIframeSrcFn: O,
          blockSelector: d,
          slimDOMOptions: et,
          dataURLOptions: ge,
          mirror: Ge,
          iframeManager: Be,
          stylesheetManager: Ee,
          shadowDomManager: Dt,
          processedNodeManager: $i,
          canvasManager: Lt,
          ignoreCSSAttributes: ae,
          privacySetting: pe,
          plugins: ((Ie = E == null ? void 0 : E.filter((P) => P.observer)) == null ? void 0 : Ie.map((P) => ({
            observer: P.observer,
            options: P.options,
            callback: (qi) => q({
              type: K.Plugin,
              data: {
                plugin: P.name,
                payload: qi
              }
            })
          }))) || []
        },
        W
      );
    };
    Be.addLoadListener(($) => {
      try {
        F.push(Ze($.contentDocument));
      } catch (Ie) {
        console.warn(Ie);
      }
    });
    const _ = () => {
      Xi(), F.push(Ze(document)), Fi = !0;
    };
    return document.readyState === "interactive" || document.readyState === "complete" ? _() : (F.push(
      he("DOMContentLoaded", () => {
        q({
          type: K.DomContentLoaded,
          data: {}
        }), w === "DOMContentLoaded" && _();
      })
    ), F.push(
      he(
        "load",
        () => {
          q({
            type: K.Load,
            data: {}
          }), w === "load" && _();
        },
        window
      )
    )), () => {
      F.forEach(($) => $()), $i.destroy(), Fi = !1, Ap();
    };
  } catch (F) {
    console.warn(F);
  }
}
Ye.addCustomEvent = (s, e) => {
  Fi && q({
    type: K.Custom,
    data: {
      tag: s,
      payload: e
    }
  });
};
Ye.freezePage = () => {
  je.forEach((s) => s.freeze());
};
Ye.takeFullSnapshot = (s) => {
  if (!Fi)
    throw new Error("please take full snapshot after start recording");
  Xi(s);
};
Ye.snapshotCanvas = (s) => ne(void 0, null, function* () {
  if (!Lt)
    throw new Error("canvas manager is not initialized");
  yield Lt.snapshot(s);
});
Ye.mirror = Ge;
var Qn;
(function(s) {
  s[s.NotStarted = 0] = "NotStarted", s[s.Running = 1] = "Running", s[s.Stopped = 2] = "Stopped";
})(Qn || (Qn = {}));
const { addCustomEvent: jn } = Ye, Im = (s) => {
  s(window.location.href);
  const e = history.pushState;
  history.pushState = /* @__PURE__ */ ((n) => function() {
    var a = n.apply(this, arguments);
    return window.dispatchEvent(new Event("pushstate")), window.dispatchEvent(new Event("locationchange")), a;
  })(history.pushState);
  const t = history.replaceState;
  history.replaceState = /* @__PURE__ */ ((n) => function() {
    var a = n.apply(this, arguments);
    return window.dispatchEvent(new Event("replacestate")), window.dispatchEvent(new Event("locationchange")), a;
  })(history.replaceState);
  const i = () => {
    window.dispatchEvent(new Event("locationchange"));
  };
  window.addEventListener("popstate", i);
  const r = function() {
    s(window.location.href);
  };
  return window.addEventListener("locationchange", r), () => {
    window.removeEventListener("popstate", i), window.removeEventListener("locationchange", r), history.pushState = e, history.replaceState = t;
  };
}, Xm = (s) => {
  switch (s) {
    case "strict":
      return [!0, void 0];
    case "default":
      return [!0, void 0];
    case "none":
      return [!1, { password: !0 }];
  }
}, Wm = (s) => {
  const e = (t) => {
    if (t.target) {
      const i = t.target, r = nl(i);
      s(r, t);
    }
  };
  return window.addEventListener("click", e), () => window.removeEventListener("click", e);
}, Rm = (s) => {
  const e = (t) => {
    if (t.target) {
      const i = nl(t.target);
      s(i);
    }
  };
  return window.addEventListener("focusin", e), () => window.removeEventListener("focusin", e);
}, Cm = (s) => {
  let e, t;
  if (typeof document.hidden != "undefined" ? (e = "hidden", t = "visibilitychange") : typeof document.msHidden != "undefined" ? (e = "msHidden", t = "msvisibilitychange") : typeof document.webkitHidden != "undefined" && (e = "webkitHidden", t = "webkitvisibilitychange"), t === void 0)
    return () => {
    };
  if (e === void 0)
    return () => {
    };
  const i = e, r = () => {
    const o = document[i];
    s(!!o);
  };
  document.addEventListener(t, r);
  const n = t;
  return () => document.removeEventListener(n, r);
}, wm = (s) => {
  s(window.location.href);
  var e = XMLHttpRequest.prototype.send;
  XMLHttpRequest.prototype.send = function(n) {
    setTimeout(() => {
      var a;
      var o;
      try {
        o = JSON.parse((a = n == null ? void 0 : n.toString()) != null ? a : "");
      } catch (l) {
        return;
      }
      (o.type === "track" || o.type === "identify") && ys(o) && s(o);
    }, 100), e.call(this, n);
  };
  const t = (n) => {
    if (n.key === "ajs_user_id" || n.key === "ajs_anonymous_id" || n.key === "ajs_user_traits") {
      const { userId: o, userTraits: a } = Dn();
      if (o) {
        let l = {};
        a && (l = JSON.parse(a));
        const u = {
          type: "identify",
          userId: o.toString(),
          traits: l
        };
        ys(u) && s(u);
      }
    }
  }, { userId: i, userTraits: r } = Dn();
  if (i) {
    let n = {};
    r && (n = JSON.parse(r));
    const o = {
      type: "identify",
      userId: i.toString(),
      traits: n
    };
    ys(o) && s(o);
  }
  return window.addEventListener("storage", t), ba(({ keyName: n }) => {
    t({
      key: n
    });
  }), () => {
    window.removeEventListener("storage", t), XMLHttpRequest.prototype.send = e;
  };
}, Dn = () => {
  const s = Ce(
    "ajs_user_id"
    /* USER_ID */
  ), e = Ce(
    "ajs_user_traits"
    /* USER_TRAITS */
  ), t = Ce(
    "ajs_anonymous_id"
    /* ANONYMOUS_ID */
  );
  return {
    userId: s,
    userTraits: e,
    anonymousId: t
  };
}, ys = (s) => {
  if (!s)
    return !1;
  let e = "";
  try {
    e = JSON.stringify(s);
  } catch (r) {
    return !1;
  }
  const t = xm(e), i = Ce(
    ve.SEGMENT_LAST_SENT_HASH_KEY
  );
  return i === void 0 ? (De(ve.SEGMENT_LAST_SENT_HASH_KEY, t), !0) : t !== i ? (De(ve.SEGMENT_LAST_SENT_HASH_KEY, t), !0) : !1;
}, xm = (s) => {
  var e = 0, t = s.length, i = 0;
  if (t > 0) for (; i < t; ) e = (e << 5) - e + s.charCodeAt(i++) | 0;
  return e.toString();
}, km = (s, e) => {
  const t = Lm(s);
  let i = [];
  const r = !1, n = !0;
  for (let o = 0; o < t.length; o++) {
    let a = t[o].split("+");
    i = [], a.length > 1 && (i = Ym(ra, a)), a = a[a.length - 1], a = a === "*" ? "*" : vm(a), a in Re || (Re[a] = []), Re[a].push({
      mods: i,
      shortcut: t[o],
      key: t[o],
      method: e,
      keyup: r,
      keydown: n,
      scope: "all",
      splitKey: "+"
    });
  }
  Nm(document, "keydown", (o) => {
    Um(o);
  });
};
let ce = [];
function Lm(s) {
  typeof s != "string" && (s = ""), s = s.replace(/\s/g, "");
  const e = s.split(",");
  let t = e.lastIndexOf("");
  for (; t >= 0; )
    e[t - 1] += ",", e.splice(t, 1), t = e.lastIndexOf("");
  return e;
}
const Re = {}, gs = typeof navigator != "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1, Jm = {
  backspace: 8,
  tab: 9,
  clear: 12,
  enter: 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": gs ? 173 : 189,
  "=": gs ? 61 : 187,
  ";": gs ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, An = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, ue = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, ra = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
}, vm = (s) => (
  // @ts-expect-error
  Jm[s.toLowerCase()] || // @ts-expect-error
  ra[s.toLowerCase()] || s.toUpperCase().charCodeAt(0)
);
function Ym(s, e) {
  const t = e.slice(0, e.length - 1);
  for (let i = 0; i < t.length; i++)
    t[i] = s[t[i].toLowerCase()];
  return t;
}
function Nm(s, e, t) {
  s.addEventListener ? s.addEventListener(e, t, !1) : s.attachEvent && s.attachEvent(`on${e}`, () => {
    t(window.event);
  });
}
function Tm(s, e, t) {
  let i;
  if (e.scope === t || e.scope === "all") {
    i = e.mods.length > 0;
    for (const r in ue)
      Object.prototype.hasOwnProperty.call(ue, r) && // @ts-expect-error
      (!ue[r] && e.mods.indexOf(+r) > -1 || // @ts-expect-error
      ue[r] && e.mods.indexOf(+r) === -1) && (i = !1);
    (e.mods.length === 0 && !ue[16] && !ue[18] && !ue[17] && !ue[91] || i || e.shortcut === "*") && e.method(s, e) === !1 && (s.preventDefault ? s.preventDefault() : s.returnValue = !1, s.stopPropagation && s.stopPropagation(), s.cancelBubble && (s.cancelBubble = !0));
  }
}
function Um(s) {
  const e = Re["*"];
  let t = s.keyCode || s.which || s.charCode;
  if ((t === 93 || t === 224) && (t = 91), ce.indexOf(t) === -1 && t !== 229 && ce.push(t), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach((i) => {
    const r = An[i];
    s[i] && ce.indexOf(r) === -1 ? ce.push(r) : !s[i] && ce.indexOf(r) > -1 ? ce.splice(ce.indexOf(r), 1) : i === "metaKey" && s[i] && ce.length === 3 && (s.ctrlKey || s.shiftKey || s.altKey || (ce = ce.slice(ce.indexOf(r))));
  }), !(t in ue && (ue[t] = !0, !e))) {
    for (const i in ue)
      Object.prototype.hasOwnProperty.call(ue, i) && (ue[i] = s[An[i]]);
    if (s.getModifierState && !(s.altKey && !s.ctrlKey) && s.getModifierState("AltGraph") && (ce.indexOf(17) === -1 && ce.push(17), ce.indexOf(18) === -1 && ce.push(18), ue[17] = !0, ue[18] = !0), t in Re) {
      for (let i = 0; i < Re[t].length; i++)
        if (
          // @ts-expect-error
          (s.type === "keydown" && Re[t][i].keydown || // @ts-expect-error
          s.type === "keyup" && Re[t][i].keyup) && Re[t][i].key
        ) {
          const r = Re[t][i];
          Tm(s, r, "all");
        }
    }
  }
}
const _n = "iframe parent ready", $n = "iframe ok", Ot = "highlightLogs", Km = (s) => {
  let e = Ce(Ot) || "";
  e = e + "[" + (/* @__PURE__ */ new Date()).getTime() + "] " + s + `
`, De(Ot, e);
}, Fm = () => Ce(Ot) || "", zm = (s) => {
  if (!s)
    return;
  let e = Ce(Ot) || "";
  e && (e.startsWith(s) ? (e = e.slice(s.length), De(Ot, e)) : Km(
    "Unable to clear logs " + s.replace(`
`, " ") + " from " + e.replace(`
`, " ")
  ));
};
var fe = Uint8Array, me = Uint16Array, kr = Int32Array, Lr = new fe([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Jr = new fe([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), qn = new fe([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), na = function(s, e) {
  for (var t = new me(31), i = 0; i < 31; ++i)
    t[i] = e += 1 << s[i - 1];
  for (var r = new kr(t[30]), i = 1; i < 30; ++i)
    for (var n = t[i]; n < t[i + 1]; ++n)
      r[n] = n - t[i] << 5 | i;
  return { b: t, r };
}, la = na(Lr, 2), Hm = la.b, tr = la.r;
Hm[28] = 258, tr[258] = 28;
var Mm = na(Jr, 0), el = Mm.r, ir = new me(32768);
for (var D = 0; D < 32768; ++D) {
  var Ke = (D & 43690) >> 1 | (D & 21845) << 1;
  Ke = (Ke & 52428) >> 2 | (Ke & 13107) << 2, Ke = (Ke & 61680) >> 4 | (Ke & 3855) << 4, ir[D] = ((Ke & 65280) >> 8 | (Ke & 255) << 8) >> 1;
}
var Jt = function(s, e, t) {
  for (var i = s.length, r = 0, n = new me(e); r < i; ++r)
    s[r] && ++n[s[r] - 1];
  var o = new me(e);
  for (r = 1; r < e; ++r)
    o[r] = o[r - 1] + n[r - 1] << 1;
  var a;
  if (t) {
    a = new me(1 << e);
    var l = 15 - e;
    for (r = 0; r < i; ++r)
      if (s[r])
        for (var u = r << 4 | s[r], c = e - s[r], h = o[s[r] - 1]++ << c, p = h | (1 << c) - 1; h <= p; ++h)
          a[ir[h] >> l] = u;
  } else
    for (a = new me(i), r = 0; r < i; ++r)
      s[r] && (a[r] = ir[o[s[r] - 1]++] >> 15 - s[r]);
  return a;
}, Ae = new fe(288);
for (var D = 0; D < 144; ++D)
  Ae[D] = 8;
for (var D = 144; D < 256; ++D)
  Ae[D] = 9;
for (var D = 256; D < 280; ++D)
  Ae[D] = 7;
for (var D = 280; D < 288; ++D)
  Ae[D] = 8;
var zi = new fe(32);
for (var D = 0; D < 32; ++D)
  zi[D] = 5;
var Om = /* @__PURE__ */ Jt(Ae, 9, 0), Pm = /* @__PURE__ */ Jt(zi, 5, 0), oa = function(s) {
  return (s + 7) / 8 | 0;
}, aa = function(s, e, t) {
  return (t == null || t > s.length) && (t = s.length), new fe(s.subarray(e, t));
}, Le = function(s, e, t) {
  t <<= e & 7;
  var i = e / 8 | 0;
  s[i] |= t, s[i + 1] |= t >> 8;
}, Rt = function(s, e, t) {
  t <<= e & 7;
  var i = e / 8 | 0;
  s[i] |= t, s[i + 1] |= t >> 8, s[i + 2] |= t >> 16;
}, Zs = function(s, e) {
  for (var t = [], i = 0; i < s.length; ++i)
    s[i] && t.push({ s: i, f: s[i] });
  var r = t.length, n = t.slice();
  if (!r)
    return { t: ua, l: 0 };
  if (r == 1) {
    var o = new fe(t[0].s + 1);
    return o[t[0].s] = 1, { t: o, l: 1 };
  }
  t.sort(function(g, R) {
    return g.f - R.f;
  }), t.push({ s: -1, f: 25001 });
  var a = t[0], l = t[1], u = 0, c = 1, h = 2;
  for (t[0] = { s: -1, f: a.f + l.f, l: a, r: l }; c != r - 1; )
    a = t[t[u].f < t[h].f ? u++ : h++], l = t[u != c && t[u].f < t[h].f ? u++ : h++], t[c++] = { s: -1, f: a.f + l.f, l: a, r: l };
  for (var p = n[0].s, i = 1; i < r; ++i)
    n[i].s > p && (p = n[i].s);
  var d = new me(p + 1), b = sr(t[c - 1], d, 0);
  if (b > e) {
    var i = 0, m = 0, f = b - e, G = 1 << f;
    for (n.sort(function(R, C) {
      return d[C.s] - d[R.s] || R.f - C.f;
    }); i < r; ++i) {
      var S = n[i].s;
      if (d[S] > e)
        m += G - (1 << b - d[S]), d[S] = e;
      else
        break;
    }
    for (m >>= f; m > 0; ) {
      var V = n[i].s;
      d[V] < e ? m -= 1 << e - d[V]++ - 1 : ++i;
    }
    for (; i >= 0 && m; --i) {
      var I = n[i].s;
      d[I] == e && (--d[I], ++m);
    }
    b = e;
  }
  return { t: new fe(d), l: b };
}, sr = function(s, e, t) {
  return s.s == -1 ? Math.max(sr(s.l, e, t + 1), sr(s.r, e, t + 1)) : e[s.s] = t;
}, tl = function(s) {
  for (var e = s.length; e && !s[--e]; )
    ;
  for (var t = new me(++e), i = 0, r = s[0], n = 1, o = function(l) {
    t[i++] = l;
  }, a = 1; a <= e; ++a)
    if (s[a] == r && a != e)
      ++n;
    else {
      if (!r && n > 2) {
        for (; n > 138; n -= 138)
          o(32754);
        n > 2 && (o(n > 10 ? n - 11 << 5 | 28690 : n - 3 << 5 | 12305), n = 0);
      } else if (n > 3) {
        for (o(r), --n; n > 6; n -= 6)
          o(8304);
        n > 2 && (o(n - 3 << 5 | 8208), n = 0);
      }
      for (; n--; )
        o(r);
      n = 1, r = s[a];
    }
  return { c: t.subarray(0, i), n: e };
}, Ct = function(s, e) {
  for (var t = 0, i = 0; i < e.length; ++i)
    t += s[i] * e[i];
  return t;
}, ca = function(s, e, t) {
  var i = t.length, r = oa(e + 2);
  s[r] = i & 255, s[r + 1] = i >> 8, s[r + 2] = s[r] ^ 255, s[r + 3] = s[r + 1] ^ 255;
  for (var n = 0; n < i; ++n)
    s[r + n + 4] = t[n];
  return (r + 4 + i) * 8;
}, il = function(s, e, t, i, r, n, o, a, l, u, c) {
  Le(e, c++, t), ++r[256];
  for (var h = Zs(r, 15), p = h.t, d = h.l, b = Zs(n, 15), m = b.t, f = b.l, G = tl(p), S = G.c, V = G.n, I = tl(m), g = I.c, R = I.n, C = new me(19), W = 0; W < S.length; ++W)
    ++C[S[W] & 31];
  for (var W = 0; W < g.length; ++W)
    ++C[g[W] & 31];
  for (var y = Zs(C, 7), X = y.t, Y = y.l, v = 19; v > 4 && !X[qn[v - 1]]; --v)
    ;
  var Q = u + 5 << 3, A = Ct(r, Ae) + Ct(n, zi) + o, w = Ct(r, p) + Ct(n, m) + o + 14 + 3 * v + Ct(C, X) + 2 * C[16] + 3 * C[17] + 7 * C[18];
  if (l >= 0 && Q <= A && Q <= w)
    return ca(e, c, s.subarray(l, l + u));
  var te, M, j, ee;
  if (Le(e, c, 1 + (w < A)), c += 2, w < A) {
    te = Jt(p, d, 0), M = p, j = Jt(m, f, 0), ee = m;
    var E = Jt(X, Y, 0);
    Le(e, c, V - 257), Le(e, c + 5, R - 1), Le(e, c + 10, v - 4), c += 14;
    for (var W = 0; W < v; ++W)
      Le(e, c + 3 * W, X[qn[W]]);
    c += 3 * v;
    for (var O = [S, g], pe = 0; pe < 2; ++pe)
      for (var ae = O[pe], W = 0; W < ae.length; ++W) {
        var be = ae[W] & 31;
        Le(e, c, E[be]), c += X[be], be > 15 && (Le(e, c, ae[W] >> 5 & 127), c += ae[W] >> 12);
      }
  } else
    te = Om, M = Ae, j = Pm, ee = zi;
  for (var W = 0; W < a; ++W) {
    var se = i[W];
    if (se > 255) {
      var be = se >> 18 & 31;
      Rt(e, c, te[be + 257]), c += M[be + 257], be > 7 && (Le(e, c, se >> 23 & 31), c += Lr[be]);
      var ge = se & 31;
      Rt(e, c, j[ge]), c += ee[ge], ge > 3 && (Rt(e, c, se >> 5 & 8191), c += Jr[ge]);
    } else
      Rt(e, c, te[se]), c += M[se];
  }
  return Rt(e, c, te[256]), c + M[256];
}, Em = /* @__PURE__ */ new kr([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), ua = /* @__PURE__ */ new fe(0), Bm = function(s, e, t, i, r, n) {
  var o = n.z || s.length, a = new fe(i + o + 5 * (1 + Math.ceil(o / 7e3)) + r), l = a.subarray(i, a.length - r), u = n.l, c = (n.r || 0) & 7;
  if (e) {
    c && (l[0] = n.r >> 3);
    for (var h = Em[e - 1], p = h >> 13, d = h & 8191, b = (1 << t) - 1, m = n.p || new me(32768), f = n.h || new me(b + 1), G = Math.ceil(t / 3), S = 2 * G, V = function(Ue) {
      return (s[Ue] ^ s[Ue + 1] << G ^ s[Ue + 2] << S) & b;
    }, I = new kr(25e3), g = new me(288), R = new me(32), C = 0, W = 0, y = n.i || 0, X = 0, Y = n.w || 0, v = 0; y + 2 < o; ++y) {
      var Q = V(y), A = y & 32767, w = f[Q];
      if (m[A] = w, f[Q] = A, Y <= y) {
        var te = o - y;
        if ((C > 7e3 || X > 24576) && (te > 423 || !u)) {
          c = il(s, l, 0, I, g, R, W, X, v, y - v, c), X = C = W = 0, v = y;
          for (var M = 0; M < 286; ++M)
            g[M] = 0;
          for (var M = 0; M < 30; ++M)
            R[M] = 0;
        }
        var j = 2, ee = 0, E = d, O = A - w & 32767;
        if (te > 2 && Q == V(y - O))
          for (var pe = Math.min(p, te) - 1, ae = Math.min(32767, y), be = Math.min(258, te); O <= ae && --E && A != w; ) {
            if (s[y + j] == s[y + j - O]) {
              for (var se = 0; se < be && s[y + se] == s[y + se - O]; ++se)
                ;
              if (se > j) {
                if (j = se, ee = O, se > pe)
                  break;
                for (var ge = Math.min(O, se - 2), Pe = 0, M = 0; M < ge; ++M) {
                  var we = y - O + M & 32767, yt = m[we], et = we - yt & 32767;
                  et > Pe && (Pe = et, w = we);
                }
              }
            }
            A = w, w = m[A], O += A - w & 32767;
          }
        if (ee) {
          I[X++] = 268435456 | tr[j] << 18 | el[ee];
          var gt = tr[j] & 31, tt = el[ee] & 31;
          W += Lr[gt] + Jr[tt], ++g[257 + gt], ++R[tt], Y = y + j, ++C;
        } else
          I[X++] = s[y], ++g[s[y]];
      }
    }
    for (y = Math.max(y, Y); y < o; ++y)
      I[X++] = s[y], ++g[s[y]];
    c = il(s, l, u, I, g, R, W, X, v, y - v, c), u || (n.r = c & 7 | l[c / 8 | 0] << 3, c -= 7, n.h = f, n.p = m, n.i = y, n.w = Y);
  } else {
    for (var y = n.w || 0; y < o + u; y += 65535) {
      var it = y + 65535;
      it >= o && (l[c / 8 | 0] = u, it = o), c = ca(l, c + 1, s.subarray(y, it));
    }
    n.i = o;
  }
  return aa(a, 0, i + oa(c) + r);
}, Qm = /* @__PURE__ */ function() {
  for (var s = new Int32Array(256), e = 0; e < 256; ++e) {
    for (var t = e, i = 9; --i; )
      t = (t & 1 && -306674912) ^ t >>> 1;
    s[e] = t;
  }
  return s;
}(), jm = function() {
  var s = -1;
  return {
    p: function(e) {
      for (var t = s, i = 0; i < e.length; ++i)
        t = Qm[t & 255 ^ e[i]] ^ t >>> 8;
      s = t;
    },
    d: function() {
      return ~s;
    }
  };
}, Dm = function(s, e, t, i, r) {
  if (!r && (r = { l: 1 }, e.dictionary)) {
    var n = e.dictionary.subarray(-32768), o = new fe(n.length + s.length);
    o.set(n), o.set(s, n.length), s = o, r.w = n.length;
  }
  return Bm(s, e.level == null ? 6 : e.level, e.mem == null ? r.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(s.length))) * 1.5) : 20 : 12 + e.mem, t, i, r);
}, rr = function(s, e, t) {
  for (; t; ++e)
    s[e] = t, t >>>= 8;
}, Am = function(s, e) {
  var t = e.filename;
  if (s[0] = 31, s[1] = 139, s[2] = 8, s[8] = e.level < 2 ? 4 : e.level == 9 ? 2 : 0, s[9] = 3, e.mtime != 0 && rr(s, 4, Math.floor(new Date(e.mtime || Date.now()) / 1e3)), t) {
    s[3] = 8;
    for (var i = 0; i <= t.length; ++i)
      s[i + 10] = t.charCodeAt(i);
  }
}, _m = function(s) {
  return 10 + (s.filename ? s.filename.length + 1 : 0);
};
function $m(s, e) {
  e || (e = {});
  var t = jm(), i = s.length;
  t.p(s);
  var r = Dm(s, e, _m(e), 8), n = r.length;
  return Am(r, e), rr(r, n - 8, t.d()), rr(r, n - 4, i), r;
}
var sl = typeof TextEncoder != "undefined" && /* @__PURE__ */ new TextEncoder(), qm = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
try {
  qm.decode(ua, { stream: !0 });
} catch (s) {
}
function ef(s, e) {
  var t;
  if (sl)
    return sl.encode(s);
  for (var i = s.length, r = new fe(s.length + (s.length >> 1)), n = 0, o = function(u) {
    r[n++] = u;
  }, t = 0; t < i; ++t) {
    if (n + 5 > r.length) {
      var a = new fe(n + 8 + (i - t << 1));
      a.set(r), r = a;
    }
    var l = s.charCodeAt(t);
    l < 128 || e ? o(l) : l < 2048 ? (o(192 | l >> 6), o(128 | l & 63)) : l > 55295 && l < 57344 ? (l = 65536 + (l & 1047552) | s.charCodeAt(++t) & 1023, o(240 | l >> 18), o(128 | l >> 12 & 63), o(128 | l >> 6 & 63), o(128 | l & 63)) : (o(224 | l >> 12), o(128 | l >> 6 & 63), o(128 | l & 63));
  }
  return aa(r, 0, n);
}
function tf(s) {
  return ne(this, null, function* () {
    const e = ef(JSON.stringify(s)), t = $m(e), i = yield new Promise((r) => {
      const n = new FileReader();
      n.onload = () => r(n.result), n.readAsDataURL(new Blob([new Uint8Array(t)]));
    });
    return {
      compressedBase64: i.slice(i.indexOf(",") + 1),
      compressedSize: t.length,
      bufferLength: e.length
    };
  });
}
const ha = "dmFyIFZyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxqcj1PYmplY3QuZGVmaW5lUHJvcGVydGllczt2YXIgcXI9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7dmFyICRlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7dmFyIHRuPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksbm49T2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTt2YXIgZnQ9KEYsUCxNKT0+UCBpbiBGP1ZyKEYsUCx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6TX0pOkZbUF09TSxEPShGLFApPT57Zm9yKHZhciBNIGluIFB8fChQPXt9KSl0bi5jYWxsKFAsTSkmJmZ0KEYsTSxQW01dKTtpZigkZSlmb3IodmFyIE0gb2YgJGUoUCkpbm4uY2FsbChQLE0pJiZmdChGLE0sUFtNXSk7cmV0dXJuIEZ9LEJlPShGLFApPT5qcihGLHFyKFApKTt2YXIgdmU9KEYsUCk9Pnt2YXIgTT17fTtmb3IodmFyIFggaW4gRil0bi5jYWxsKEYsWCkmJlAuaW5kZXhPZihYKTwwJiYoTVtYXT1GW1hdKTtpZihGIT1udWxsJiYkZSlmb3IodmFyIFggb2YgJGUoRikpUC5pbmRleE9mKFgpPDAmJm5uLmNhbGwoRixYKSYmKE1bWF09RltYXSk7cmV0dXJuIE19O3ZhciBodD0oRixQLE0pPT5mdChGLHR5cGVvZiBQIT0ic3ltYm9sIj9QKyIiOlAsTSk7dmFyIFE9KEYsUCxNKT0+bmV3IFByb21pc2UoKFgsSWUpPT57dmFyIFVlPXJlPT57dHJ5e29lKE0ubmV4dChyZSkpfWNhdGNoKEVlKXtJZShFZSl9fSxWZT1yZT0+e3RyeXtvZShNLnRocm93KHJlKSl9Y2F0Y2goRWUpe0llKEVlKX19LG9lPXJlPT5yZS5kb25lP1gocmUudmFsdWUpOlByb21pc2UucmVzb2x2ZShyZS52YWx1ZSkudGhlbihVZSxWZSk7b2UoKE09TS5hcHBseShGLFApKS5uZXh0KCkpfSk7KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIEYoZSx0KXtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKG4pe24mJnR5cGVvZiBuIT0ic3RyaW5nIiYmIUFycmF5LmlzQXJyYXkobikmJk9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24oaSl7aWYoaSE9PSJkZWZhdWx0IiYmIShpIGluIGUpKXt2YXIgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4saSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsaSxyLmdldD9yOntlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBuW2ldfX0pfX0pfSksT2JqZWN0LmZyZWV6ZShlKX1jb25zdCBQPUpTT04sTT1lPT5lLnRvVXBwZXJDYXNlKCksWD1lPT57Y29uc3QgdD17fTtyZXR1cm4gZS5mb3JFYWNoKChuLGkpPT57dFtpXT1ufSksdH0sSWU9KGUsdCxuKT0+ZS5kb2N1bWVudD9lOntkb2N1bWVudDplLHZhcmlhYmxlczp0LHJlcXVlc3RIZWFkZXJzOm4sc2lnbmFsOnZvaWQgMH0sVWU9KGUsdCxuKT0+ZS5xdWVyeT9lOntxdWVyeTplLHZhcmlhYmxlczp0LHJlcXVlc3RIZWFkZXJzOm4sc2lnbmFsOnZvaWQgMH0sVmU9KGUsdCk9PmUuZG9jdW1lbnRzP2U6e2RvY3VtZW50czplLHJlcXVlc3RIZWFkZXJzOnQsc2lnbmFsOnZvaWQgMH07ZnVuY3Rpb24gb2UoZSx0KXtpZighISFlKXRocm93IG5ldyBFcnJvcih0KX1mdW5jdGlvbiByZShlKXtyZXR1cm4gdHlwZW9mIGU9PSJvYmplY3QiJiZlIT09bnVsbH1mdW5jdGlvbiBFZShlLHQpe2lmKCEhIWUpdGhyb3cgbmV3IEVycm9yKCJVbmV4cGVjdGVkIGludmFyaWFudCB0cmlnZ2VyZWQuIil9Y29uc3Qgcm49L1xyXG58W1xuXHJdL2c7ZnVuY3Rpb24gamUoZSx0KXtsZXQgbj0wLGk9MTtmb3IoY29uc3QgciBvZiBlLmJvZHkubWF0Y2hBbGwocm4pKXtpZih0eXBlb2Ygci5pbmRleD09Im51bWJlciJ8fEVlKCExKSxyLmluZGV4Pj10KWJyZWFrO249ci5pbmRleCtyWzBdLmxlbmd0aCxpKz0xfXJldHVybntsaW5lOmksY29sdW1uOnQrMS1ufX1mdW5jdGlvbiBzbihlKXtyZXR1cm4gZHQoZS5zb3VyY2UsamUoZS5zb3VyY2UsZS5zdGFydCkpfWZ1bmN0aW9uIGR0KGUsdCl7Y29uc3Qgbj1lLmxvY2F0aW9uT2Zmc2V0LmNvbHVtbi0xLGk9IiIucGFkU3RhcnQobikrZS5ib2R5LHI9dC5saW5lLTEscz1lLmxvY2F0aW9uT2Zmc2V0LmxpbmUtMSxvPXQubGluZStzLGM9dC5saW5lPT09MT9uOjAsZj10LmNvbHVtbitjLGQ9YCR7ZS5uYW1lfToke299OiR7Zn0KYCx1PWkuc3BsaXQoL1xyXG58W1xuXHJdL2cpLHk9dVtyXTtpZih5Lmxlbmd0aD4xMjApe2NvbnN0IHY9TWF0aC5mbG9vcihmLzgwKSxiPWYlODAsbT1bXTtmb3IobGV0IE49MDtOPHkubGVuZ3RoO04rPTgwKW0ucHVzaCh5LnNsaWNlKE4sTis4MCkpO3JldHVybiBkK3B0KFtbYCR7b30gfGAsbVswXV0sLi4ubS5zbGljZSgxLHYrMSkubWFwKE49PlsifCIsTl0pLFsifCIsIl4iLnBhZFN0YXJ0KGIpXSxbInwiLG1bdisxXV1dKX1yZXR1cm4gZCtwdChbW2Ake28tMX0gfGAsdVtyLTFdXSxbYCR7b30gfGAseV0sWyJ8IiwiXiIucGFkU3RhcnQoZildLFtgJHtvKzF9IHxgLHVbcisxXV1dKX1mdW5jdGlvbiBwdChlKXtjb25zdCB0PWUuZmlsdGVyKChbaSxyXSk9PnIhPT12b2lkIDApLG49TWF0aC5tYXgoLi4udC5tYXAoKFtpXSk9PmkubGVuZ3RoKSk7cmV0dXJuIHQubWFwKChbaSxyXSk9PmkucGFkU3RhcnQobikrKHI/IiAiK3I6IiIpKS5qb2luKGAKYCl9ZnVuY3Rpb24gb24oZSl7Y29uc3QgdD1lWzBdO3JldHVybiB0PT1udWxsfHwia2luZCJpbiB0fHwibGVuZ3RoImluIHQ/e25vZGVzOnQsc291cmNlOmVbMV0scG9zaXRpb25zOmVbMl0scGF0aDplWzNdLG9yaWdpbmFsRXJyb3I6ZVs0XSxleHRlbnNpb25zOmVbNV19OnR9Y2xhc3MgcWUgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3Rvcih0LC4uLm4pe3ZhciBpLHIscztjb25zdHtub2RlczpvLHNvdXJjZTpjLHBvc2l0aW9uczpmLHBhdGg6ZCxvcmlnaW5hbEVycm9yOnUsZXh0ZW5zaW9uczp5fT1vbihuKTtzdXBlcih0KSx0aGlzLm5hbWU9IkdyYXBoUUxFcnJvciIsdGhpcy5wYXRoPWQhPW51bGw/ZDp2b2lkIDAsdGhpcy5vcmlnaW5hbEVycm9yPXUhPW51bGw/dTp2b2lkIDAsdGhpcy5ub2Rlcz1tdChBcnJheS5pc0FycmF5KG8pP286bz9bb106dm9pZCAwKTtjb25zdCB2PW10KChpPXRoaXMubm9kZXMpPT09bnVsbHx8aT09PXZvaWQgMD92b2lkIDA6aS5tYXAobT0+bS5sb2MpLmZpbHRlcihtPT5tIT1udWxsKSk7dGhpcy5zb3VyY2U9YyE9bnVsbD9jOnY9PW51bGx8fChyPXZbMF0pPT09bnVsbHx8cj09PXZvaWQgMD92b2lkIDA6ci5zb3VyY2UsdGhpcy5wb3NpdGlvbnM9ZiE9bnVsbD9mOnY9PW51bGw/dm9pZCAwOnYubWFwKG09Pm0uc3RhcnQpLHRoaXMubG9jYXRpb25zPWYmJmM/Zi5tYXAobT0+amUoYyxtKSk6dj09bnVsbD92b2lkIDA6di5tYXAobT0+amUobS5zb3VyY2UsbS5zdGFydCkpO2NvbnN0IGI9cmUodT09bnVsbD92b2lkIDA6dS5leHRlbnNpb25zKT91PT1udWxsP3ZvaWQgMDp1LmV4dGVuc2lvbnM6dm9pZCAwO3RoaXMuZXh0ZW5zaW9ucz0ocz15IT1udWxsP3k6YikhPT1udWxsJiZzIT09dm9pZCAwP3M6T2JqZWN0LmNyZWF0ZShudWxsKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLHttZXNzYWdlOnt3cml0YWJsZTohMCxlbnVtZXJhYmxlOiEwfSxuYW1lOntlbnVtZXJhYmxlOiExfSxub2Rlczp7ZW51bWVyYWJsZTohMX0sc291cmNlOntlbnVtZXJhYmxlOiExfSxwb3NpdGlvbnM6e2VudW1lcmFibGU6ITF9LG9yaWdpbmFsRXJyb3I6e2VudW1lcmFibGU6ITF9fSksdSE9bnVsbCYmdS5zdGFjaz9PYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3RhY2siLHt2YWx1ZTp1LnN0YWNrLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pOkVycm9yLmNhcHR1cmVTdGFja1RyYWNlP0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMscWUpOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzdGFjayIse3ZhbHVlOkVycm9yKCkuc3RhY2ssd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSl9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm4iR3JhcGhRTEVycm9yIn10b1N0cmluZygpe2xldCB0PXRoaXMubWVzc2FnZTtpZih0aGlzLm5vZGVzKWZvcihjb25zdCBuIG9mIHRoaXMubm9kZXMpbi5sb2MmJih0Kz1gCgpgK3NuKG4ubG9jKSk7ZWxzZSBpZih0aGlzLnNvdXJjZSYmdGhpcy5sb2NhdGlvbnMpZm9yKGNvbnN0IG4gb2YgdGhpcy5sb2NhdGlvbnMpdCs9YAoKYCtkdCh0aGlzLnNvdXJjZSxuKTtyZXR1cm4gdH10b0pTT04oKXtjb25zdCB0PXttZXNzYWdlOnRoaXMubWVzc2FnZX07cmV0dXJuIHRoaXMubG9jYXRpb25zIT1udWxsJiYodC5sb2NhdGlvbnM9dGhpcy5sb2NhdGlvbnMpLHRoaXMucGF0aCE9bnVsbCYmKHQucGF0aD10aGlzLnBhdGgpLHRoaXMuZXh0ZW5zaW9ucyE9bnVsbCYmT2JqZWN0LmtleXModGhpcy5leHRlbnNpb25zKS5sZW5ndGg+MCYmKHQuZXh0ZW5zaW9ucz10aGlzLmV4dGVuc2lvbnMpLHR9fWZ1bmN0aW9uIG10KGUpe3JldHVybiBlPT09dm9pZCAwfHxlLmxlbmd0aD09PTA/dm9pZCAwOmV9ZnVuY3Rpb24gRyhlLHQsbil7cmV0dXJuIG5ldyBxZShgU3ludGF4IEVycm9yOiAke259YCx7c291cmNlOmUscG9zaXRpb25zOlt0XX0pfWNsYXNzIGFue2NvbnN0cnVjdG9yKHQsbixpKXt0aGlzLnN0YXJ0PXQuc3RhcnQsdGhpcy5lbmQ9bi5lbmQsdGhpcy5zdGFydFRva2VuPXQsdGhpcy5lbmRUb2tlbj1uLHRoaXMuc291cmNlPWl9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm4iTG9jYXRpb24ifXRvSlNPTigpe3JldHVybntzdGFydDp0aGlzLnN0YXJ0LGVuZDp0aGlzLmVuZH19fWNsYXNzIHl0e2NvbnN0cnVjdG9yKHQsbixpLHIscyxvKXt0aGlzLmtpbmQ9dCx0aGlzLnN0YXJ0PW4sdGhpcy5lbmQ9aSx0aGlzLmxpbmU9cix0aGlzLmNvbHVtbj1zLHRoaXMudmFsdWU9byx0aGlzLnByZXY9bnVsbCx0aGlzLm5leHQ9bnVsbH1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVybiJUb2tlbiJ9dG9KU09OKCl7cmV0dXJue2tpbmQ6dGhpcy5raW5kLHZhbHVlOnRoaXMudmFsdWUsbGluZTp0aGlzLmxpbmUsY29sdW1uOnRoaXMuY29sdW1ufX19Y29uc3QgZ3Q9e05hbWU6W10sRG9jdW1lbnQ6WyJkZWZpbml0aW9ucyJdLE9wZXJhdGlvbkRlZmluaXRpb246WyJuYW1lIiwidmFyaWFibGVEZWZpbml0aW9ucyIsImRpcmVjdGl2ZXMiLCJzZWxlY3Rpb25TZXQiXSxWYXJpYWJsZURlZmluaXRpb246WyJ2YXJpYWJsZSIsInR5cGUiLCJkZWZhdWx0VmFsdWUiLCJkaXJlY3RpdmVzIl0sVmFyaWFibGU6WyJuYW1lIl0sU2VsZWN0aW9uU2V0Olsic2VsZWN0aW9ucyJdLEZpZWxkOlsiYWxpYXMiLCJuYW1lIiwiYXJndW1lbnRzIiwiZGlyZWN0aXZlcyIsInNlbGVjdGlvblNldCJdLEFyZ3VtZW50OlsibmFtZSIsInZhbHVlIl0sRnJhZ21lbnRTcHJlYWQ6WyJuYW1lIiwiZGlyZWN0aXZlcyJdLElubGluZUZyYWdtZW50OlsidHlwZUNvbmRpdGlvbiIsImRpcmVjdGl2ZXMiLCJzZWxlY3Rpb25TZXQiXSxGcmFnbWVudERlZmluaXRpb246WyJuYW1lIiwidmFyaWFibGVEZWZpbml0aW9ucyIsInR5cGVDb25kaXRpb24iLCJkaXJlY3RpdmVzIiwic2VsZWN0aW9uU2V0Il0sSW50VmFsdWU6W10sRmxvYXRWYWx1ZTpbXSxTdHJpbmdWYWx1ZTpbXSxCb29sZWFuVmFsdWU6W10sTnVsbFZhbHVlOltdLEVudW1WYWx1ZTpbXSxMaXN0VmFsdWU6WyJ2YWx1ZXMiXSxPYmplY3RWYWx1ZTpbImZpZWxkcyJdLE9iamVjdEZpZWxkOlsibmFtZSIsInZhbHVlIl0sRGlyZWN0aXZlOlsibmFtZSIsImFyZ3VtZW50cyJdLE5hbWVkVHlwZTpbIm5hbWUiXSxMaXN0VHlwZTpbInR5cGUiXSxOb25OdWxsVHlwZTpbInR5cGUiXSxTY2hlbWFEZWZpbml0aW9uOlsiZGVzY3JpcHRpb24iLCJkaXJlY3RpdmVzIiwib3BlcmF0aW9uVHlwZXMiXSxPcGVyYXRpb25UeXBlRGVmaW5pdGlvbjpbInR5cGUiXSxTY2FsYXJUeXBlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsImRpcmVjdGl2ZXMiXSxPYmplY3RUeXBlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsImludGVyZmFjZXMiLCJkaXJlY3RpdmVzIiwiZmllbGRzIl0sRmllbGREZWZpbml0aW9uOlsiZGVzY3JpcHRpb24iLCJuYW1lIiwiYXJndW1lbnRzIiwidHlwZSIsImRpcmVjdGl2ZXMiXSxJbnB1dFZhbHVlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsInR5cGUiLCJkZWZhdWx0VmFsdWUiLCJkaXJlY3RpdmVzIl0sSW50ZXJmYWNlVHlwZURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJpbnRlcmZhY2VzIiwiZGlyZWN0aXZlcyIsImZpZWxkcyJdLFVuaW9uVHlwZURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJkaXJlY3RpdmVzIiwidHlwZXMiXSxFbnVtVHlwZURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJkaXJlY3RpdmVzIiwidmFsdWVzIl0sRW51bVZhbHVlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsImRpcmVjdGl2ZXMiXSxJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uOlsiZGVzY3JpcHRpb24iLCJuYW1lIiwiZGlyZWN0aXZlcyIsImZpZWxkcyJdLERpcmVjdGl2ZURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJhcmd1bWVudHMiLCJsb2NhdGlvbnMiXSxTY2hlbWFFeHRlbnNpb246WyJkaXJlY3RpdmVzIiwib3BlcmF0aW9uVHlwZXMiXSxTY2FsYXJUeXBlRXh0ZW5zaW9uOlsibmFtZSIsImRpcmVjdGl2ZXMiXSxPYmplY3RUeXBlRXh0ZW5zaW9uOlsibmFtZSIsImludGVyZmFjZXMiLCJkaXJlY3RpdmVzIiwiZmllbGRzIl0sSW50ZXJmYWNlVHlwZUV4dGVuc2lvbjpbIm5hbWUiLCJpbnRlcmZhY2VzIiwiZGlyZWN0aXZlcyIsImZpZWxkcyJdLFVuaW9uVHlwZUV4dGVuc2lvbjpbIm5hbWUiLCJkaXJlY3RpdmVzIiwidHlwZXMiXSxFbnVtVHlwZUV4dGVuc2lvbjpbIm5hbWUiLCJkaXJlY3RpdmVzIiwidmFsdWVzIl0sSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uOlsibmFtZSIsImRpcmVjdGl2ZXMiLCJmaWVsZHMiXX0sY249bmV3IFNldChPYmplY3Qua2V5cyhndCkpO2Z1bmN0aW9uIHZ0KGUpe2NvbnN0IHQ9ZT09bnVsbD92b2lkIDA6ZS5raW5kO3JldHVybiB0eXBlb2YgdD09InN0cmluZyImJmNuLmhhcyh0KX12YXIgZmU7KGZ1bmN0aW9uKGUpe2UuUVVFUlk9InF1ZXJ5IixlLk1VVEFUSU9OPSJtdXRhdGlvbiIsZS5TVUJTQ1JJUFRJT049InN1YnNjcmlwdGlvbiJ9KShmZXx8KGZlPXt9KSk7dmFyIEdlOyhmdW5jdGlvbihlKXtlLlFVRVJZPSJRVUVSWSIsZS5NVVRBVElPTj0iTVVUQVRJT04iLGUuU1VCU0NSSVBUSU9OPSJTVUJTQ1JJUFRJT04iLGUuRklFTEQ9IkZJRUxEIixlLkZSQUdNRU5UX0RFRklOSVRJT049IkZSQUdNRU5UX0RFRklOSVRJT04iLGUuRlJBR01FTlRfU1BSRUFEPSJGUkFHTUVOVF9TUFJFQUQiLGUuSU5MSU5FX0ZSQUdNRU5UPSJJTkxJTkVfRlJBR01FTlQiLGUuVkFSSUFCTEVfREVGSU5JVElPTj0iVkFSSUFCTEVfREVGSU5JVElPTiIsZS5TQ0hFTUE9IlNDSEVNQSIsZS5TQ0FMQVI9IlNDQUxBUiIsZS5PQkpFQ1Q9Ik9CSkVDVCIsZS5GSUVMRF9ERUZJTklUSU9OPSJGSUVMRF9ERUZJTklUSU9OIixlLkFSR1VNRU5UX0RFRklOSVRJT049IkFSR1VNRU5UX0RFRklOSVRJT04iLGUuSU5URVJGQUNFPSJJTlRFUkZBQ0UiLGUuVU5JT049IlVOSU9OIixlLkVOVU09IkVOVU0iLGUuRU5VTV9WQUxVRT0iRU5VTV9WQUxVRSIsZS5JTlBVVF9PQkpFQ1Q9IklOUFVUX09CSkVDVCIsZS5JTlBVVF9GSUVMRF9ERUZJTklUSU9OPSJJTlBVVF9GSUVMRF9ERUZJTklUSU9OIn0pKEdlfHwoR2U9e30pKTt2YXIgVDsoZnVuY3Rpb24oZSl7ZS5OQU1FPSJOYW1lIixlLkRPQ1VNRU5UPSJEb2N1bWVudCIsZS5PUEVSQVRJT05fREVGSU5JVElPTj0iT3BlcmF0aW9uRGVmaW5pdGlvbiIsZS5WQVJJQUJMRV9ERUZJTklUSU9OPSJWYXJpYWJsZURlZmluaXRpb24iLGUuU0VMRUNUSU9OX1NFVD0iU2VsZWN0aW9uU2V0IixlLkZJRUxEPSJGaWVsZCIsZS5BUkdVTUVOVD0iQXJndW1lbnQiLGUuRlJBR01FTlRfU1BSRUFEPSJGcmFnbWVudFNwcmVhZCIsZS5JTkxJTkVfRlJBR01FTlQ9IklubGluZUZyYWdtZW50IixlLkZSQUdNRU5UX0RFRklOSVRJT049IkZyYWdtZW50RGVmaW5pdGlvbiIsZS5WQVJJQUJMRT0iVmFyaWFibGUiLGUuSU5UPSJJbnRWYWx1ZSIsZS5GTE9BVD0iRmxvYXRWYWx1ZSIsZS5TVFJJTkc9IlN0cmluZ1ZhbHVlIixlLkJPT0xFQU49IkJvb2xlYW5WYWx1ZSIsZS5OVUxMPSJOdWxsVmFsdWUiLGUuRU5VTT0iRW51bVZhbHVlIixlLkxJU1Q9Ikxpc3RWYWx1ZSIsZS5PQkpFQ1Q9Ik9iamVjdFZhbHVlIixlLk9CSkVDVF9GSUVMRD0iT2JqZWN0RmllbGQiLGUuRElSRUNUSVZFPSJEaXJlY3RpdmUiLGUuTkFNRURfVFlQRT0iTmFtZWRUeXBlIixlLkxJU1RfVFlQRT0iTGlzdFR5cGUiLGUuTk9OX05VTExfVFlQRT0iTm9uTnVsbFR5cGUiLGUuU0NIRU1BX0RFRklOSVRJT049IlNjaGVtYURlZmluaXRpb24iLGUuT1BFUkFUSU9OX1RZUEVfREVGSU5JVElPTj0iT3BlcmF0aW9uVHlwZURlZmluaXRpb24iLGUuU0NBTEFSX1RZUEVfREVGSU5JVElPTj0iU2NhbGFyVHlwZURlZmluaXRpb24iLGUuT0JKRUNUX1RZUEVfREVGSU5JVElPTj0iT2JqZWN0VHlwZURlZmluaXRpb24iLGUuRklFTERfREVGSU5JVElPTj0iRmllbGREZWZpbml0aW9uIixlLklOUFVUX1ZBTFVFX0RFRklOSVRJT049IklucHV0VmFsdWVEZWZpbml0aW9uIixlLklOVEVSRkFDRV9UWVBFX0RFRklOSVRJT049IkludGVyZmFjZVR5cGVEZWZpbml0aW9uIixlLlVOSU9OX1RZUEVfREVGSU5JVElPTj0iVW5pb25UeXBlRGVmaW5pdGlvbiIsZS5FTlVNX1RZUEVfREVGSU5JVElPTj0iRW51bVR5cGVEZWZpbml0aW9uIixlLkVOVU1fVkFMVUVfREVGSU5JVElPTj0iRW51bVZhbHVlRGVmaW5pdGlvbiIsZS5JTlBVVF9PQkpFQ1RfVFlQRV9ERUZJTklUSU9OPSJJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uIixlLkRJUkVDVElWRV9ERUZJTklUSU9OPSJEaXJlY3RpdmVEZWZpbml0aW9uIixlLlNDSEVNQV9FWFRFTlNJT049IlNjaGVtYUV4dGVuc2lvbiIsZS5TQ0FMQVJfVFlQRV9FWFRFTlNJT049IlNjYWxhclR5cGVFeHRlbnNpb24iLGUuT0JKRUNUX1RZUEVfRVhURU5TSU9OPSJPYmplY3RUeXBlRXh0ZW5zaW9uIixlLklOVEVSRkFDRV9UWVBFX0VYVEVOU0lPTj0iSW50ZXJmYWNlVHlwZUV4dGVuc2lvbiIsZS5VTklPTl9UWVBFX0VYVEVOU0lPTj0iVW5pb25UeXBlRXh0ZW5zaW9uIixlLkVOVU1fVFlQRV9FWFRFTlNJT049IkVudW1UeXBlRXh0ZW5zaW9uIixlLklOUFVUX09CSkVDVF9UWVBFX0VYVEVOU0lPTj0iSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uIn0pKFR8fChUPXt9KSk7ZnVuY3Rpb24gemUoZSl7cmV0dXJuIGU9PT05fHxlPT09MzJ9ZnVuY3Rpb24gX2UoZSl7cmV0dXJuIGU+PTQ4JiZlPD01N31mdW5jdGlvbiBFdChlKXtyZXR1cm4gZT49OTcmJmU8PTEyMnx8ZT49NjUmJmU8PTkwfWZ1bmN0aW9uIF90KGUpe3JldHVybiBFdChlKXx8ZT09PTk1fWZ1bmN0aW9uIHVuKGUpe3JldHVybiBFdChlKXx8X2UoZSl8fGU9PT05NX1mdW5jdGlvbiBsbihlKXt2YXIgdDtsZXQgbj1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUixpPW51bGwscj0tMTtmb3IobGV0IG89MDtvPGUubGVuZ3RoOysrbyl7dmFyIHM7Y29uc3QgYz1lW29dLGY9Zm4oYyk7ZiE9PWMubGVuZ3RoJiYoaT0ocz1pKSE9PW51bGwmJnMhPT12b2lkIDA/czpvLHI9byxvIT09MCYmZjxuJiYobj1mKSl9cmV0dXJuIGUubWFwKChvLGMpPT5jPT09MD9vOm8uc2xpY2UobikpLnNsaWNlKCh0PWkpIT09bnVsbCYmdCE9PXZvaWQgMD90OjAscisxKX1mdW5jdGlvbiBmbihlKXtsZXQgdD0wO2Zvcig7dDxlLmxlbmd0aCYmemUoZS5jaGFyQ29kZUF0KHQpKTspKyt0O3JldHVybiB0fWZ1bmN0aW9uIGhuKGUsdCl7Y29uc3Qgbj1lLnJlcGxhY2UoLyIiIi9nLCdcXCIiIicpLGk9bi5zcGxpdCgvXHJcbnxbXG5ccl0vZykscj1pLmxlbmd0aD09PTEscz1pLmxlbmd0aD4xJiZpLnNsaWNlKDEpLmV2ZXJ5KGI9PmIubGVuZ3RoPT09MHx8emUoYi5jaGFyQ29kZUF0KDApKSksbz1uLmVuZHNXaXRoKCdcXCIiIicpLGM9ZS5lbmRzV2l0aCgnIicpJiYhbyxmPWUuZW5kc1dpdGgoIlxcIiksZD1jfHxmLHU9IXJ8fGUubGVuZ3RoPjcwfHxkfHxzfHxvO2xldCB5PSIiO2NvbnN0IHY9ciYmemUoZS5jaGFyQ29kZUF0KDApKTtyZXR1cm4odSYmIXZ8fHMpJiYoeSs9YApgKSx5Kz1uLCh1fHxkKSYmKHkrPWAKYCksJyIiIicreSsnIiIiJ312YXIgbDsoZnVuY3Rpb24oZSl7ZS5TT0Y9IjxTT0Y+IixlLkVPRj0iPEVPRj4iLGUuQkFORz0iISIsZS5ET0xMQVI9IiQiLGUuQU1QPSImIixlLlBBUkVOX0w9IigiLGUuUEFSRU5fUj0iKSIsZS5TUFJFQUQ9Ii4uLiIsZS5DT0xPTj0iOiIsZS5FUVVBTFM9Ij0iLGUuQVQ9IkAiLGUuQlJBQ0tFVF9MPSJbIixlLkJSQUNLRVRfUj0iXSIsZS5CUkFDRV9MPSJ7IixlLlBJUEU9InwiLGUuQlJBQ0VfUj0ifSIsZS5OQU1FPSJOYW1lIixlLklOVD0iSW50IixlLkZMT0FUPSJGbG9hdCIsZS5TVFJJTkc9IlN0cmluZyIsZS5CTE9DS19TVFJJTkc9IkJsb2NrU3RyaW5nIixlLkNPTU1FTlQ9IkNvbW1lbnQifSkobHx8KGw9e30pKTtjbGFzcyBkbntjb25zdHJ1Y3Rvcih0KXtjb25zdCBuPW5ldyB5dChsLlNPRiwwLDAsMCwwKTt0aGlzLnNvdXJjZT10LHRoaXMubGFzdFRva2VuPW4sdGhpcy50b2tlbj1uLHRoaXMubGluZT0xLHRoaXMubGluZVN0YXJ0PTB9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm4iTGV4ZXIifWFkdmFuY2UoKXtyZXR1cm4gdGhpcy5sYXN0VG9rZW49dGhpcy50b2tlbix0aGlzLnRva2VuPXRoaXMubG9va2FoZWFkKCl9bG9va2FoZWFkKCl7bGV0IHQ9dGhpcy50b2tlbjtpZih0LmtpbmQhPT1sLkVPRilkbyBpZih0Lm5leHQpdD10Lm5leHQ7ZWxzZXtjb25zdCBuPW1uKHRoaXMsdC5lbmQpO3QubmV4dD1uLG4ucHJldj10LHQ9bn13aGlsZSh0LmtpbmQ9PT1sLkNPTU1FTlQpO3JldHVybiB0fX1mdW5jdGlvbiBwbihlKXtyZXR1cm4gZT09PWwuQkFOR3x8ZT09PWwuRE9MTEFSfHxlPT09bC5BTVB8fGU9PT1sLlBBUkVOX0x8fGU9PT1sLlBBUkVOX1J8fGU9PT1sLlNQUkVBRHx8ZT09PWwuQ09MT058fGU9PT1sLkVRVUFMU3x8ZT09PWwuQVR8fGU9PT1sLkJSQUNLRVRfTHx8ZT09PWwuQlJBQ0tFVF9SfHxlPT09bC5CUkFDRV9MfHxlPT09bC5QSVBFfHxlPT09bC5CUkFDRV9SfWZ1bmN0aW9uIGhlKGUpe3JldHVybiBlPj0wJiZlPD01NTI5NXx8ZT49NTczNDQmJmU8PTExMTQxMTF9ZnVuY3Rpb24gU2UoZSx0KXtyZXR1cm4gVHQoZS5jaGFyQ29kZUF0KHQpKSYmYnQoZS5jaGFyQ29kZUF0KHQrMSkpfWZ1bmN0aW9uIFR0KGUpe3JldHVybiBlPj01NTI5NiYmZTw9NTYzMTl9ZnVuY3Rpb24gYnQoZSl7cmV0dXJuIGU+PTU2MzIwJiZlPD01NzM0M31mdW5jdGlvbiB1ZShlLHQpe2NvbnN0IG49ZS5zb3VyY2UuYm9keS5jb2RlUG9pbnRBdCh0KTtpZihuPT09dm9pZCAwKXJldHVybiBsLkVPRjtpZihuPj0zMiYmbjw9MTI2KXtjb25zdCBpPVN0cmluZy5mcm9tQ29kZVBvaW50KG4pO3JldHVybiBpPT09JyInP2AnIidgOmAiJHtpfSJgfXJldHVybiJVKyIrbi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCg0LCIwIil9ZnVuY3Rpb24gVihlLHQsbixpLHIpe2NvbnN0IHM9ZS5saW5lLG89MStuLWUubGluZVN0YXJ0O3JldHVybiBuZXcgeXQodCxuLGkscyxvLHIpfWZ1bmN0aW9uIG1uKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9bi5sZW5ndGg7bGV0IHI9dDtmb3IoO3I8aTspe2NvbnN0IHM9bi5jaGFyQ29kZUF0KHIpO3N3aXRjaChzKXtjYXNlIDY1Mjc5OmNhc2UgOTpjYXNlIDMyOmNhc2UgNDQ6KytyO2NvbnRpbnVlO2Nhc2UgMTA6KytyLCsrZS5saW5lLGUubGluZVN0YXJ0PXI7Y29udGludWU7Y2FzZSAxMzpuLmNoYXJDb2RlQXQocisxKT09PTEwP3IrPTI6KytyLCsrZS5saW5lLGUubGluZVN0YXJ0PXI7Y29udGludWU7Y2FzZSAzNTpyZXR1cm4geW4oZSxyKTtjYXNlIDMzOnJldHVybiBWKGUsbC5CQU5HLHIscisxKTtjYXNlIDM2OnJldHVybiBWKGUsbC5ET0xMQVIscixyKzEpO2Nhc2UgMzg6cmV0dXJuIFYoZSxsLkFNUCxyLHIrMSk7Y2FzZSA0MDpyZXR1cm4gVihlLGwuUEFSRU5fTCxyLHIrMSk7Y2FzZSA0MTpyZXR1cm4gVihlLGwuUEFSRU5fUixyLHIrMSk7Y2FzZSA0NjppZihuLmNoYXJDb2RlQXQocisxKT09PTQ2JiZuLmNoYXJDb2RlQXQocisyKT09PTQ2KXJldHVybiBWKGUsbC5TUFJFQUQscixyKzMpO2JyZWFrO2Nhc2UgNTg6cmV0dXJuIFYoZSxsLkNPTE9OLHIscisxKTtjYXNlIDYxOnJldHVybiBWKGUsbC5FUVVBTFMscixyKzEpO2Nhc2UgNjQ6cmV0dXJuIFYoZSxsLkFULHIscisxKTtjYXNlIDkxOnJldHVybiBWKGUsbC5CUkFDS0VUX0wscixyKzEpO2Nhc2UgOTM6cmV0dXJuIFYoZSxsLkJSQUNLRVRfUixyLHIrMSk7Y2FzZSAxMjM6cmV0dXJuIFYoZSxsLkJSQUNFX0wscixyKzEpO2Nhc2UgMTI0OnJldHVybiBWKGUsbC5QSVBFLHIscisxKTtjYXNlIDEyNTpyZXR1cm4gVihlLGwuQlJBQ0VfUixyLHIrMSk7Y2FzZSAzNDpyZXR1cm4gbi5jaGFyQ29kZUF0KHIrMSk9PT0zNCYmbi5jaGFyQ29kZUF0KHIrMik9PT0zND9ibihlLHIpOnZuKGUscil9aWYoX2Uocyl8fHM9PT00NSlyZXR1cm4gZ24oZSxyLHMpO2lmKF90KHMpKXJldHVybiBObihlLHIpO3Rocm93IEcoZS5zb3VyY2UscixzPT09Mzk/YFVuZXhwZWN0ZWQgc2luZ2xlIHF1b3RlIGNoYXJhY3RlciAoJyksIGRpZCB5b3UgbWVhbiB0byB1c2UgYSBkb3VibGUgcXVvdGUgKCIpP2A6aGUocyl8fFNlKG4scik/YFVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAke3VlKGUscil9LmA6YEludmFsaWQgY2hhcmFjdGVyOiAke3VlKGUscil9LmApfXJldHVybiBWKGUsbC5FT0YsaSxpKX1mdW5jdGlvbiB5bihlLHQpe2NvbnN0IG49ZS5zb3VyY2UuYm9keSxpPW4ubGVuZ3RoO2xldCByPXQrMTtmb3IoO3I8aTspe2NvbnN0IHM9bi5jaGFyQ29kZUF0KHIpO2lmKHM9PT0xMHx8cz09PTEzKWJyZWFrO2lmKGhlKHMpKSsrcjtlbHNlIGlmKFNlKG4scikpcis9MjtlbHNlIGJyZWFrfXJldHVybiBWKGUsbC5DT01NRU5ULHQscixuLnNsaWNlKHQrMSxyKSl9ZnVuY3Rpb24gZ24oZSx0LG4pe2NvbnN0IGk9ZS5zb3VyY2UuYm9keTtsZXQgcj10LHM9bixvPSExO2lmKHM9PT00NSYmKHM9aS5jaGFyQ29kZUF0KCsrcikpLHM9PT00OCl7aWYocz1pLmNoYXJDb2RlQXQoKytyKSxfZShzKSl0aHJvdyBHKGUuc291cmNlLHIsYEludmFsaWQgbnVtYmVyLCB1bmV4cGVjdGVkIGRpZ2l0IGFmdGVyIDA6ICR7dWUoZSxyKX0uYCl9ZWxzZSByPUhlKGUscixzKSxzPWkuY2hhckNvZGVBdChyKTtpZihzPT09NDYmJihvPSEwLHM9aS5jaGFyQ29kZUF0KCsrcikscj1IZShlLHIscykscz1pLmNoYXJDb2RlQXQocikpLChzPT09Njl8fHM9PT0xMDEpJiYobz0hMCxzPWkuY2hhckNvZGVBdCgrK3IpLChzPT09NDN8fHM9PT00NSkmJihzPWkuY2hhckNvZGVBdCgrK3IpKSxyPUhlKGUscixzKSxzPWkuY2hhckNvZGVBdChyKSkscz09PTQ2fHxfdChzKSl0aHJvdyBHKGUuc291cmNlLHIsYEludmFsaWQgbnVtYmVyLCBleHBlY3RlZCBkaWdpdCBidXQgZ290OiAke3VlKGUscil9LmApO3JldHVybiBWKGUsbz9sLkZMT0FUOmwuSU5ULHQscixpLnNsaWNlKHQscikpfWZ1bmN0aW9uIEhlKGUsdCxuKXtpZighX2UobikpdGhyb3cgRyhlLnNvdXJjZSx0LGBJbnZhbGlkIG51bWJlciwgZXhwZWN0ZWQgZGlnaXQgYnV0IGdvdDogJHt1ZShlLHQpfS5gKTtjb25zdCBpPWUuc291cmNlLmJvZHk7bGV0IHI9dCsxO2Zvcig7X2UoaS5jaGFyQ29kZUF0KHIpKTspKytyO3JldHVybiByfWZ1bmN0aW9uIHZuKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9bi5sZW5ndGg7bGV0IHI9dCsxLHM9cixvPSIiO2Zvcig7cjxpOyl7Y29uc3QgYz1uLmNoYXJDb2RlQXQocik7aWYoYz09PTM0KXJldHVybiBvKz1uLnNsaWNlKHMsciksVihlLGwuU1RSSU5HLHQscisxLG8pO2lmKGM9PT05Mil7bys9bi5zbGljZShzLHIpO2NvbnN0IGY9bi5jaGFyQ29kZUF0KHIrMSk9PT0xMTc/bi5jaGFyQ29kZUF0KHIrMik9PT0xMjM/RW4oZSxyKTpfbihlLHIpOlRuKGUscik7bys9Zi52YWx1ZSxyKz1mLnNpemUscz1yO2NvbnRpbnVlfWlmKGM9PT0xMHx8Yz09PTEzKWJyZWFrO2lmKGhlKGMpKSsrcjtlbHNlIGlmKFNlKG4scikpcis9MjtlbHNlIHRocm93IEcoZS5zb3VyY2UscixgSW52YWxpZCBjaGFyYWN0ZXIgd2l0aGluIFN0cmluZzogJHt1ZShlLHIpfS5gKX10aHJvdyBHKGUuc291cmNlLHIsIlVudGVybWluYXRlZCBzdHJpbmcuIil9ZnVuY3Rpb24gRW4oZSx0KXtjb25zdCBuPWUuc291cmNlLmJvZHk7bGV0IGk9MCxyPTM7Zm9yKDtyPDEyOyl7Y29uc3Qgcz1uLmNoYXJDb2RlQXQodCtyKyspO2lmKHM9PT0xMjUpe2lmKHI8NXx8IWhlKGkpKWJyZWFrO3JldHVybnt2YWx1ZTpTdHJpbmcuZnJvbUNvZGVQb2ludChpKSxzaXplOnJ9fWlmKGk9aTw8NHxUZShzKSxpPDApYnJlYWt9dGhyb3cgRyhlLnNvdXJjZSx0LGBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlOiAiJHtuLnNsaWNlKHQsdCtyKX0iLmApfWZ1bmN0aW9uIF9uKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9TnQobix0KzIpO2lmKGhlKGkpKXJldHVybnt2YWx1ZTpTdHJpbmcuZnJvbUNvZGVQb2ludChpKSxzaXplOjZ9O2lmKFR0KGkpJiZuLmNoYXJDb2RlQXQodCs2KT09PTkyJiZuLmNoYXJDb2RlQXQodCs3KT09PTExNyl7Y29uc3Qgcj1OdChuLHQrOCk7aWYoYnQocikpcmV0dXJue3ZhbHVlOlN0cmluZy5mcm9tQ29kZVBvaW50KGksciksc2l6ZToxMn19dGhyb3cgRyhlLnNvdXJjZSx0LGBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlOiAiJHtuLnNsaWNlKHQsdCs2KX0iLmApfWZ1bmN0aW9uIE50KGUsdCl7cmV0dXJuIFRlKGUuY2hhckNvZGVBdCh0KSk8PDEyfFRlKGUuY2hhckNvZGVBdCh0KzEpKTw8OHxUZShlLmNoYXJDb2RlQXQodCsyKSk8PDR8VGUoZS5jaGFyQ29kZUF0KHQrMykpfWZ1bmN0aW9uIFRlKGUpe3JldHVybiBlPj00OCYmZTw9NTc/ZS00ODplPj02NSYmZTw9NzA/ZS01NTplPj05NyYmZTw9MTAyP2UtODc6LTF9ZnVuY3Rpb24gVG4oZSx0KXtjb25zdCBuPWUuc291cmNlLmJvZHk7c3dpdGNoKG4uY2hhckNvZGVBdCh0KzEpKXtjYXNlIDM0OnJldHVybnt2YWx1ZTonIicsc2l6ZToyfTtjYXNlIDkyOnJldHVybnt2YWx1ZToiXFwiLHNpemU6Mn07Y2FzZSA0NzpyZXR1cm57dmFsdWU6Ii8iLHNpemU6Mn07Y2FzZSA5ODpyZXR1cm57dmFsdWU6IlxiIixzaXplOjJ9O2Nhc2UgMTAyOnJldHVybnt2YWx1ZToiXGYiLHNpemU6Mn07Y2FzZSAxMTA6cmV0dXJue3ZhbHVlOmAKYCxzaXplOjJ9O2Nhc2UgMTE0OnJldHVybnt2YWx1ZToiXHIiLHNpemU6Mn07Y2FzZSAxMTY6cmV0dXJue3ZhbHVlOiIJIixzaXplOjJ9fXRocm93IEcoZS5zb3VyY2UsdCxgSW52YWxpZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlOiAiJHtuLnNsaWNlKHQsdCsyKX0iLmApfWZ1bmN0aW9uIGJuKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9bi5sZW5ndGg7bGV0IHI9ZS5saW5lU3RhcnQscz10KzMsbz1zLGM9IiI7Y29uc3QgZj1bXTtmb3IoO3M8aTspe2NvbnN0IGQ9bi5jaGFyQ29kZUF0KHMpO2lmKGQ9PT0zNCYmbi5jaGFyQ29kZUF0KHMrMSk9PT0zNCYmbi5jaGFyQ29kZUF0KHMrMik9PT0zNCl7Yys9bi5zbGljZShvLHMpLGYucHVzaChjKTtjb25zdCB1PVYoZSxsLkJMT0NLX1NUUklORyx0LHMrMyxsbihmKS5qb2luKGAKYCkpO3JldHVybiBlLmxpbmUrPWYubGVuZ3RoLTEsZS5saW5lU3RhcnQ9cix1fWlmKGQ9PT05MiYmbi5jaGFyQ29kZUF0KHMrMSk9PT0zNCYmbi5jaGFyQ29kZUF0KHMrMik9PT0zNCYmbi5jaGFyQ29kZUF0KHMrMyk9PT0zNCl7Yys9bi5zbGljZShvLHMpLG89cysxLHMrPTQ7Y29udGludWV9aWYoZD09PTEwfHxkPT09MTMpe2MrPW4uc2xpY2UobyxzKSxmLnB1c2goYyksZD09PTEzJiZuLmNoYXJDb2RlQXQocysxKT09PTEwP3MrPTI6KytzLGM9IiIsbz1zLHI9cztjb250aW51ZX1pZihoZShkKSkrK3M7ZWxzZSBpZihTZShuLHMpKXMrPTI7ZWxzZSB0aHJvdyBHKGUuc291cmNlLHMsYEludmFsaWQgY2hhcmFjdGVyIHdpdGhpbiBTdHJpbmc6ICR7dWUoZSxzKX0uYCl9dGhyb3cgRyhlLnNvdXJjZSxzLCJVbnRlcm1pbmF0ZWQgc3RyaW5nLiIpfWZ1bmN0aW9uIE5uKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9bi5sZW5ndGg7bGV0IHI9dCsxO2Zvcig7cjxpOyl7Y29uc3Qgcz1uLmNoYXJDb2RlQXQocik7aWYodW4ocykpKytyO2Vsc2UgYnJlYWt9cmV0dXJuIFYoZSxsLk5BTUUsdCxyLG4uc2xpY2UodCxyKSl9Y29uc3QgeG49MTAseHQ9MjtmdW5jdGlvbiBZZShlKXtyZXR1cm4gT2UoZSxbXSl9ZnVuY3Rpb24gT2UoZSx0KXtzd2l0Y2godHlwZW9mIGUpe2Nhc2Uic3RyaW5nIjpyZXR1cm4gSlNPTi5zdHJpbmdpZnkoZSk7Y2FzZSJmdW5jdGlvbiI6cmV0dXJuIGUubmFtZT9gW2Z1bmN0aW9uICR7ZS5uYW1lfV1gOiJbZnVuY3Rpb25dIjtjYXNlIm9iamVjdCI6cmV0dXJuIEFuKGUsdCk7ZGVmYXVsdDpyZXR1cm4gU3RyaW5nKGUpfX1mdW5jdGlvbiBBbihlLHQpe2lmKGU9PT1udWxsKXJldHVybiJudWxsIjtpZih0LmluY2x1ZGVzKGUpKXJldHVybiJbQ2lyY3VsYXJdIjtjb25zdCBuPVsuLi50LGVdO2lmKEluKGUpKXtjb25zdCBpPWUudG9KU09OKCk7aWYoaSE9PWUpcmV0dXJuIHR5cGVvZiBpPT0ic3RyaW5nIj9pOk9lKGksbil9ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBPbihlLG4pO3JldHVybiBTbihlLG4pfWZ1bmN0aW9uIEluKGUpe3JldHVybiB0eXBlb2YgZS50b0pTT049PSJmdW5jdGlvbiJ9ZnVuY3Rpb24gU24oZSx0KXtjb25zdCBuPU9iamVjdC5lbnRyaWVzKGUpO3JldHVybiBuLmxlbmd0aD09PTA/Int9Ijp0Lmxlbmd0aD54dD8iWyIrd24oZSkrIl0iOiJ7ICIrbi5tYXAoKFtyLHNdKT0+cisiOiAiK09lKHMsdCkpLmpvaW4oIiwgIikrIiB9In1mdW5jdGlvbiBPbihlLHQpe2lmKGUubGVuZ3RoPT09MClyZXR1cm4iW10iO2lmKHQubGVuZ3RoPnh0KXJldHVybiJbQXJyYXldIjtjb25zdCBuPU1hdGgubWluKHhuLGUubGVuZ3RoKSxpPWUubGVuZ3RoLW4scj1bXTtmb3IobGV0IHM9MDtzPG47KytzKXIucHVzaChPZShlW3NdLHQpKTtyZXR1cm4gaT09PTE/ci5wdXNoKCIuLi4gMSBtb3JlIGl0ZW0iKTppPjEmJnIucHVzaChgLi4uICR7aX0gbW9yZSBpdGVtc2ApLCJbIityLmpvaW4oIiwgIikrIl0ifWZ1bmN0aW9uIHduKGUpe2NvbnN0IHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnJlcGxhY2UoL15cW29iamVjdCAvLCIiKS5yZXBsYWNlKC9dJC8sIiIpO2lmKHQ9PT0iT2JqZWN0IiYmdHlwZW9mIGUuY29uc3RydWN0b3I9PSJmdW5jdGlvbiIpe2NvbnN0IG49ZS5jb25zdHJ1Y3Rvci5uYW1lO2lmKHR5cGVvZiBuPT0ic3RyaW5nIiYmbiE9PSIiKXJldHVybiBufXJldHVybiB0fWNvbnN0IERuPWdsb2JhbFRoaXMucHJvY2VzcyYmcHJvY2Vzcy5lbnYuTk9ERV9FTlY9PT0icHJvZHVjdGlvbiI/ZnVuY3Rpb24odCxuKXtyZXR1cm4gdCBpbnN0YW5jZW9mIG59OmZ1bmN0aW9uKHQsbil7aWYodCBpbnN0YW5jZW9mIG4pcmV0dXJuITA7aWYodHlwZW9mIHQ9PSJvYmplY3QiJiZ0IT09bnVsbCl7dmFyIGk7Y29uc3Qgcj1uLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddLHM9U3ltYm9sLnRvU3RyaW5nVGFnIGluIHQ/dFtTeW1ib2wudG9TdHJpbmdUYWddOihpPXQuY29uc3RydWN0b3IpPT09bnVsbHx8aT09PXZvaWQgMD92b2lkIDA6aS5uYW1lO2lmKHI9PT1zKXtjb25zdCBvPVllKHQpO3Rocm93IG5ldyBFcnJvcihgQ2Fubm90IHVzZSAke3J9ICIke299IiBmcm9tIGFub3RoZXIgbW9kdWxlIG9yIHJlYWxtLgoKRW5zdXJlIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgaW5zdGFuY2Ugb2YgImdyYXBocWwiIGluIHRoZSBub2RlX21vZHVsZXMKZGlyZWN0b3J5LiBJZiBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgImdyYXBocWwiIGFyZSB0aGUgZGVwZW5kZW5jaWVzIG9mIG90aGVyCnJlbGllZCBvbiBtb2R1bGVzLCB1c2UgInJlc29sdXRpb25zIiB0byBlbnN1cmUgb25seSBvbmUgdmVyc2lvbiBpcyBpbnN0YWxsZWQuCgpodHRwczovL3lhcm5wa2cuY29tL2VuL2RvY3Mvc2VsZWN0aXZlLXZlcnNpb24tcmVzb2x1dGlvbnMKCkR1cGxpY2F0ZSAiZ3JhcGhxbCIgbW9kdWxlcyBjYW5ub3QgYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lIHNpbmNlIGRpZmZlcmVudAp2ZXJzaW9ucyBtYXkgaGF2ZSBkaWZmZXJlbnQgY2FwYWJpbGl0aWVzIGFuZCBiZWhhdmlvci4gVGhlIGRhdGEgZnJvbSBvbmUKdmVyc2lvbiB1c2VkIGluIHRoZSBmdW5jdGlvbiBmcm9tIGFub3RoZXIgY291bGQgcHJvZHVjZSBjb25mdXNpbmcgYW5kCnNwdXJpb3VzIHJlc3VsdHMuYCl9fXJldHVybiExfTtjbGFzcyBBdHtjb25zdHJ1Y3Rvcih0LG49IkdyYXBoUUwgcmVxdWVzdCIsaT17bGluZToxLGNvbHVtbjoxfSl7dHlwZW9mIHQ9PSJzdHJpbmcifHxvZSghMSxgQm9keSBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZDogJHtZZSh0KX0uYCksdGhpcy5ib2R5PXQsdGhpcy5uYW1lPW4sdGhpcy5sb2NhdGlvbk9mZnNldD1pLHRoaXMubG9jYXRpb25PZmZzZXQubGluZT4wfHxvZSghMSwibGluZSBpbiBsb2NhdGlvbk9mZnNldCBpcyAxLWluZGV4ZWQgYW5kIG11c3QgYmUgcG9zaXRpdmUuIiksdGhpcy5sb2NhdGlvbk9mZnNldC5jb2x1bW4+MHx8b2UoITEsImNvbHVtbiBpbiBsb2NhdGlvbk9mZnNldCBpcyAxLWluZGV4ZWQgYW5kIG11c3QgYmUgcG9zaXRpdmUuIil9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm4iU291cmNlIn19ZnVuY3Rpb24gQ24oZSl7cmV0dXJuIERuKGUsQXQpfWZ1bmN0aW9uIEl0KGUsdCl7Y29uc3Qgbj1uZXcga24oZSx0KSxpPW4ucGFyc2VEb2N1bWVudCgpO3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwidG9rZW5Db3VudCIse2VudW1lcmFibGU6ITEsdmFsdWU6bi50b2tlbkNvdW50fSksaX1jbGFzcyBrbntjb25zdHJ1Y3Rvcih0LG49e30pe2NvbnN0IGk9Q24odCk/dDpuZXcgQXQodCk7dGhpcy5fbGV4ZXI9bmV3IGRuKGkpLHRoaXMuX29wdGlvbnM9bix0aGlzLl90b2tlbkNvdW50ZXI9MH1nZXQgdG9rZW5Db3VudCgpe3JldHVybiB0aGlzLl90b2tlbkNvdW50ZXJ9cGFyc2VOYW1lKCl7Y29uc3QgdD10aGlzLmV4cGVjdFRva2VuKGwuTkFNRSk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuTkFNRSx2YWx1ZTp0LnZhbHVlfSl9cGFyc2VEb2N1bWVudCgpe3JldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4se2tpbmQ6VC5ET0NVTUVOVCxkZWZpbml0aW9uczp0aGlzLm1hbnkobC5TT0YsdGhpcy5wYXJzZURlZmluaXRpb24sbC5FT0YpfSl9cGFyc2VEZWZpbml0aW9uKCl7aWYodGhpcy5wZWVrKGwuQlJBQ0VfTCkpcmV0dXJuIHRoaXMucGFyc2VPcGVyYXRpb25EZWZpbml0aW9uKCk7Y29uc3QgdD10aGlzLnBlZWtEZXNjcmlwdGlvbigpLG49dD90aGlzLl9sZXhlci5sb29rYWhlYWQoKTp0aGlzLl9sZXhlci50b2tlbjtpZihuLmtpbmQ9PT1sLk5BTUUpe3N3aXRjaChuLnZhbHVlKXtjYXNlInNjaGVtYSI6cmV0dXJuIHRoaXMucGFyc2VTY2hlbWFEZWZpbml0aW9uKCk7Y2FzZSJzY2FsYXIiOnJldHVybiB0aGlzLnBhcnNlU2NhbGFyVHlwZURlZmluaXRpb24oKTtjYXNlInR5cGUiOnJldHVybiB0aGlzLnBhcnNlT2JqZWN0VHlwZURlZmluaXRpb24oKTtjYXNlImludGVyZmFjZSI6cmV0dXJuIHRoaXMucGFyc2VJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbigpO2Nhc2UidW5pb24iOnJldHVybiB0aGlzLnBhcnNlVW5pb25UeXBlRGVmaW5pdGlvbigpO2Nhc2UiZW51bSI6cmV0dXJuIHRoaXMucGFyc2VFbnVtVHlwZURlZmluaXRpb24oKTtjYXNlImlucHV0IjpyZXR1cm4gdGhpcy5wYXJzZUlucHV0T2JqZWN0VHlwZURlZmluaXRpb24oKTtjYXNlImRpcmVjdGl2ZSI6cmV0dXJuIHRoaXMucGFyc2VEaXJlY3RpdmVEZWZpbml0aW9uKCl9aWYodCl0aHJvdyBHKHRoaXMuX2xleGVyLnNvdXJjZSx0aGlzLl9sZXhlci50b2tlbi5zdGFydCwiVW5leHBlY3RlZCBkZXNjcmlwdGlvbiwgZGVzY3JpcHRpb25zIGFyZSBzdXBwb3J0ZWQgb25seSBvbiB0eXBlIGRlZmluaXRpb25zLiIpO3N3aXRjaChuLnZhbHVlKXtjYXNlInF1ZXJ5IjpjYXNlIm11dGF0aW9uIjpjYXNlInN1YnNjcmlwdGlvbiI6cmV0dXJuIHRoaXMucGFyc2VPcGVyYXRpb25EZWZpbml0aW9uKCk7Y2FzZSJmcmFnbWVudCI6cmV0dXJuIHRoaXMucGFyc2VGcmFnbWVudERlZmluaXRpb24oKTtjYXNlImV4dGVuZCI6cmV0dXJuIHRoaXMucGFyc2VUeXBlU3lzdGVtRXh0ZW5zaW9uKCl9fXRocm93IHRoaXMudW5leHBlY3RlZChuKX1wYXJzZU9wZXJhdGlvbkRlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuO2lmKHRoaXMucGVlayhsLkJSQUNFX0wpKXJldHVybiB0aGlzLm5vZGUodCx7a2luZDpULk9QRVJBVElPTl9ERUZJTklUSU9OLG9wZXJhdGlvbjpmZS5RVUVSWSxuYW1lOnZvaWQgMCx2YXJpYWJsZURlZmluaXRpb25zOltdLGRpcmVjdGl2ZXM6W10sc2VsZWN0aW9uU2V0OnRoaXMucGFyc2VTZWxlY3Rpb25TZXQoKX0pO2NvbnN0IG49dGhpcy5wYXJzZU9wZXJhdGlvblR5cGUoKTtsZXQgaTtyZXR1cm4gdGhpcy5wZWVrKGwuTkFNRSkmJihpPXRoaXMucGFyc2VOYW1lKCkpLHRoaXMubm9kZSh0LHtraW5kOlQuT1BFUkFUSU9OX0RFRklOSVRJT04sb3BlcmF0aW9uOm4sbmFtZTppLHZhcmlhYmxlRGVmaW5pdGlvbnM6dGhpcy5wYXJzZVZhcmlhYmxlRGVmaW5pdGlvbnMoKSxkaXJlY3RpdmVzOnRoaXMucGFyc2VEaXJlY3RpdmVzKCExKSxzZWxlY3Rpb25TZXQ6dGhpcy5wYXJzZVNlbGVjdGlvblNldCgpfSl9cGFyc2VPcGVyYXRpb25UeXBlKCl7Y29uc3QgdD10aGlzLmV4cGVjdFRva2VuKGwuTkFNRSk7c3dpdGNoKHQudmFsdWUpe2Nhc2UicXVlcnkiOnJldHVybiBmZS5RVUVSWTtjYXNlIm11dGF0aW9uIjpyZXR1cm4gZmUuTVVUQVRJT047Y2FzZSJzdWJzY3JpcHRpb24iOnJldHVybiBmZS5TVUJTQ1JJUFRJT059dGhyb3cgdGhpcy51bmV4cGVjdGVkKHQpfXBhcnNlVmFyaWFibGVEZWZpbml0aW9ucygpe3JldHVybiB0aGlzLm9wdGlvbmFsTWFueShsLlBBUkVOX0wsdGhpcy5wYXJzZVZhcmlhYmxlRGVmaW5pdGlvbixsLlBBUkVOX1IpfXBhcnNlVmFyaWFibGVEZWZpbml0aW9uKCl7cmV0dXJuIHRoaXMubm9kZSh0aGlzLl9sZXhlci50b2tlbix7a2luZDpULlZBUklBQkxFX0RFRklOSVRJT04sdmFyaWFibGU6dGhpcy5wYXJzZVZhcmlhYmxlKCksdHlwZToodGhpcy5leHBlY3RUb2tlbihsLkNPTE9OKSx0aGlzLnBhcnNlVHlwZVJlZmVyZW5jZSgpKSxkZWZhdWx0VmFsdWU6dGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGwuRVFVQUxTKT90aGlzLnBhcnNlQ29uc3RWYWx1ZUxpdGVyYWwoKTp2b2lkIDAsZGlyZWN0aXZlczp0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCl9KX1wYXJzZVZhcmlhYmxlKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbjtyZXR1cm4gdGhpcy5leHBlY3RUb2tlbihsLkRPTExBUiksdGhpcy5ub2RlKHQse2tpbmQ6VC5WQVJJQUJMRSxuYW1lOnRoaXMucGFyc2VOYW1lKCl9KX1wYXJzZVNlbGVjdGlvblNldCgpe3JldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4se2tpbmQ6VC5TRUxFQ1RJT05fU0VULHNlbGVjdGlvbnM6dGhpcy5tYW55KGwuQlJBQ0VfTCx0aGlzLnBhcnNlU2VsZWN0aW9uLGwuQlJBQ0VfUil9KX1wYXJzZVNlbGVjdGlvbigpe3JldHVybiB0aGlzLnBlZWsobC5TUFJFQUQpP3RoaXMucGFyc2VGcmFnbWVudCgpOnRoaXMucGFyc2VGaWVsZCgpfXBhcnNlRmllbGQoKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuLG49dGhpcy5wYXJzZU5hbWUoKTtsZXQgaSxyO3JldHVybiB0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4obC5DT0xPTik/KGk9bixyPXRoaXMucGFyc2VOYW1lKCkpOnI9bix0aGlzLm5vZGUodCx7a2luZDpULkZJRUxELGFsaWFzOmksbmFtZTpyLGFyZ3VtZW50czp0aGlzLnBhcnNlQXJndW1lbnRzKCExKSxkaXJlY3RpdmVzOnRoaXMucGFyc2VEaXJlY3RpdmVzKCExKSxzZWxlY3Rpb25TZXQ6dGhpcy5wZWVrKGwuQlJBQ0VfTCk/dGhpcy5wYXJzZVNlbGVjdGlvblNldCgpOnZvaWQgMH0pfXBhcnNlQXJndW1lbnRzKHQpe2NvbnN0IG49dD90aGlzLnBhcnNlQ29uc3RBcmd1bWVudDp0aGlzLnBhcnNlQXJndW1lbnQ7cmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KGwuUEFSRU5fTCxuLGwuUEFSRU5fUil9cGFyc2VBcmd1bWVudCh0PSExKXtjb25zdCBuPXRoaXMuX2xleGVyLnRva2VuLGk9dGhpcy5wYXJzZU5hbWUoKTtyZXR1cm4gdGhpcy5leHBlY3RUb2tlbihsLkNPTE9OKSx0aGlzLm5vZGUobix7a2luZDpULkFSR1VNRU5ULG5hbWU6aSx2YWx1ZTp0aGlzLnBhcnNlVmFsdWVMaXRlcmFsKHQpfSl9cGFyc2VDb25zdEFyZ3VtZW50KCl7cmV0dXJuIHRoaXMucGFyc2VBcmd1bWVudCghMCl9cGFyc2VGcmFnbWVudCgpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47dGhpcy5leHBlY3RUb2tlbihsLlNQUkVBRCk7Y29uc3Qgbj10aGlzLmV4cGVjdE9wdGlvbmFsS2V5d29yZCgib24iKTtyZXR1cm4hbiYmdGhpcy5wZWVrKGwuTkFNRSk/dGhpcy5ub2RlKHQse2tpbmQ6VC5GUkFHTUVOVF9TUFJFQUQsbmFtZTp0aGlzLnBhcnNlRnJhZ21lbnROYW1lKCksZGlyZWN0aXZlczp0aGlzLnBhcnNlRGlyZWN0aXZlcyghMSl9KTp0aGlzLm5vZGUodCx7a2luZDpULklOTElORV9GUkFHTUVOVCx0eXBlQ29uZGl0aW9uOm4/dGhpcy5wYXJzZU5hbWVkVHlwZSgpOnZvaWQgMCxkaXJlY3RpdmVzOnRoaXMucGFyc2VEaXJlY3RpdmVzKCExKSxzZWxlY3Rpb25TZXQ6dGhpcy5wYXJzZVNlbGVjdGlvblNldCgpfSl9cGFyc2VGcmFnbWVudERlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuO3JldHVybiB0aGlzLmV4cGVjdEtleXdvcmQoImZyYWdtZW50IiksdGhpcy5fb3B0aW9ucy5hbGxvd0xlZ2FjeUZyYWdtZW50VmFyaWFibGVzPT09ITA/dGhpcy5ub2RlKHQse2tpbmQ6VC5GUkFHTUVOVF9ERUZJTklUSU9OLG5hbWU6dGhpcy5wYXJzZUZyYWdtZW50TmFtZSgpLHZhcmlhYmxlRGVmaW5pdGlvbnM6dGhpcy5wYXJzZVZhcmlhYmxlRGVmaW5pdGlvbnMoKSx0eXBlQ29uZGl0aW9uOih0aGlzLmV4cGVjdEtleXdvcmQoIm9uIiksdGhpcy5wYXJzZU5hbWVkVHlwZSgpKSxkaXJlY3RpdmVzOnRoaXMucGFyc2VEaXJlY3RpdmVzKCExKSxzZWxlY3Rpb25TZXQ6dGhpcy5wYXJzZVNlbGVjdGlvblNldCgpfSk6dGhpcy5ub2RlKHQse2tpbmQ6VC5GUkFHTUVOVF9ERUZJTklUSU9OLG5hbWU6dGhpcy5wYXJzZUZyYWdtZW50TmFtZSgpLHR5cGVDb25kaXRpb246KHRoaXMuZXhwZWN0S2V5d29yZCgib24iKSx0aGlzLnBhcnNlTmFtZWRUeXBlKCkpLGRpcmVjdGl2ZXM6dGhpcy5wYXJzZURpcmVjdGl2ZXMoITEpLHNlbGVjdGlvblNldDp0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCl9KX1wYXJzZUZyYWdtZW50TmFtZSgpe2lmKHRoaXMuX2xleGVyLnRva2VuLnZhbHVlPT09Im9uIil0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtyZXR1cm4gdGhpcy5wYXJzZU5hbWUoKX1wYXJzZVZhbHVlTGl0ZXJhbCh0KXtjb25zdCBuPXRoaXMuX2xleGVyLnRva2VuO3N3aXRjaChuLmtpbmQpe2Nhc2UgbC5CUkFDS0VUX0w6cmV0dXJuIHRoaXMucGFyc2VMaXN0KHQpO2Nhc2UgbC5CUkFDRV9MOnJldHVybiB0aGlzLnBhcnNlT2JqZWN0KHQpO2Nhc2UgbC5JTlQ6cmV0dXJuIHRoaXMuYWR2YW5jZUxleGVyKCksdGhpcy5ub2RlKG4se2tpbmQ6VC5JTlQsdmFsdWU6bi52YWx1ZX0pO2Nhc2UgbC5GTE9BVDpyZXR1cm4gdGhpcy5hZHZhbmNlTGV4ZXIoKSx0aGlzLm5vZGUobix7a2luZDpULkZMT0FULHZhbHVlOm4udmFsdWV9KTtjYXNlIGwuU1RSSU5HOmNhc2UgbC5CTE9DS19TVFJJTkc6cmV0dXJuIHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKCk7Y2FzZSBsLk5BTUU6c3dpdGNoKHRoaXMuYWR2YW5jZUxleGVyKCksbi52YWx1ZSl7Y2FzZSJ0cnVlIjpyZXR1cm4gdGhpcy5ub2RlKG4se2tpbmQ6VC5CT09MRUFOLHZhbHVlOiEwfSk7Y2FzZSJmYWxzZSI6cmV0dXJuIHRoaXMubm9kZShuLHtraW5kOlQuQk9PTEVBTix2YWx1ZTohMX0pO2Nhc2UibnVsbCI6cmV0dXJuIHRoaXMubm9kZShuLHtraW5kOlQuTlVMTH0pO2RlZmF1bHQ6cmV0dXJuIHRoaXMubm9kZShuLHtraW5kOlQuRU5VTSx2YWx1ZTpuLnZhbHVlfSl9Y2FzZSBsLkRPTExBUjppZih0KWlmKHRoaXMuZXhwZWN0VG9rZW4obC5ET0xMQVIpLHRoaXMuX2xleGVyLnRva2VuLmtpbmQ9PT1sLk5BTUUpe2NvbnN0IGk9dGhpcy5fbGV4ZXIudG9rZW4udmFsdWU7dGhyb3cgRyh0aGlzLl9sZXhlci5zb3VyY2Usbi5zdGFydCxgVW5leHBlY3RlZCB2YXJpYWJsZSAiJCR7aX0iIGluIGNvbnN0YW50IHZhbHVlLmApfWVsc2UgdGhyb3cgdGhpcy51bmV4cGVjdGVkKG4pO3JldHVybiB0aGlzLnBhcnNlVmFyaWFibGUoKTtkZWZhdWx0OnRocm93IHRoaXMudW5leHBlY3RlZCgpfX1wYXJzZUNvbnN0VmFsdWVMaXRlcmFsKCl7cmV0dXJuIHRoaXMucGFyc2VWYWx1ZUxpdGVyYWwoITApfXBhcnNlU3RyaW5nTGl0ZXJhbCgpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJuIHRoaXMuYWR2YW5jZUxleGVyKCksdGhpcy5ub2RlKHQse2tpbmQ6VC5TVFJJTkcsdmFsdWU6dC52YWx1ZSxibG9jazp0LmtpbmQ9PT1sLkJMT0NLX1NUUklOR30pfXBhcnNlTGlzdCh0KXtjb25zdCBuPSgpPT50aGlzLnBhcnNlVmFsdWVMaXRlcmFsKHQpO3JldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4se2tpbmQ6VC5MSVNULHZhbHVlczp0aGlzLmFueShsLkJSQUNLRVRfTCxuLGwuQlJBQ0tFVF9SKX0pfXBhcnNlT2JqZWN0KHQpe2NvbnN0IG49KCk9PnRoaXMucGFyc2VPYmplY3RGaWVsZCh0KTtyZXR1cm4gdGhpcy5ub2RlKHRoaXMuX2xleGVyLnRva2VuLHtraW5kOlQuT0JKRUNULGZpZWxkczp0aGlzLmFueShsLkJSQUNFX0wsbixsLkJSQUNFX1IpfSl9cGFyc2VPYmplY3RGaWVsZCh0KXtjb25zdCBuPXRoaXMuX2xleGVyLnRva2VuLGk9dGhpcy5wYXJzZU5hbWUoKTtyZXR1cm4gdGhpcy5leHBlY3RUb2tlbihsLkNPTE9OKSx0aGlzLm5vZGUobix7a2luZDpULk9CSkVDVF9GSUVMRCxuYW1lOmksdmFsdWU6dGhpcy5wYXJzZVZhbHVlTGl0ZXJhbCh0KX0pfXBhcnNlRGlyZWN0aXZlcyh0KXtjb25zdCBuPVtdO2Zvcig7dGhpcy5wZWVrKGwuQVQpOyluLnB1c2godGhpcy5wYXJzZURpcmVjdGl2ZSh0KSk7cmV0dXJuIG59cGFyc2VDb25zdERpcmVjdGl2ZXMoKXtyZXR1cm4gdGhpcy5wYXJzZURpcmVjdGl2ZXMoITApfXBhcnNlRGlyZWN0aXZlKHQpe2NvbnN0IG49dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJuIHRoaXMuZXhwZWN0VG9rZW4obC5BVCksdGhpcy5ub2RlKG4se2tpbmQ6VC5ESVJFQ1RJVkUsbmFtZTp0aGlzLnBhcnNlTmFtZSgpLGFyZ3VtZW50czp0aGlzLnBhcnNlQXJndW1lbnRzKHQpfSl9cGFyc2VUeXBlUmVmZXJlbmNlKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbjtsZXQgbjtpZih0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4obC5CUkFDS0VUX0wpKXtjb25zdCBpPXRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCk7dGhpcy5leHBlY3RUb2tlbihsLkJSQUNLRVRfUiksbj10aGlzLm5vZGUodCx7a2luZDpULkxJU1RfVFlQRSx0eXBlOml9KX1lbHNlIG49dGhpcy5wYXJzZU5hbWVkVHlwZSgpO3JldHVybiB0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4obC5CQU5HKT90aGlzLm5vZGUodCx7a2luZDpULk5PTl9OVUxMX1RZUEUsdHlwZTpufSk6bn1wYXJzZU5hbWVkVHlwZSgpe3JldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4se2tpbmQ6VC5OQU1FRF9UWVBFLG5hbWU6dGhpcy5wYXJzZU5hbWUoKX0pfXBlZWtEZXNjcmlwdGlvbigpe3JldHVybiB0aGlzLnBlZWsobC5TVFJJTkcpfHx0aGlzLnBlZWsobC5CTE9DS19TVFJJTkcpfXBhcnNlRGVzY3JpcHRpb24oKXtpZih0aGlzLnBlZWtEZXNjcmlwdGlvbigpKXJldHVybiB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCgpfXBhcnNlU2NoZW1hRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoInNjaGVtYSIpO2NvbnN0IGk9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLHI9dGhpcy5tYW55KGwuQlJBQ0VfTCx0aGlzLnBhcnNlT3BlcmF0aW9uVHlwZURlZmluaXRpb24sbC5CUkFDRV9SKTtyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5TQ0hFTUFfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLGRpcmVjdGl2ZXM6aSxvcGVyYXRpb25UeXBlczpyfSl9cGFyc2VPcGVyYXRpb25UeXBlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlT3BlcmF0aW9uVHlwZSgpO3RoaXMuZXhwZWN0VG9rZW4obC5DT0xPTik7Y29uc3QgaT10aGlzLnBhcnNlTmFtZWRUeXBlKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuT1BFUkFUSU9OX1RZUEVfREVGSU5JVElPTixvcGVyYXRpb246bix0eXBlOml9KX1wYXJzZVNjYWxhclR5cGVEZWZpbml0aW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbixuPXRoaXMucGFyc2VEZXNjcmlwdGlvbigpO3RoaXMuZXhwZWN0S2V5d29yZCgic2NhbGFyIik7Y29uc3QgaT10aGlzLnBhcnNlTmFtZSgpLHI9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULlNDQUxBUl9UWVBFX0RFRklOSVRJT04sZGVzY3JpcHRpb246bixuYW1lOmksZGlyZWN0aXZlczpyfSl9cGFyc2VPYmplY3RUeXBlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoInR5cGUiKTtjb25zdCBpPXRoaXMucGFyc2VOYW1lKCkscj10aGlzLnBhcnNlSW1wbGVtZW50c0ludGVyZmFjZXMoKSxzPXRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKSxvPXRoaXMucGFyc2VGaWVsZHNEZWZpbml0aW9uKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuT0JKRUNUX1RZUEVfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLG5hbWU6aSxpbnRlcmZhY2VzOnIsZGlyZWN0aXZlczpzLGZpZWxkczpvfSl9cGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpe3JldHVybiB0aGlzLmV4cGVjdE9wdGlvbmFsS2V5d29yZCgiaW1wbGVtZW50cyIpP3RoaXMuZGVsaW1pdGVkTWFueShsLkFNUCx0aGlzLnBhcnNlTmFtZWRUeXBlKTpbXX1wYXJzZUZpZWxkc0RlZmluaXRpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkobC5CUkFDRV9MLHRoaXMucGFyc2VGaWVsZERlZmluaXRpb24sbC5CUkFDRV9SKX1wYXJzZUZpZWxkRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKSxpPXRoaXMucGFyc2VOYW1lKCkscj10aGlzLnBhcnNlQXJndW1lbnREZWZzKCk7dGhpcy5leHBlY3RUb2tlbihsLkNPTE9OKTtjb25zdCBzPXRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCksbz10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuRklFTERfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLG5hbWU6aSxhcmd1bWVudHM6cix0eXBlOnMsZGlyZWN0aXZlczpvfSl9cGFyc2VBcmd1bWVudERlZnMoKXtyZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkobC5QQVJFTl9MLHRoaXMucGFyc2VJbnB1dFZhbHVlRGVmLGwuUEFSRU5fUil9cGFyc2VJbnB1dFZhbHVlRGVmKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbixuPXRoaXMucGFyc2VEZXNjcmlwdGlvbigpLGk9dGhpcy5wYXJzZU5hbWUoKTt0aGlzLmV4cGVjdFRva2VuKGwuQ09MT04pO2NvbnN0IHI9dGhpcy5wYXJzZVR5cGVSZWZlcmVuY2UoKTtsZXQgczt0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4obC5FUVVBTFMpJiYocz10aGlzLnBhcnNlQ29uc3RWYWx1ZUxpdGVyYWwoKSk7Y29uc3Qgbz10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuSU5QVVRfVkFMVUVfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLG5hbWU6aSx0eXBlOnIsZGVmYXVsdFZhbHVlOnMsZGlyZWN0aXZlczpvfSl9cGFyc2VJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoImludGVyZmFjZSIpO2NvbnN0IGk9dGhpcy5wYXJzZU5hbWUoKSxyPXRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpLHM9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLG89dGhpcy5wYXJzZUZpZWxkc0RlZmluaXRpb24oKTtyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5JTlRFUkZBQ0VfVFlQRV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOm4sbmFtZTppLGludGVyZmFjZXM6cixkaXJlY3RpdmVzOnMsZmllbGRzOm99KX1wYXJzZVVuaW9uVHlwZURlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuLG49dGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7dGhpcy5leHBlY3RLZXl3b3JkKCJ1bmlvbiIpO2NvbnN0IGk9dGhpcy5wYXJzZU5hbWUoKSxyPXRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKSxzPXRoaXMucGFyc2VVbmlvbk1lbWJlclR5cGVzKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuVU5JT05fVFlQRV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOm4sbmFtZTppLGRpcmVjdGl2ZXM6cix0eXBlczpzfSl9cGFyc2VVbmlvbk1lbWJlclR5cGVzKCl7cmV0dXJuIHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihsLkVRVUFMUyk/dGhpcy5kZWxpbWl0ZWRNYW55KGwuUElQRSx0aGlzLnBhcnNlTmFtZWRUeXBlKTpbXX1wYXJzZUVudW1UeXBlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoImVudW0iKTtjb25zdCBpPXRoaXMucGFyc2VOYW1lKCkscj10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCkscz10aGlzLnBhcnNlRW51bVZhbHVlc0RlZmluaXRpb24oKTtyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5FTlVNX1RZUEVfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLG5hbWU6aSxkaXJlY3RpdmVzOnIsdmFsdWVzOnN9KX1wYXJzZUVudW1WYWx1ZXNEZWZpbml0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KGwuQlJBQ0VfTCx0aGlzLnBhcnNlRW51bVZhbHVlRGVmaW5pdGlvbixsLkJSQUNFX1IpfXBhcnNlRW51bVZhbHVlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKSxpPXRoaXMucGFyc2VFbnVtVmFsdWVOYW1lKCkscj10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuRU5VTV9WQUxVRV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOm4sbmFtZTppLGRpcmVjdGl2ZXM6cn0pfXBhcnNlRW51bVZhbHVlTmFtZSgpe2lmKHRoaXMuX2xleGVyLnRva2VuLnZhbHVlPT09InRydWUifHx0aGlzLl9sZXhlci50b2tlbi52YWx1ZT09PSJmYWxzZSJ8fHRoaXMuX2xleGVyLnRva2VuLnZhbHVlPT09Im51bGwiKXRocm93IEcodGhpcy5fbGV4ZXIuc291cmNlLHRoaXMuX2xleGVyLnRva2VuLnN0YXJ0LGAke3dlKHRoaXMuX2xleGVyLnRva2VuKX0gaXMgcmVzZXJ2ZWQgYW5kIGNhbm5vdCBiZSB1c2VkIGZvciBhbiBlbnVtIHZhbHVlLmApO3JldHVybiB0aGlzLnBhcnNlTmFtZSgpfXBhcnNlSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoImlucHV0Iik7Y29uc3QgaT10aGlzLnBhcnNlTmFtZSgpLHI9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLHM9dGhpcy5wYXJzZUlucHV0RmllbGRzRGVmaW5pdGlvbigpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULklOUFVUX09CSkVDVF9UWVBFX0RFRklOSVRJT04sZGVzY3JpcHRpb246bixuYW1lOmksZGlyZWN0aXZlczpyLGZpZWxkczpzfSl9cGFyc2VJbnB1dEZpZWxkc0RlZmluaXRpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkobC5CUkFDRV9MLHRoaXMucGFyc2VJbnB1dFZhbHVlRGVmLGwuQlJBQ0VfUil9cGFyc2VUeXBlU3lzdGVtRXh0ZW5zaW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci5sb29rYWhlYWQoKTtpZih0LmtpbmQ9PT1sLk5BTUUpc3dpdGNoKHQudmFsdWUpe2Nhc2Uic2NoZW1hIjpyZXR1cm4gdGhpcy5wYXJzZVNjaGVtYUV4dGVuc2lvbigpO2Nhc2Uic2NhbGFyIjpyZXR1cm4gdGhpcy5wYXJzZVNjYWxhclR5cGVFeHRlbnNpb24oKTtjYXNlInR5cGUiOnJldHVybiB0aGlzLnBhcnNlT2JqZWN0VHlwZUV4dGVuc2lvbigpO2Nhc2UiaW50ZXJmYWNlIjpyZXR1cm4gdGhpcy5wYXJzZUludGVyZmFjZVR5cGVFeHRlbnNpb24oKTtjYXNlInVuaW9uIjpyZXR1cm4gdGhpcy5wYXJzZVVuaW9uVHlwZUV4dGVuc2lvbigpO2Nhc2UiZW51bSI6cmV0dXJuIHRoaXMucGFyc2VFbnVtVHlwZUV4dGVuc2lvbigpO2Nhc2UiaW5wdXQiOnJldHVybiB0aGlzLnBhcnNlSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uKCl9dGhyb3cgdGhpcy51bmV4cGVjdGVkKHQpfXBhcnNlU2NoZW1hRXh0ZW5zaW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbjt0aGlzLmV4cGVjdEtleXdvcmQoImV4dGVuZCIpLHRoaXMuZXhwZWN0S2V5d29yZCgic2NoZW1hIik7Y29uc3Qgbj10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCksaT10aGlzLm9wdGlvbmFsTWFueShsLkJSQUNFX0wsdGhpcy5wYXJzZU9wZXJhdGlvblR5cGVEZWZpbml0aW9uLGwuQlJBQ0VfUik7aWYobi5sZW5ndGg9PT0wJiZpLmxlbmd0aD09PTApdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuU0NIRU1BX0VYVEVOU0lPTixkaXJlY3RpdmVzOm4sb3BlcmF0aW9uVHlwZXM6aX0pfXBhcnNlU2NhbGFyVHlwZUV4dGVuc2lvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47dGhpcy5leHBlY3RLZXl3b3JkKCJleHRlbmQiKSx0aGlzLmV4cGVjdEtleXdvcmQoInNjYWxhciIpO2NvbnN0IG49dGhpcy5wYXJzZU5hbWUoKSxpPXRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtpZihpLmxlbmd0aD09PTApdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuU0NBTEFSX1RZUEVfRVhURU5TSU9OLG5hbWU6bixkaXJlY3RpdmVzOml9KX1wYXJzZU9iamVjdFR5cGVFeHRlbnNpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuO3RoaXMuZXhwZWN0S2V5d29yZCgiZXh0ZW5kIiksdGhpcy5leHBlY3RLZXl3b3JkKCJ0eXBlIik7Y29uc3Qgbj10aGlzLnBhcnNlTmFtZSgpLGk9dGhpcy5wYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzKCkscj10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCkscz10aGlzLnBhcnNlRmllbGRzRGVmaW5pdGlvbigpO2lmKGkubGVuZ3RoPT09MCYmci5sZW5ndGg9PT0wJiZzLmxlbmd0aD09PTApdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuT0JKRUNUX1RZUEVfRVhURU5TSU9OLG5hbWU6bixpbnRlcmZhY2VzOmksZGlyZWN0aXZlczpyLGZpZWxkczpzfSl9cGFyc2VJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbjt0aGlzLmV4cGVjdEtleXdvcmQoImV4dGVuZCIpLHRoaXMuZXhwZWN0S2V5d29yZCgiaW50ZXJmYWNlIik7Y29uc3Qgbj10aGlzLnBhcnNlTmFtZSgpLGk9dGhpcy5wYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzKCkscj10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCkscz10aGlzLnBhcnNlRmllbGRzRGVmaW5pdGlvbigpO2lmKGkubGVuZ3RoPT09MCYmci5sZW5ndGg9PT0wJiZzLmxlbmd0aD09PTApdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuSU5URVJGQUNFX1RZUEVfRVhURU5TSU9OLG5hbWU6bixpbnRlcmZhY2VzOmksZGlyZWN0aXZlczpyLGZpZWxkczpzfSl9cGFyc2VVbmlvblR5cGVFeHRlbnNpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuO3RoaXMuZXhwZWN0S2V5d29yZCgiZXh0ZW5kIiksdGhpcy5leHBlY3RLZXl3b3JkKCJ1bmlvbiIpO2NvbnN0IG49dGhpcy5wYXJzZU5hbWUoKSxpPXRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKSxyPXRoaXMucGFyc2VVbmlvbk1lbWJlclR5cGVzKCk7aWYoaS5sZW5ndGg9PT0wJiZyLmxlbmd0aD09PTApdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuVU5JT05fVFlQRV9FWFRFTlNJT04sbmFtZTpuLGRpcmVjdGl2ZXM6aSx0eXBlczpyfSl9cGFyc2VFbnVtVHlwZUV4dGVuc2lvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47dGhpcy5leHBlY3RLZXl3b3JkKCJleHRlbmQiKSx0aGlzLmV4cGVjdEtleXdvcmQoImVudW0iKTtjb25zdCBuPXRoaXMucGFyc2VOYW1lKCksaT10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCkscj10aGlzLnBhcnNlRW51bVZhbHVlc0RlZmluaXRpb24oKTtpZihpLmxlbmd0aD09PTAmJnIubGVuZ3RoPT09MCl0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5FTlVNX1RZUEVfRVhURU5TSU9OLG5hbWU6bixkaXJlY3RpdmVzOmksdmFsdWVzOnJ9KX1wYXJzZUlucHV0T2JqZWN0VHlwZUV4dGVuc2lvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47dGhpcy5leHBlY3RLZXl3b3JkKCJleHRlbmQiKSx0aGlzLmV4cGVjdEtleXdvcmQoImlucHV0Iik7Y29uc3Qgbj10aGlzLnBhcnNlTmFtZSgpLGk9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLHI9dGhpcy5wYXJzZUlucHV0RmllbGRzRGVmaW5pdGlvbigpO2lmKGkubGVuZ3RoPT09MCYmci5sZW5ndGg9PT0wKXRocm93IHRoaXMudW5leHBlY3RlZCgpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULklOUFVUX09CSkVDVF9UWVBFX0VYVEVOU0lPTixuYW1lOm4sZGlyZWN0aXZlczppLGZpZWxkczpyfSl9cGFyc2VEaXJlY3RpdmVEZWZpbml0aW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbixuPXRoaXMucGFyc2VEZXNjcmlwdGlvbigpO3RoaXMuZXhwZWN0S2V5d29yZCgiZGlyZWN0aXZlIiksdGhpcy5leHBlY3RUb2tlbihsLkFUKTtjb25zdCBpPXRoaXMucGFyc2VOYW1lKCkscj10aGlzLnBhcnNlQXJndW1lbnREZWZzKCkscz10aGlzLmV4cGVjdE9wdGlvbmFsS2V5d29yZCgicmVwZWF0YWJsZSIpO3RoaXMuZXhwZWN0S2V5d29yZCgib24iKTtjb25zdCBvPXRoaXMucGFyc2VEaXJlY3RpdmVMb2NhdGlvbnMoKTtyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5ESVJFQ1RJVkVfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLG5hbWU6aSxhcmd1bWVudHM6cixyZXBlYXRhYmxlOnMsbG9jYXRpb25zOm99KX1wYXJzZURpcmVjdGl2ZUxvY2F0aW9ucygpe3JldHVybiB0aGlzLmRlbGltaXRlZE1hbnkobC5QSVBFLHRoaXMucGFyc2VEaXJlY3RpdmVMb2NhdGlvbil9cGFyc2VEaXJlY3RpdmVMb2NhdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlTmFtZSgpO2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChHZSxuLnZhbHVlKSlyZXR1cm4gbjt0aHJvdyB0aGlzLnVuZXhwZWN0ZWQodCl9bm9kZSh0LG4pe3JldHVybiB0aGlzLl9vcHRpb25zLm5vTG9jYXRpb24hPT0hMCYmKG4ubG9jPW5ldyBhbih0LHRoaXMuX2xleGVyLmxhc3RUb2tlbix0aGlzLl9sZXhlci5zb3VyY2UpKSxufXBlZWsodCl7cmV0dXJuIHRoaXMuX2xleGVyLnRva2VuLmtpbmQ9PT10fWV4cGVjdFRva2VuKHQpe2NvbnN0IG49dGhpcy5fbGV4ZXIudG9rZW47aWYobi5raW5kPT09dClyZXR1cm4gdGhpcy5hZHZhbmNlTGV4ZXIoKSxuO3Rocm93IEcodGhpcy5fbGV4ZXIuc291cmNlLG4uc3RhcnQsYEV4cGVjdGVkICR7U3QodCl9LCBmb3VuZCAke3dlKG4pfS5gKX1leHBlY3RPcHRpb25hbFRva2VuKHQpe3JldHVybiB0aGlzLl9sZXhlci50b2tlbi5raW5kPT09dD8odGhpcy5hZHZhbmNlTGV4ZXIoKSwhMCk6ITF9ZXhwZWN0S2V5d29yZCh0KXtjb25zdCBuPXRoaXMuX2xleGVyLnRva2VuO2lmKG4ua2luZD09PWwuTkFNRSYmbi52YWx1ZT09PXQpdGhpcy5hZHZhbmNlTGV4ZXIoKTtlbHNlIHRocm93IEcodGhpcy5fbGV4ZXIuc291cmNlLG4uc3RhcnQsYEV4cGVjdGVkICIke3R9IiwgZm91bmQgJHt3ZShuKX0uYCl9ZXhwZWN0T3B0aW9uYWxLZXl3b3JkKHQpe2NvbnN0IG49dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJuIG4ua2luZD09PWwuTkFNRSYmbi52YWx1ZT09PXQ/KHRoaXMuYWR2YW5jZUxleGVyKCksITApOiExfXVuZXhwZWN0ZWQodCl7Y29uc3Qgbj10IT1udWxsP3Q6dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJuIEcodGhpcy5fbGV4ZXIuc291cmNlLG4uc3RhcnQsYFVuZXhwZWN0ZWQgJHt3ZShuKX0uYCl9YW55KHQsbixpKXt0aGlzLmV4cGVjdFRva2VuKHQpO2NvbnN0IHI9W107Zm9yKDshdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGkpOylyLnB1c2gobi5jYWxsKHRoaXMpKTtyZXR1cm4gcn1vcHRpb25hbE1hbnkodCxuLGkpe2lmKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbih0KSl7Y29uc3Qgcj1bXTtkbyByLnB1c2gobi5jYWxsKHRoaXMpKTt3aGlsZSghdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGkpKTtyZXR1cm4gcn1yZXR1cm5bXX1tYW55KHQsbixpKXt0aGlzLmV4cGVjdFRva2VuKHQpO2NvbnN0IHI9W107ZG8gci5wdXNoKG4uY2FsbCh0aGlzKSk7d2hpbGUoIXRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihpKSk7cmV0dXJuIHJ9ZGVsaW1pdGVkTWFueSh0LG4pe3RoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbih0KTtjb25zdCBpPVtdO2RvIGkucHVzaChuLmNhbGwodGhpcykpO3doaWxlKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbih0KSk7cmV0dXJuIGl9YWR2YW5jZUxleGVyKCl7Y29uc3R7bWF4VG9rZW5zOnR9PXRoaXMuX29wdGlvbnMsbj10aGlzLl9sZXhlci5hZHZhbmNlKCk7aWYobi5raW5kIT09bC5FT0YmJigrK3RoaXMuX3Rva2VuQ291bnRlcix0IT09dm9pZCAwJiZ0aGlzLl90b2tlbkNvdW50ZXI+dCkpdGhyb3cgRyh0aGlzLl9sZXhlci5zb3VyY2Usbi5zdGFydCxgRG9jdW1lbnQgY29udGFpbnMgbW9yZSB0aGF0ICR7dH0gdG9rZW5zLiBQYXJzaW5nIGFib3J0ZWQuYCl9fWZ1bmN0aW9uIHdlKGUpe2NvbnN0IHQ9ZS52YWx1ZTtyZXR1cm4gU3QoZS5raW5kKSsodCE9bnVsbD9gICIke3R9ImA6IiIpfWZ1bmN0aW9uIFN0KGUpe3JldHVybiBwbihlKT9gIiR7ZX0iYDplfWZ1bmN0aW9uIFJuKGUpe3JldHVybmAiJHtlLnJlcGxhY2UoUG4sTG4pfSJgfWNvbnN0IFBuPS9bXHgwMC1ceDFmXHgyMlx4NWNceDdmLVx4OWZdL2c7ZnVuY3Rpb24gTG4oZSl7cmV0dXJuIEZuW2UuY2hhckNvZGVBdCgwKV19Y29uc3QgRm49WyJcXHUwMDAwIiwiXFx1MDAwMSIsIlxcdTAwMDIiLCJcXHUwMDAzIiwiXFx1MDAwNCIsIlxcdTAwMDUiLCJcXHUwMDA2IiwiXFx1MDAwNyIsIlxcYiIsIlxcdCIsIlxcbiIsIlxcdTAwMEIiLCJcXGYiLCJcXHIiLCJcXHUwMDBFIiwiXFx1MDAwRiIsIlxcdTAwMTAiLCJcXHUwMDExIiwiXFx1MDAxMiIsIlxcdTAwMTMiLCJcXHUwMDE0IiwiXFx1MDAxNSIsIlxcdTAwMTYiLCJcXHUwMDE3IiwiXFx1MDAxOCIsIlxcdTAwMTkiLCJcXHUwMDFBIiwiXFx1MDAxQiIsIlxcdTAwMUMiLCJcXHUwMDFEIiwiXFx1MDAxRSIsIlxcdTAwMUYiLCIiLCIiLCdcXCInLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJcXFxcIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiXFx1MDA3RiIsIlxcdTAwODAiLCJcXHUwMDgxIiwiXFx1MDA4MiIsIlxcdTAwODMiLCJcXHUwMDg0IiwiXFx1MDA4NSIsIlxcdTAwODYiLCJcXHUwMDg3IiwiXFx1MDA4OCIsIlxcdTAwODkiLCJcXHUwMDhBIiwiXFx1MDA4QiIsIlxcdTAwOEMiLCJcXHUwMDhEIiwiXFx1MDA4RSIsIlxcdTAwOEYiLCJcXHUwMDkwIiwiXFx1MDA5MSIsIlxcdTAwOTIiLCJcXHUwMDkzIiwiXFx1MDA5NCIsIlxcdTAwOTUiLCJcXHUwMDk2IiwiXFx1MDA5NyIsIlxcdTAwOTgiLCJcXHUwMDk5IiwiXFx1MDA5QSIsIlxcdTAwOUIiLCJcXHUwMDlDIiwiXFx1MDA5RCIsIlxcdTAwOUUiLCJcXHUwMDlGIl0sTW49T2JqZWN0LmZyZWV6ZSh7fSk7ZnVuY3Rpb24gJG4oZSx0LG49Z3Qpe2NvbnN0IGk9bmV3IE1hcDtmb3IoY29uc3QgRSBvZiBPYmplY3QudmFsdWVzKFQpKWkuc2V0KEUsQm4odCxFKSk7bGV0IHIscz1BcnJheS5pc0FycmF5KGUpLG89W2VdLGM9LTEsZj1bXSxkPWUsdSx5O2NvbnN0IHY9W10sYj1bXTtkb3tjKys7Y29uc3QgRT1jPT09by5sZW5ndGgsQz1FJiZmLmxlbmd0aCE9PTA7aWYoRSl7aWYodT1iLmxlbmd0aD09PTA/dm9pZCAwOnZbdi5sZW5ndGgtMV0sZD15LHk9Yi5wb3AoKSxDKWlmKHMpe2Q9ZC5zbGljZSgpO2xldCBSPTA7Zm9yKGNvbnN0WyQscV1vZiBmKXtjb25zdCBCPSQtUjtxPT09bnVsbD8oZC5zcGxpY2UoQiwxKSxSKyspOmRbQl09cX19ZWxzZXtkPUQoe30sZCk7Zm9yKGNvbnN0W1IsJF1vZiBmKWRbUl09JH1jPXIuaW5kZXgsbz1yLmtleXMsZj1yLmVkaXRzLHM9ci5pbkFycmF5LHI9ci5wcmV2fWVsc2UgaWYoeSl7aWYodT1zP2M6b1tjXSxkPXlbdV0sZD09bnVsbCljb250aW51ZTt2LnB1c2godSl9bGV0IHc7aWYoIUFycmF5LmlzQXJyYXkoZCkpe3ZhciBtLE47dnQoZCl8fG9lKCExLGBJbnZhbGlkIEFTVCBOb2RlOiAke1llKGQpfS5gKTtjb25zdCBSPUU/KG09aS5nZXQoZC5raW5kKSk9PT1udWxsfHxtPT09dm9pZCAwP3ZvaWQgMDptLmxlYXZlOihOPWkuZ2V0KGQua2luZCkpPT09bnVsbHx8Tj09PXZvaWQgMD92b2lkIDA6Ti5lbnRlcjtpZih3PVI9PW51bGw/dm9pZCAwOlIuY2FsbCh0LGQsdSx5LHYsYiksdz09PU1uKWJyZWFrO2lmKHc9PT0hMSl7aWYoIUUpe3YucG9wKCk7Y29udGludWV9fWVsc2UgaWYodyE9PXZvaWQgMCYmKGYucHVzaChbdSx3XSksIUUpKWlmKHZ0KHcpKWQ9dztlbHNle3YucG9wKCk7Y29udGludWV9fWlmKHc9PT12b2lkIDAmJkMmJmYucHVzaChbdSxkXSksRSl2LnBvcCgpO2Vsc2V7dmFyIGc7cj17aW5BcnJheTpzLGluZGV4OmMsa2V5czpvLGVkaXRzOmYscHJldjpyfSxzPUFycmF5LmlzQXJyYXkoZCksbz1zP2Q6KGc9bltkLmtpbmRdKSE9PW51bGwmJmchPT12b2lkIDA/ZzpbXSxjPS0xLGY9W10seSYmYi5wdXNoKHkpLHk9ZH19d2hpbGUociE9PXZvaWQgMCk7cmV0dXJuIGYubGVuZ3RoIT09MD9mW2YubGVuZ3RoLTFdWzFdOmV9ZnVuY3Rpb24gQm4oZSx0KXtjb25zdCBuPWVbdF07cmV0dXJuIHR5cGVvZiBuPT0ib2JqZWN0Ij9uOnR5cGVvZiBuPT0iZnVuY3Rpb24iP3tlbnRlcjpuLGxlYXZlOnZvaWQgMH06e2VudGVyOmUuZW50ZXIsbGVhdmU6ZS5sZWF2ZX19ZnVuY3Rpb24gVW4oZSl7cmV0dXJuICRuKGUsam4pfWNvbnN0IFZuPTgwLGpuPXtOYW1lOntsZWF2ZTplPT5lLnZhbHVlfSxWYXJpYWJsZTp7bGVhdmU6ZT0+IiQiK2UubmFtZX0sRG9jdW1lbnQ6e2xlYXZlOmU9PnAoZS5kZWZpbml0aW9ucyxgCgpgKX0sT3BlcmF0aW9uRGVmaW5pdGlvbjp7bGVhdmUoZSl7Y29uc3QgdD1PKCIoIixwKGUudmFyaWFibGVEZWZpbml0aW9ucywiLCAiKSwiKSIpLG49cChbZS5vcGVyYXRpb24scChbZS5uYW1lLHRdKSxwKGUuZGlyZWN0aXZlcywiICIpXSwiICIpO3JldHVybihuPT09InF1ZXJ5Ij8iIjpuKyIgIikrZS5zZWxlY3Rpb25TZXR9fSxWYXJpYWJsZURlZmluaXRpb246e2xlYXZlOih7dmFyaWFibGU6ZSx0eXBlOnQsZGVmYXVsdFZhbHVlOm4sZGlyZWN0aXZlczppfSk9PmUrIjogIit0K08oIiA9ICIsbikrTygiICIscChpLCIgIikpfSxTZWxlY3Rpb25TZXQ6e2xlYXZlOih7c2VsZWN0aW9uczplfSk9PmVlKGUpfSxGaWVsZDp7bGVhdmUoe2FsaWFzOmUsbmFtZTp0LGFyZ3VtZW50czpuLGRpcmVjdGl2ZXM6aSxzZWxlY3Rpb25TZXQ6cn0pe2NvbnN0IHM9TygiIixlLCI6ICIpK3Q7bGV0IG89cytPKCIoIixwKG4sIiwgIiksIikiKTtyZXR1cm4gby5sZW5ndGg+Vm4mJihvPXMrTyhgKApgLERlKHAobixgCmApKSxgCilgKSkscChbbyxwKGksIiAiKSxyXSwiICIpfX0sQXJndW1lbnQ6e2xlYXZlOih7bmFtZTplLHZhbHVlOnR9KT0+ZSsiOiAiK3R9LEZyYWdtZW50U3ByZWFkOntsZWF2ZTooe25hbWU6ZSxkaXJlY3RpdmVzOnR9KT0+Ii4uLiIrZStPKCIgIixwKHQsIiAiKSl9LElubGluZUZyYWdtZW50OntsZWF2ZTooe3R5cGVDb25kaXRpb246ZSxkaXJlY3RpdmVzOnQsc2VsZWN0aW9uU2V0Om59KT0+cChbIi4uLiIsTygib24gIixlKSxwKHQsIiAiKSxuXSwiICIpfSxGcmFnbWVudERlZmluaXRpb246e2xlYXZlOih7bmFtZTplLHR5cGVDb25kaXRpb246dCx2YXJpYWJsZURlZmluaXRpb25zOm4sZGlyZWN0aXZlczppLHNlbGVjdGlvblNldDpyfSk9PmBmcmFnbWVudCAke2V9JHtPKCIoIixwKG4sIiwgIiksIikiKX0gb24gJHt0fSAke08oIiIscChpLCIgIiksIiAiKX1gK3J9LEludFZhbHVlOntsZWF2ZTooe3ZhbHVlOmV9KT0+ZX0sRmxvYXRWYWx1ZTp7bGVhdmU6KHt2YWx1ZTplfSk9PmV9LFN0cmluZ1ZhbHVlOntsZWF2ZTooe3ZhbHVlOmUsYmxvY2s6dH0pPT50P2huKGUpOlJuKGUpfSxCb29sZWFuVmFsdWU6e2xlYXZlOih7dmFsdWU6ZX0pPT5lPyJ0cnVlIjoiZmFsc2UifSxOdWxsVmFsdWU6e2xlYXZlOigpPT4ibnVsbCJ9LEVudW1WYWx1ZTp7bGVhdmU6KHt2YWx1ZTplfSk9PmV9LExpc3RWYWx1ZTp7bGVhdmU6KHt2YWx1ZXM6ZX0pPT4iWyIrcChlLCIsICIpKyJdIn0sT2JqZWN0VmFsdWU6e2xlYXZlOih7ZmllbGRzOmV9KT0+InsiK3AoZSwiLCAiKSsifSJ9LE9iamVjdEZpZWxkOntsZWF2ZTooe25hbWU6ZSx2YWx1ZTp0fSk9PmUrIjogIit0fSxEaXJlY3RpdmU6e2xlYXZlOih7bmFtZTplLGFyZ3VtZW50czp0fSk9PiJAIitlK08oIigiLHAodCwiLCAiKSwiKSIpfSxOYW1lZFR5cGU6e2xlYXZlOih7bmFtZTplfSk9PmV9LExpc3RUeXBlOntsZWF2ZTooe3R5cGU6ZX0pPT4iWyIrZSsiXSJ9LE5vbk51bGxUeXBlOntsZWF2ZTooe3R5cGU6ZX0pPT5lKyIhIn0sU2NoZW1hRGVmaW5pdGlvbjp7bGVhdmU6KHtkZXNjcmlwdGlvbjplLGRpcmVjdGl2ZXM6dCxvcGVyYXRpb25UeXBlczpufSk9Pk8oIiIsZSxgCmApK3AoWyJzY2hlbWEiLHAodCwiICIpLGVlKG4pXSwiICIpfSxPcGVyYXRpb25UeXBlRGVmaW5pdGlvbjp7bGVhdmU6KHtvcGVyYXRpb246ZSx0eXBlOnR9KT0+ZSsiOiAiK3R9LFNjYWxhclR5cGVEZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsbmFtZTp0LGRpcmVjdGl2ZXM6bn0pPT5PKCIiLGUsYApgKStwKFsic2NhbGFyIix0LHAobiwiICIpXSwiICIpfSxPYmplY3RUeXBlRGVmaW5pdGlvbjp7bGVhdmU6KHtkZXNjcmlwdGlvbjplLG5hbWU6dCxpbnRlcmZhY2VzOm4sZGlyZWN0aXZlczppLGZpZWxkczpyfSk9Pk8oIiIsZSxgCmApK3AoWyJ0eXBlIix0LE8oImltcGxlbWVudHMgIixwKG4sIiAmICIpKSxwKGksIiAiKSxlZShyKV0sIiAiKX0sRmllbGREZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsbmFtZTp0LGFyZ3VtZW50czpuLHR5cGU6aSxkaXJlY3RpdmVzOnJ9KT0+TygiIixlLGAKYCkrdCsoT3Qobik/TyhgKApgLERlKHAobixgCmApKSxgCilgKTpPKCIoIixwKG4sIiwgIiksIikiKSkrIjogIitpK08oIiAiLHAociwiICIpKX0sSW5wdXRWYWx1ZURlZmluaXRpb246e2xlYXZlOih7ZGVzY3JpcHRpb246ZSxuYW1lOnQsdHlwZTpuLGRlZmF1bHRWYWx1ZTppLGRpcmVjdGl2ZXM6cn0pPT5PKCIiLGUsYApgKStwKFt0KyI6ICIrbixPKCI9ICIsaSkscChyLCIgIildLCIgIil9LEludGVyZmFjZVR5cGVEZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsbmFtZTp0LGludGVyZmFjZXM6bixkaXJlY3RpdmVzOmksZmllbGRzOnJ9KT0+TygiIixlLGAKYCkrcChbImludGVyZmFjZSIsdCxPKCJpbXBsZW1lbnRzICIscChuLCIgJiAiKSkscChpLCIgIiksZWUocildLCIgIil9LFVuaW9uVHlwZURlZmluaXRpb246e2xlYXZlOih7ZGVzY3JpcHRpb246ZSxuYW1lOnQsZGlyZWN0aXZlczpuLHR5cGVzOml9KT0+TygiIixlLGAKYCkrcChbInVuaW9uIix0LHAobiwiICIpLE8oIj0gIixwKGksIiB8ICIpKV0sIiAiKX0sRW51bVR5cGVEZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsbmFtZTp0LGRpcmVjdGl2ZXM6bix2YWx1ZXM6aX0pPT5PKCIiLGUsYApgKStwKFsiZW51bSIsdCxwKG4sIiAiKSxlZShpKV0sIiAiKX0sRW51bVZhbHVlRGVmaW5pdGlvbjp7bGVhdmU6KHtkZXNjcmlwdGlvbjplLG5hbWU6dCxkaXJlY3RpdmVzOm59KT0+TygiIixlLGAKYCkrcChbdCxwKG4sIiAiKV0sIiAiKX0sSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbjp7bGVhdmU6KHtkZXNjcmlwdGlvbjplLG5hbWU6dCxkaXJlY3RpdmVzOm4sZmllbGRzOml9KT0+TygiIixlLGAKYCkrcChbImlucHV0Iix0LHAobiwiICIpLGVlKGkpXSwiICIpfSxEaXJlY3RpdmVEZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsbmFtZTp0LGFyZ3VtZW50czpuLHJlcGVhdGFibGU6aSxsb2NhdGlvbnM6cn0pPT5PKCIiLGUsYApgKSsiZGlyZWN0aXZlIEAiK3QrKE90KG4pP08oYCgKYCxEZShwKG4sYApgKSksYAopYCk6TygiKCIscChuLCIsICIpLCIpIikpKyhpPyIgcmVwZWF0YWJsZSI6IiIpKyIgb24gIitwKHIsIiB8ICIpfSxTY2hlbWFFeHRlbnNpb246e2xlYXZlOih7ZGlyZWN0aXZlczplLG9wZXJhdGlvblR5cGVzOnR9KT0+cChbImV4dGVuZCBzY2hlbWEiLHAoZSwiICIpLGVlKHQpXSwiICIpfSxTY2FsYXJUeXBlRXh0ZW5zaW9uOntsZWF2ZTooe25hbWU6ZSxkaXJlY3RpdmVzOnR9KT0+cChbImV4dGVuZCBzY2FsYXIiLGUscCh0LCIgIildLCIgIil9LE9iamVjdFR5cGVFeHRlbnNpb246e2xlYXZlOih7bmFtZTplLGludGVyZmFjZXM6dCxkaXJlY3RpdmVzOm4sZmllbGRzOml9KT0+cChbImV4dGVuZCB0eXBlIixlLE8oImltcGxlbWVudHMgIixwKHQsIiAmICIpKSxwKG4sIiAiKSxlZShpKV0sIiAiKX0sSW50ZXJmYWNlVHlwZUV4dGVuc2lvbjp7bGVhdmU6KHtuYW1lOmUsaW50ZXJmYWNlczp0LGRpcmVjdGl2ZXM6bixmaWVsZHM6aX0pPT5wKFsiZXh0ZW5kIGludGVyZmFjZSIsZSxPKCJpbXBsZW1lbnRzICIscCh0LCIgJiAiKSkscChuLCIgIiksZWUoaSldLCIgIil9LFVuaW9uVHlwZUV4dGVuc2lvbjp7bGVhdmU6KHtuYW1lOmUsZGlyZWN0aXZlczp0LHR5cGVzOm59KT0+cChbImV4dGVuZCB1bmlvbiIsZSxwKHQsIiAiKSxPKCI9ICIscChuLCIgfCAiKSldLCIgIil9LEVudW1UeXBlRXh0ZW5zaW9uOntsZWF2ZTooe25hbWU6ZSxkaXJlY3RpdmVzOnQsdmFsdWVzOm59KT0+cChbImV4dGVuZCBlbnVtIixlLHAodCwiICIpLGVlKG4pXSwiICIpfSxJbnB1dE9iamVjdFR5cGVFeHRlbnNpb246e2xlYXZlOih7bmFtZTplLGRpcmVjdGl2ZXM6dCxmaWVsZHM6bn0pPT5wKFsiZXh0ZW5kIGlucHV0IixlLHAodCwiICIpLGVlKG4pXSwiICIpfX07ZnVuY3Rpb24gcChlLHQ9IiIpe3ZhciBuO3JldHVybihuPWU9PW51bGw/dm9pZCAwOmUuZmlsdGVyKGk9PmkpLmpvaW4odCkpIT09bnVsbCYmbiE9PXZvaWQgMD9uOiIifWZ1bmN0aW9uIGVlKGUpe3JldHVybiBPKGB7CmAsRGUocChlLGAKYCkpLGAKfWApfWZ1bmN0aW9uIE8oZSx0LG49IiIpe3JldHVybiB0IT1udWxsJiZ0IT09IiI/ZSt0K246IiJ9ZnVuY3Rpb24gRGUoZSl7cmV0dXJuIE8oIiAgIixlLnJlcGxhY2UoL1xuL2csYAogIGApKX1mdW5jdGlvbiBPdChlKXt2YXIgdDtyZXR1cm4odD1lPT1udWxsP3ZvaWQgMDplLnNvbWUobj0+bi5pbmNsdWRlcyhgCmApKSkhPT1udWxsJiZ0IT09dm9pZCAwP3Q6ITF9Y29uc3Qgd3Q9ZT0+e3ZhciBpLHI7bGV0IHQ7Y29uc3Qgbj1lLmRlZmluaXRpb25zLmZpbHRlcihzPT5zLmtpbmQ9PT0iT3BlcmF0aW9uRGVmaW5pdGlvbiIpO3JldHVybiBuLmxlbmd0aD09PTEmJih0PShyPShpPW5bMF0pPT1udWxsP3ZvaWQgMDppLm5hbWUpPT1udWxsP3ZvaWQgMDpyLnZhbHVlKSx0fSxKZT1lPT57aWYodHlwZW9mIGU9PSJzdHJpbmciKXtsZXQgbjt0cnl7Y29uc3QgaT1JdChlKTtuPXd0KGkpfWNhdGNoKGkpe31yZXR1cm57cXVlcnk6ZSxvcGVyYXRpb25OYW1lOm59fWNvbnN0IHQ9d3QoZSk7cmV0dXJue3F1ZXJ5OlVuKGUpLG9wZXJhdGlvbk5hbWU6dH19O2NsYXNzIGRlIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IodCxuKXtjb25zdCBpPWAke2RlLmV4dHJhY3RNZXNzYWdlKHQpfTogJHtKU09OLnN0cmluZ2lmeSh7cmVzcG9uc2U6dCxyZXF1ZXN0Om59KX1gO3N1cGVyKGkpLE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLGRlLnByb3RvdHlwZSksdGhpcy5yZXNwb25zZT10LHRoaXMucmVxdWVzdD1uLHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT09ImZ1bmN0aW9uIiYmRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyxkZSl9c3RhdGljIGV4dHJhY3RNZXNzYWdlKHQpe3ZhciBuLGkscjtyZXR1cm4ocj0oaT0obj10LmVycm9ycyk9PW51bGw/dm9pZCAwOm5bMF0pPT1udWxsP3ZvaWQgMDppLm1lc3NhZ2UpIT1udWxsP3I6YEdyYXBoUUwgRXJyb3IgKENvZGU6ICR7dC5zdGF0dXN9KWB9fXZhciBxbj10eXBlb2YgZ2xvYmFsVGhpcyE9InVuZGVmaW5lZCI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93IT0idW5kZWZpbmVkIj93aW5kb3c6dHlwZW9mIGdsb2JhbCE9InVuZGVmaW5lZCI/Z2xvYmFsOnR5cGVvZiBzZWxmIT0idW5kZWZpbmVkIj9zZWxmOnt9O2Z1bmN0aW9uIER0KGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCJkZWZhdWx0Iik/ZS5kZWZhdWx0OmV9dmFyIFFlPXtleHBvcnRzOnt9fTsoZnVuY3Rpb24oZSx0KXt2YXIgbj10eXBlb2Ygc2VsZiE9InVuZGVmaW5lZCI/c2VsZjpxbixpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcygpe3RoaXMuZmV0Y2g9ITEsdGhpcy5ET01FeGNlcHRpb249bi5ET01FeGNlcHRpb259cmV0dXJuIHMucHJvdG90eXBlPW4sbmV3IHN9KCk7KGZ1bmN0aW9uKHMpeyhmdW5jdGlvbihvKXt2YXIgYz17c2VhcmNoUGFyYW1zOiJVUkxTZWFyY2hQYXJhbXMiaW4gcyxpdGVyYWJsZToiU3ltYm9sImluIHMmJiJpdGVyYXRvciJpbiBTeW1ib2wsYmxvYjoiRmlsZVJlYWRlciJpbiBzJiYiQmxvYiJpbiBzJiZmdW5jdGlvbigpe3RyeXtyZXR1cm4gbmV3IEJsb2IsITB9Y2F0Y2goYSl7cmV0dXJuITF9fSgpLGZvcm1EYXRhOiJGb3JtRGF0YSJpbiBzLGFycmF5QnVmZmVyOiJBcnJheUJ1ZmZlciJpbiBzfTtmdW5jdGlvbiBmKGEpe3JldHVybiBhJiZEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihhKX1pZihjLmFycmF5QnVmZmVyKXZhciBkPVsiW29iamVjdCBJbnQ4QXJyYXldIiwiW29iamVjdCBVaW50OEFycmF5XSIsIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIiwiW29iamVjdCBJbnQxNkFycmF5XSIsIltvYmplY3QgVWludDE2QXJyYXldIiwiW29iamVjdCBJbnQzMkFycmF5XSIsIltvYmplY3QgVWludDMyQXJyYXldIiwiW29iamVjdCBGbG9hdDMyQXJyYXldIiwiW29iamVjdCBGbG9hdDY0QXJyYXldIl0sdT1BcnJheUJ1ZmZlci5pc1ZpZXd8fGZ1bmN0aW9uKGEpe3JldHVybiBhJiZkLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpKT4tMX07ZnVuY3Rpb24geShhKXtpZih0eXBlb2YgYSE9InN0cmluZyImJihhPVN0cmluZyhhKSksL1teYS16MC05XC0jJCUmJyorLl5fYHx+XS9pLnRlc3QoYSkpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUiKTtyZXR1cm4gYS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIHYoYSl7cmV0dXJuIHR5cGVvZiBhIT0ic3RyaW5nIiYmKGE9U3RyaW5nKGEpKSxhfWZ1bmN0aW9uIGIoYSl7dmFyIGg9e25leHQ6ZnVuY3Rpb24oKXt2YXIgXz1hLnNoaWZ0KCk7cmV0dXJue2RvbmU6Xz09PXZvaWQgMCx2YWx1ZTpffX19O3JldHVybiBjLml0ZXJhYmxlJiYoaFtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIGh9KSxofWZ1bmN0aW9uIG0oYSl7dGhpcy5tYXA9e30sYSBpbnN0YW5jZW9mIG0/YS5mb3JFYWNoKGZ1bmN0aW9uKGgsXyl7dGhpcy5hcHBlbmQoXyxoKX0sdGhpcyk6QXJyYXkuaXNBcnJheShhKT9hLmZvckVhY2goZnVuY3Rpb24oaCl7dGhpcy5hcHBlbmQoaFswXSxoWzFdKX0sdGhpcyk6YSYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYSkuZm9yRWFjaChmdW5jdGlvbihoKXt0aGlzLmFwcGVuZChoLGFbaF0pfSx0aGlzKX1tLnByb3RvdHlwZS5hcHBlbmQ9ZnVuY3Rpb24oYSxoKXthPXkoYSksaD12KGgpO3ZhciBfPXRoaXMubWFwW2FdO3RoaXMubWFwW2FdPV8/XysiLCAiK2g6aH0sbS5wcm90b3R5cGUuZGVsZXRlPWZ1bmN0aW9uKGEpe2RlbGV0ZSB0aGlzLm1hcFt5KGEpXX0sbS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiBhPXkoYSksdGhpcy5oYXMoYSk/dGhpcy5tYXBbYV06bnVsbH0sbS5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eSh5KGEpKX0sbS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsaCl7dGhpcy5tYXBbeShhKV09dihoKX0sbS5wcm90b3R5cGUuZm9yRWFjaD1mdW5jdGlvbihhLGgpe2Zvcih2YXIgXyBpbiB0aGlzLm1hcCl0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShfKSYmYS5jYWxsKGgsdGhpcy5tYXBbX10sXyx0aGlzKX0sbS5wcm90b3R5cGUua2V5cz1mdW5jdGlvbigpe3ZhciBhPVtdO3JldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24oaCxfKXthLnB1c2goXyl9KSxiKGEpfSxtLnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXt2YXIgYT1bXTtyZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGgpe2EucHVzaChoKX0pLGIoYSl9LG0ucHJvdG90eXBlLmVudHJpZXM9ZnVuY3Rpb24oKXt2YXIgYT1bXTtyZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGgsXyl7YS5wdXNoKFtfLGhdKX0pLGIoYSl9LGMuaXRlcmFibGUmJihtLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdPW0ucHJvdG90eXBlLmVudHJpZXMpO2Z1bmN0aW9uIE4oYSl7aWYoYS5ib2R5VXNlZClyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcigiQWxyZWFkeSByZWFkIikpO2EuYm9keVVzZWQ9ITB9ZnVuY3Rpb24gZyhhKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oaCxfKXthLm9ubG9hZD1mdW5jdGlvbigpe2goYS5yZXN1bHQpfSxhLm9uZXJyb3I9ZnVuY3Rpb24oKXtfKGEuZXJyb3IpfX0pfWZ1bmN0aW9uIEUoYSl7dmFyIGg9bmV3IEZpbGVSZWFkZXIsXz1nKGgpO3JldHVybiBoLnJlYWRBc0FycmF5QnVmZmVyKGEpLF99ZnVuY3Rpb24gQyhhKXt2YXIgaD1uZXcgRmlsZVJlYWRlcixfPWcoaCk7cmV0dXJuIGgucmVhZEFzVGV4dChhKSxffWZ1bmN0aW9uIHcoYSl7Zm9yKHZhciBoPW5ldyBVaW50OEFycmF5KGEpLF89bmV3IEFycmF5KGgubGVuZ3RoKSxBPTA7QTxoLmxlbmd0aDtBKyspX1tBXT1TdHJpbmcuZnJvbUNoYXJDb2RlKGhbQV0pO3JldHVybiBfLmpvaW4oIiIpfWZ1bmN0aW9uIFIoYSl7aWYoYS5zbGljZSlyZXR1cm4gYS5zbGljZSgwKTt2YXIgaD1uZXcgVWludDhBcnJheShhLmJ5dGVMZW5ndGgpO3JldHVybiBoLnNldChuZXcgVWludDhBcnJheShhKSksaC5idWZmZXJ9ZnVuY3Rpb24gJCgpe3JldHVybiB0aGlzLmJvZHlVc2VkPSExLHRoaXMuX2luaXRCb2R5PWZ1bmN0aW9uKGEpe3RoaXMuX2JvZHlJbml0PWEsYT90eXBlb2YgYT09InN0cmluZyI/dGhpcy5fYm9keVRleHQ9YTpjLmJsb2ImJkJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYSk/dGhpcy5fYm9keUJsb2I9YTpjLmZvcm1EYXRhJiZGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihhKT90aGlzLl9ib2R5Rm9ybURhdGE9YTpjLnNlYXJjaFBhcmFtcyYmVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGEpP3RoaXMuX2JvZHlUZXh0PWEudG9TdHJpbmcoKTpjLmFycmF5QnVmZmVyJiZjLmJsb2ImJmYoYSk/KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcj1SKGEuYnVmZmVyKSx0aGlzLl9ib2R5SW5pdD1uZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpOmMuYXJyYXlCdWZmZXImJihBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihhKXx8dShhKSk/dGhpcy5fYm9keUFycmF5QnVmZmVyPVIoYSk6dGhpcy5fYm9keVRleHQ9YT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk6dGhpcy5fYm9keVRleHQ9IiIsdGhpcy5oZWFkZXJzLmdldCgiY29udGVudC10eXBlIil8fCh0eXBlb2YgYT09InN0cmluZyI/dGhpcy5oZWFkZXJzLnNldCgiY29udGVudC10eXBlIiwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Iik6dGhpcy5fYm9keUJsb2ImJnRoaXMuX2JvZHlCbG9iLnR5cGU/dGhpcy5oZWFkZXJzLnNldCgiY29udGVudC10eXBlIix0aGlzLl9ib2R5QmxvYi50eXBlKTpjLnNlYXJjaFBhcmFtcyYmVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGEpJiZ0aGlzLmhlYWRlcnMuc2V0KCJjb250ZW50LXR5cGUiLCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCIpKX0sYy5ibG9iJiYodGhpcy5ibG9iPWZ1bmN0aW9uKCl7dmFyIGE9Tih0aGlzKTtpZihhKXJldHVybiBhO2lmKHRoaXMuX2JvZHlCbG9iKXJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpO2lmKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSk7aWYodGhpcy5fYm9keUZvcm1EYXRhKXRocm93IG5ldyBFcnJvcigiY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iIik7cmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSl9LHRoaXMuYXJyYXlCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYm9keUFycmF5QnVmZmVyP04odGhpcyl8fFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpOnRoaXMuYmxvYigpLnRoZW4oRSl9KSx0aGlzLnRleHQ9ZnVuY3Rpb24oKXt2YXIgYT1OKHRoaXMpO2lmKGEpcmV0dXJuIGE7aWYodGhpcy5fYm9keUJsb2IpcmV0dXJuIEModGhpcy5fYm9keUJsb2IpO2lmKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHcodGhpcy5fYm9keUFycmF5QnVmZmVyKSk7aWYodGhpcy5fYm9keUZvcm1EYXRhKXRocm93IG5ldyBFcnJvcigiY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0Iik7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dCl9LGMuZm9ybURhdGEmJih0aGlzLmZvcm1EYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oUyl9KSx0aGlzLmpzb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKX0sdGhpc312YXIgcT1bIkRFTEVURSIsIkdFVCIsIkhFQUQiLCJPUFRJT05TIiwiUE9TVCIsIlBVVCJdO2Z1bmN0aW9uIEIoYSl7dmFyIGg9YS50b1VwcGVyQ2FzZSgpO3JldHVybiBxLmluZGV4T2YoaCk+LTE/aDphfWZ1bmN0aW9uIEkoYSxoKXtoPWh8fHt9O3ZhciBfPWguYm9keTtpZihhIGluc3RhbmNlb2YgSSl7aWYoYS5ib2R5VXNlZCl0aHJvdyBuZXcgVHlwZUVycm9yKCJBbHJlYWR5IHJlYWQiKTt0aGlzLnVybD1hLnVybCx0aGlzLmNyZWRlbnRpYWxzPWEuY3JlZGVudGlhbHMsaC5oZWFkZXJzfHwodGhpcy5oZWFkZXJzPW5ldyBtKGEuaGVhZGVycykpLHRoaXMubWV0aG9kPWEubWV0aG9kLHRoaXMubW9kZT1hLm1vZGUsdGhpcy5zaWduYWw9YS5zaWduYWwsIV8mJmEuX2JvZHlJbml0IT1udWxsJiYoXz1hLl9ib2R5SW5pdCxhLmJvZHlVc2VkPSEwKX1lbHNlIHRoaXMudXJsPVN0cmluZyhhKTtpZih0aGlzLmNyZWRlbnRpYWxzPWguY3JlZGVudGlhbHN8fHRoaXMuY3JlZGVudGlhbHN8fCJzYW1lLW9yaWdpbiIsKGguaGVhZGVyc3x8IXRoaXMuaGVhZGVycykmJih0aGlzLmhlYWRlcnM9bmV3IG0oaC5oZWFkZXJzKSksdGhpcy5tZXRob2Q9QihoLm1ldGhvZHx8dGhpcy5tZXRob2R8fCJHRVQiKSx0aGlzLm1vZGU9aC5tb2RlfHx0aGlzLm1vZGV8fG51bGwsdGhpcy5zaWduYWw9aC5zaWduYWx8fHRoaXMuc2lnbmFsLHRoaXMucmVmZXJyZXI9bnVsbCwodGhpcy5tZXRob2Q9PT0iR0VUInx8dGhpcy5tZXRob2Q9PT0iSEVBRCIpJiZfKXRocm93IG5ldyBUeXBlRXJyb3IoIkJvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzIik7dGhpcy5faW5pdEJvZHkoXyl9SS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEkodGhpcyx7Ym9keTp0aGlzLl9ib2R5SW5pdH0pfTtmdW5jdGlvbiBTKGEpe3ZhciBoPW5ldyBGb3JtRGF0YTtyZXR1cm4gYS50cmltKCkuc3BsaXQoIiYiKS5mb3JFYWNoKGZ1bmN0aW9uKF8pe2lmKF8pe3ZhciBBPV8uc3BsaXQoIj0iKSxrPUEuc2hpZnQoKS5yZXBsYWNlKC9cKy9nLCIgIikseD1BLmpvaW4oIj0iKS5yZXBsYWNlKC9cKy9nLCIgIik7aC5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KGspLGRlY29kZVVSSUNvbXBvbmVudCh4KSl9fSksaH1mdW5jdGlvbiBqKGEpe3ZhciBoPW5ldyBtLF89YS5yZXBsYWNlKC9ccj9cbltcdCBdKy9nLCIgIik7cmV0dXJuIF8uc3BsaXQoL1xyP1xuLykuZm9yRWFjaChmdW5jdGlvbihBKXt2YXIgaz1BLnNwbGl0KCI6IikseD1rLnNoaWZ0KCkudHJpbSgpO2lmKHgpe3ZhciBjZT1rLmpvaW4oIjoiKS50cmltKCk7aC5hcHBlbmQoeCxjZSl9fSksaH0kLmNhbGwoSS5wcm90b3R5cGUpO2Z1bmN0aW9uIFUoYSxoKXtofHwoaD17fSksdGhpcy50eXBlPSJkZWZhdWx0Iix0aGlzLnN0YXR1cz1oLnN0YXR1cz09PXZvaWQgMD8yMDA6aC5zdGF0dXMsdGhpcy5vaz10aGlzLnN0YXR1cz49MjAwJiZ0aGlzLnN0YXR1czwzMDAsdGhpcy5zdGF0dXNUZXh0PSJzdGF0dXNUZXh0ImluIGg/aC5zdGF0dXNUZXh0OiJPSyIsdGhpcy5oZWFkZXJzPW5ldyBtKGguaGVhZGVycyksdGhpcy51cmw9aC51cmx8fCIiLHRoaXMuX2luaXRCb2R5KGEpfSQuY2FsbChVLnByb3RvdHlwZSksVS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFUodGhpcy5fYm9keUluaXQse3N0YXR1czp0aGlzLnN0YXR1cyxzdGF0dXNUZXh0OnRoaXMuc3RhdHVzVGV4dCxoZWFkZXJzOm5ldyBtKHRoaXMuaGVhZGVycyksdXJsOnRoaXMudXJsfSl9LFUuZXJyb3I9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVShudWxsLHtzdGF0dXM6MCxzdGF0dXNUZXh0OiIifSk7cmV0dXJuIGEudHlwZT0iZXJyb3IiLGF9O3ZhciB6PVszMDEsMzAyLDMwMywzMDcsMzA4XTtVLnJlZGlyZWN0PWZ1bmN0aW9uKGEsaCl7aWYoei5pbmRleE9mKGgpPT09LTEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkludmFsaWQgc3RhdHVzIGNvZGUiKTtyZXR1cm4gbmV3IFUobnVsbCx7c3RhdHVzOmgsaGVhZGVyczp7bG9jYXRpb246YX19KX0sby5ET01FeGNlcHRpb249cy5ET01FeGNlcHRpb247dHJ5e25ldyBvLkRPTUV4Y2VwdGlvbn1jYXRjaChhKXtvLkRPTUV4Y2VwdGlvbj1mdW5jdGlvbihoLF8pe3RoaXMubWVzc2FnZT1oLHRoaXMubmFtZT1fO3ZhciBBPUVycm9yKGgpO3RoaXMuc3RhY2s9QS5zdGFja30sby5ET01FeGNlcHRpb24ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSxvLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3I9by5ET01FeGNlcHRpb259ZnVuY3Rpb24gSyhhLGgpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihfLEEpe3ZhciBrPW5ldyBJKGEsaCk7aWYoay5zaWduYWwmJmsuc2lnbmFsLmFib3J0ZWQpcmV0dXJuIEEobmV3IG8uRE9NRXhjZXB0aW9uKCJBYm9ydGVkIiwiQWJvcnRFcnJvciIpKTt2YXIgeD1uZXcgWE1MSHR0cFJlcXVlc3Q7ZnVuY3Rpb24gY2UoKXt4LmFib3J0KCl9eC5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgSD17c3RhdHVzOnguc3RhdHVzLHN0YXR1c1RleHQ6eC5zdGF0dXNUZXh0LGhlYWRlcnM6aih4LmdldEFsbFJlc3BvbnNlSGVhZGVycygpfHwiIil9O0gudXJsPSJyZXNwb25zZVVSTCJpbiB4P3gucmVzcG9uc2VVUkw6SC5oZWFkZXJzLmdldCgiWC1SZXF1ZXN0LVVSTCIpO3ZhciBzZT0icmVzcG9uc2UiaW4geD94LnJlc3BvbnNlOngucmVzcG9uc2VUZXh0O18obmV3IFUoc2UsSCkpfSx4Lm9uZXJyb3I9ZnVuY3Rpb24oKXtBKG5ldyBUeXBlRXJyb3IoIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWQiKSl9LHgub250aW1lb3V0PWZ1bmN0aW9uKCl7QShuZXcgVHlwZUVycm9yKCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkIikpfSx4Lm9uYWJvcnQ9ZnVuY3Rpb24oKXtBKG5ldyBvLkRPTUV4Y2VwdGlvbigiQWJvcnRlZCIsIkFib3J0RXJyb3IiKSl9LHgub3BlbihrLm1ldGhvZCxrLnVybCwhMCksay5jcmVkZW50aWFscz09PSJpbmNsdWRlIj94LndpdGhDcmVkZW50aWFscz0hMDprLmNyZWRlbnRpYWxzPT09Im9taXQiJiYoeC53aXRoQ3JlZGVudGlhbHM9ITEpLCJyZXNwb25zZVR5cGUiaW4geCYmYy5ibG9iJiYoeC5yZXNwb25zZVR5cGU9ImJsb2IiKSxrLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihILHNlKXt4LnNldFJlcXVlc3RIZWFkZXIoc2UsSCl9KSxrLnNpZ25hbCYmKGsuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoImFib3J0IixjZSkseC5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXt4LnJlYWR5U3RhdGU9PT00JiZrLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCJhYm9ydCIsY2UpfSkseC5zZW5kKHR5cGVvZiBrLl9ib2R5SW5pdD09InVuZGVmaW5lZCI/bnVsbDprLl9ib2R5SW5pdCl9KX1yZXR1cm4gSy5wb2x5ZmlsbD0hMCxzLmZldGNofHwocy5mZXRjaD1LLHMuSGVhZGVycz1tLHMuUmVxdWVzdD1JLHMuUmVzcG9uc2U9VSksby5IZWFkZXJzPW0sby5SZXF1ZXN0PUksby5SZXNwb25zZT1VLG8uZmV0Y2g9SyxPYmplY3QuZGVmaW5lUHJvcGVydHkobywiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksb30pKHt9KX0pKGkpLGkuZmV0Y2gucG9ueWZpbGw9ITAsZGVsZXRlIGkuZmV0Y2gucG9seWZpbGw7dmFyIHI9aTt0PXIuZmV0Y2gsdC5kZWZhdWx0PXIuZmV0Y2gsdC5mZXRjaD1yLmZldGNoLHQuSGVhZGVycz1yLkhlYWRlcnMsdC5SZXF1ZXN0PXIuUmVxdWVzdCx0LlJlc3BvbnNlPXIuUmVzcG9uc2UsZS5leHBvcnRzPXR9KShRZSxRZS5leHBvcnRzKTt2YXIgQ2U9UWUuZXhwb3J0cyxrZT1EdChDZSksR249Rih7X19wcm90b19fOm51bGwsZGVmYXVsdDprZX0sW0NlXSk7Y29uc3QgcGU9ZT0+e2xldCB0PXt9O3JldHVybiBlJiYodHlwZW9mIEhlYWRlcnMhPSJ1bmRlZmluZWQiJiZlIGluc3RhbmNlb2YgSGVhZGVyc3x8R24mJkNlLkhlYWRlcnMmJmUgaW5zdGFuY2VvZiBDZS5IZWFkZXJzP3Q9WChlKTpBcnJheS5pc0FycmF5KGUpP2UuZm9yRWFjaCgoW24saV0pPT57biYmaSE9PXZvaWQgMCYmKHRbbl09aSl9KTp0PWUpLHR9LEN0PWU9PmUucmVwbGFjZSgvKFtccyxdfCNbXlxuXHJdKykrL2csIiAiKS50cmltKCksem49ZT0+e2lmKCFBcnJheS5pc0FycmF5KGUucXVlcnkpKXtjb25zdCBpPWUscj1bYHF1ZXJ5PSR7ZW5jb2RlVVJJQ29tcG9uZW50KEN0KGkucXVlcnkpKX1gXTtyZXR1cm4gZS52YXJpYWJsZXMmJnIucHVzaChgdmFyaWFibGVzPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGkuanNvblNlcmlhbGl6ZXIuc3RyaW5naWZ5KGkudmFyaWFibGVzKSl9YCksaS5vcGVyYXRpb25OYW1lJiZyLnB1c2goYG9wZXJhdGlvbk5hbWU9JHtlbmNvZGVVUklDb21wb25lbnQoaS5vcGVyYXRpb25OYW1lKX1gKSxyLmpvaW4oIiYiKX1pZih0eXBlb2YgZS52YXJpYWJsZXMhPSJ1bmRlZmluZWQiJiYhQXJyYXkuaXNBcnJheShlLnZhcmlhYmxlcykpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgY3JlYXRlIHF1ZXJ5IHdpdGggZ2l2ZW4gdmFyaWFibGUgdHlwZSwgYXJyYXkgZXhwZWN0ZWQiKTtjb25zdCB0PWUsbj1lLnF1ZXJ5LnJlZHVjZSgoaSxyLHMpPT4oaS5wdXNoKHtxdWVyeTpDdChyKSx2YXJpYWJsZXM6dC52YXJpYWJsZXM/dC5qc29uU2VyaWFsaXplci5zdHJpbmdpZnkodC52YXJpYWJsZXNbc10pOnZvaWQgMH0pLGkpLFtdKTtyZXR1cm5gcXVlcnk9JHtlbmNvZGVVUklDb21wb25lbnQodC5qc29uU2VyaWFsaXplci5zdHJpbmdpZnkobikpfWB9LEhuPWU9PnQ9PlEodGhpcyxudWxsLGZ1bmN0aW9uKigpe3ZhciBOO2NvbnN0e3VybDpuLHF1ZXJ5OmksdmFyaWFibGVzOnIsb3BlcmF0aW9uTmFtZTpzLGZldGNoOm8sZmV0Y2hPcHRpb25zOmMsbWlkZGxld2FyZTpmfT10LGQ9RCh7fSx0LmhlYWRlcnMpO2xldCB1PSIiLHk7ZT09PSJQT1NUIj8oeT1KbihpLHIscyxjLmpzb25TZXJpYWxpemVyKSx0eXBlb2YgeT09InN0cmluZyImJihkWyJDb250ZW50LVR5cGUiXT0iYXBwbGljYXRpb24vanNvbiIpKTp1PXpuKHtxdWVyeTppLHZhcmlhYmxlczpyLG9wZXJhdGlvbk5hbWU6cyxqc29uU2VyaWFsaXplcjooTj1jLmpzb25TZXJpYWxpemVyKSE9bnVsbD9OOlB9KTtjb25zdCB2PUQoe21ldGhvZDplLGhlYWRlcnM6ZCxib2R5Onl9LGMpO2xldCBiPW4sbT12O2lmKGYpe2NvbnN0IGc9eWllbGQgUHJvbWlzZS5yZXNvbHZlKGYoQmUoRCh7fSx2KSx7dXJsOm4sb3BlcmF0aW9uTmFtZTpzLHZhcmlhYmxlczpyfSkpKSx7dXJsOkN9PWcsdz12ZShnLFsidXJsIl0pO2I9QyxtPXd9cmV0dXJuIHUmJihiPWAke2J9PyR7dX1gKSx5aWVsZCBvKGIsbSl9KTtjbGFzcyBZbntjb25zdHJ1Y3Rvcih0LG49e30pe3RoaXMudXJsPXQsdGhpcy5yZXF1ZXN0Q29uZmlnPW4sdGhpcy5yYXdSZXF1ZXN0PSguLi5pKT0+USh0aGlzLG51bGwsZnVuY3Rpb24qKCl7Y29uc3RbcixzLG9dPWksYz1VZShyLHMsbyksZz10aGlzLnJlcXVlc3RDb25maWcse2hlYWRlcnM6ZixmZXRjaDpkPWtlLG1ldGhvZDp1PSJQT1NUIixyZXF1ZXN0TWlkZGxld2FyZTp5LHJlc3BvbnNlTWlkZGxld2FyZTp2fT1nLGI9dmUoZyxbImhlYWRlcnMiLCJmZXRjaCIsIm1ldGhvZCIsInJlcXVlc3RNaWRkbGV3YXJlIiwicmVzcG9uc2VNaWRkbGV3YXJlIl0pLHt1cmw6bX09dGhpcztjLnNpZ25hbCE9PXZvaWQgMCYmKGIuc2lnbmFsPWMuc2lnbmFsKTtjb25zdHtvcGVyYXRpb25OYW1lOk59PUplKGMucXVlcnkpO3JldHVybiBYZSh7dXJsOm0scXVlcnk6Yy5xdWVyeSx2YXJpYWJsZXM6Yy52YXJpYWJsZXMsaGVhZGVyczpEKEQoe30scGUoV2UoZikpKSxwZShjLnJlcXVlc3RIZWFkZXJzKSksb3BlcmF0aW9uTmFtZTpOLGZldGNoOmQsbWV0aG9kOnUsZmV0Y2hPcHRpb25zOmIsbWlkZGxld2FyZTp5fSkudGhlbihFPT4odiYmdihFKSxFKSkuY2F0Y2goRT0+e3Rocm93IHYmJnYoRSksRX0pfSl9cmVxdWVzdCh0LC4uLm4pe3JldHVybiBRKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtjb25zdFtpLHJdPW4scz1JZSh0LGksciksTj10aGlzLnJlcXVlc3RDb25maWcse2hlYWRlcnM6byxmZXRjaDpjPWtlLG1ldGhvZDpmPSJQT1NUIixyZXF1ZXN0TWlkZGxld2FyZTpkLHJlc3BvbnNlTWlkZGxld2FyZTp1fT1OLHk9dmUoTixbImhlYWRlcnMiLCJmZXRjaCIsIm1ldGhvZCIsInJlcXVlc3RNaWRkbGV3YXJlIiwicmVzcG9uc2VNaWRkbGV3YXJlIl0pLHt1cmw6dn09dGhpcztzLnNpZ25hbCE9PXZvaWQgMCYmKHkuc2lnbmFsPXMuc2lnbmFsKTtjb25zdHtxdWVyeTpiLG9wZXJhdGlvbk5hbWU6bX09SmUocy5kb2N1bWVudCk7cmV0dXJuIFhlKHt1cmw6dixxdWVyeTpiLHZhcmlhYmxlczpzLnZhcmlhYmxlcyxoZWFkZXJzOkQoRCh7fSxwZShXZShvKSkpLHBlKHMucmVxdWVzdEhlYWRlcnMpKSxvcGVyYXRpb25OYW1lOm0sZmV0Y2g6YyxtZXRob2Q6ZixmZXRjaE9wdGlvbnM6eSxtaWRkbGV3YXJlOmR9KS50aGVuKGc9Pih1JiZ1KGcpLGcuZGF0YSkpLmNhdGNoKGc9Pnt0aHJvdyB1JiZ1KGcpLGd9KX0pfWJhdGNoUmVxdWVzdHModCxuKXt2YXIgZDtjb25zdCBpPVZlKHQsbiksZj10aGlzLnJlcXVlc3RDb25maWcse2hlYWRlcnM6cn09ZixzPXZlKGYsWyJoZWFkZXJzIl0pO2kuc2lnbmFsIT09dm9pZCAwJiYocy5zaWduYWw9aS5zaWduYWwpO2NvbnN0IG89aS5kb2N1bWVudHMubWFwKCh7ZG9jdW1lbnQ6dX0pPT5KZSh1KS5xdWVyeSksYz1pLmRvY3VtZW50cy5tYXAoKHt2YXJpYWJsZXM6dX0pPT51KTtyZXR1cm4gWGUoe3VybDp0aGlzLnVybCxxdWVyeTpvLHZhcmlhYmxlczpjLGhlYWRlcnM6RChEKHt9LHBlKFdlKHIpKSkscGUoaS5yZXF1ZXN0SGVhZGVycykpLG9wZXJhdGlvbk5hbWU6dm9pZCAwLGZldGNoOihkPXRoaXMucmVxdWVzdENvbmZpZy5mZXRjaCkhPW51bGw/ZDprZSxtZXRob2Q6dGhpcy5yZXF1ZXN0Q29uZmlnLm1ldGhvZHx8IlBPU1QiLGZldGNoT3B0aW9uczpzLG1pZGRsZXdhcmU6dGhpcy5yZXF1ZXN0Q29uZmlnLnJlcXVlc3RNaWRkbGV3YXJlfSkudGhlbih1PT4odGhpcy5yZXF1ZXN0Q29uZmlnLnJlc3BvbnNlTWlkZGxld2FyZSYmdGhpcy5yZXF1ZXN0Q29uZmlnLnJlc3BvbnNlTWlkZGxld2FyZSh1KSx1LmRhdGEpKS5jYXRjaCh1PT57dGhyb3cgdGhpcy5yZXF1ZXN0Q29uZmlnLnJlc3BvbnNlTWlkZGxld2FyZSYmdGhpcy5yZXF1ZXN0Q29uZmlnLnJlc3BvbnNlTWlkZGxld2FyZSh1KSx1fSl9c2V0SGVhZGVycyh0KXtyZXR1cm4gdGhpcy5yZXF1ZXN0Q29uZmlnLmhlYWRlcnM9dCx0aGlzfXNldEhlYWRlcih0LG4pe2NvbnN0e2hlYWRlcnM6aX09dGhpcy5yZXF1ZXN0Q29uZmlnO3JldHVybiBpP2lbdF09bjp0aGlzLnJlcXVlc3RDb25maWcuaGVhZGVycz17W3RdOm59LHRoaXN9c2V0RW5kcG9pbnQodCl7cmV0dXJuIHRoaXMudXJsPXQsdGhpc319Y29uc3QgWGU9ZT0+USh0aGlzLG51bGwsZnVuY3Rpb24qKCl7dmFyIHUseTtjb25zdHtxdWVyeTp0LHZhcmlhYmxlczpuLGZldGNoT3B0aW9uczppfT1lLHI9SG4oTSgodT1lLm1ldGhvZCkhPW51bGw/dToicG9zdCIpKSxzPUFycmF5LmlzQXJyYXkoZS5xdWVyeSksbz15aWVsZCByKGUpLGM9eWllbGQgUW4obywoeT1pLmpzb25TZXJpYWxpemVyKSE9bnVsbD95OlApLGY9QXJyYXkuaXNBcnJheShjKT8hYy5zb21lKCh7ZGF0YTpifSk9PiFiKTohIWMuZGF0YSxkPUFycmF5LmlzQXJyYXkoYyl8fCFjLmVycm9yc3x8QXJyYXkuaXNBcnJheShjLmVycm9ycykmJiFjLmVycm9ycy5sZW5ndGh8fGkuZXJyb3JQb2xpY3k9PT0iYWxsInx8aS5lcnJvclBvbGljeT09PSJpZ25vcmUiO2lmKG8ub2smJmQmJmYpe2NvbnN0IHY9KEFycmF5LmlzQXJyYXkoYyksYykse2Vycm9yczpifT12LG09dmUodixbImVycm9ycyJdKSxOPWkuZXJyb3JQb2xpY3k9PT0iaWdub3JlIj9tOmM7cmV0dXJuIEJlKEQoe30scz97ZGF0YTpOfTpOKSx7aGVhZGVyczpvLmhlYWRlcnMsc3RhdHVzOm8uc3RhdHVzfSl9ZWxzZXtjb25zdCBiPXR5cGVvZiBjPT0ic3RyaW5nIj97ZXJyb3I6Y306Yzt0aHJvdyBuZXcgZGUoQmUoRCh7fSxiKSx7c3RhdHVzOm8uc3RhdHVzLGhlYWRlcnM6by5oZWFkZXJzfSkse3F1ZXJ5OnQsdmFyaWFibGVzOm59KX19KSxKbj0oZSx0LG4saSk9Pntjb25zdCByPWkhPW51bGw/aTpQO2lmKCFBcnJheS5pc0FycmF5KGUpKXJldHVybiByLnN0cmluZ2lmeSh7cXVlcnk6ZSx2YXJpYWJsZXM6dCxvcGVyYXRpb25OYW1lOm59KTtpZih0eXBlb2YgdCE9InVuZGVmaW5lZCImJiFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBFcnJvcigiQ2Fubm90IGNyZWF0ZSByZXF1ZXN0IGJvZHkgd2l0aCBnaXZlbiB2YXJpYWJsZSB0eXBlLCBhcnJheSBleHBlY3RlZCIpO2NvbnN0IHM9ZS5yZWR1Y2UoKG8sYyxmKT0+KG8ucHVzaCh7cXVlcnk6Yyx2YXJpYWJsZXM6dD90W2ZdOnZvaWQgMH0pLG8pLFtdKTtyZXR1cm4gci5zdHJpbmdpZnkocyl9LFFuPShlLHQpPT5RKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtsZXQgbjtyZXR1cm4gZS5oZWFkZXJzLmZvckVhY2goKGkscik9PntyLnRvTG93ZXJDYXNlKCk9PT0iY29udGVudC10eXBlIiYmKG49aSl9KSxuJiYobi50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoImFwcGxpY2F0aW9uL2pzb24iKXx8bi50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoImFwcGxpY2F0aW9uL2dyYXBocWwranNvbiIpfHxuLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgiYXBwbGljYXRpb24vZ3JhcGhxbC1yZXNwb25zZStqc29uIikpP3QucGFyc2UoeWllbGQgZS50ZXh0KCkpOmUudGV4dCgpfSksV2U9ZT0+dHlwZW9mIGU9PSJmdW5jdGlvbiI/ZSgpOmU7dmFyIFplPXtleHBvcnRzOnt9fTsoZnVuY3Rpb24oZSx0KXt0PWUuZXhwb3J0cz1uLHQuZ2V0U2VyaWFsaXplPWk7ZnVuY3Rpb24gbihyLHMsbyxjKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkocixpKHMsYyksbyl9ZnVuY3Rpb24gaShyLHMpe3ZhciBvPVtdLGM9W107cmV0dXJuIHM9PW51bGwmJihzPWZ1bmN0aW9uKGYsZCl7cmV0dXJuIG9bMF09PT1kPyJbQ2lyY3VsYXIgfl0iOiJbQ2lyY3VsYXIgfi4iK2Muc2xpY2UoMCxvLmluZGV4T2YoZCkpLmpvaW4oIi4iKSsiXSJ9KSxmdW5jdGlvbihmLGQpe2lmKG8ubGVuZ3RoPjApe3ZhciB1PW8uaW5kZXhPZih0aGlzKTt+dT9vLnNwbGljZSh1KzEpOm8ucHVzaCh0aGlzKSx+dT9jLnNwbGljZSh1LDEvMCxmKTpjLnB1c2goZiksfm8uaW5kZXhPZihkKSYmKGQ9cy5jYWxsKHRoaXMsZixkKSl9ZWxzZSBvLnB1c2goZCk7cmV0dXJuIHI9PW51bGw/ZDpyLmNhbGwodGhpcyxmLGQpfX19KShaZSxaZS5leHBvcnRzKTt2YXIgWG49WmUuZXhwb3J0cyxtZT1EdChYbik7Y29uc3Qga3Q9MWUzKjE1O3ZhciBSZT1mdW5jdGlvbigpe3JldHVybiBSZT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIG4saT0xLHI9YXJndW1lbnRzLmxlbmd0aDtpPHI7aSsrKXtuPWFyZ3VtZW50c1tpXTtmb3IodmFyIHMgaW4gbilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixzKSYmKHRbc109bltzXSl9cmV0dXJuIHR9LFJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dHlwZW9mIFN1cHByZXNzZWRFcnJvcj09ImZ1bmN0aW9uIiYmU3VwcHJlc3NlZEVycm9yO3ZhciBQZT1uZXcgTWFwLEtlPW5ldyBNYXAsUnQ9ITAsTGU9ITE7ZnVuY3Rpb24gUHQoZSl7cmV0dXJuIGUucmVwbGFjZSgvW1xzLF0rL2csIiAiKS50cmltKCl9ZnVuY3Rpb24gV24oZSl7cmV0dXJuIFB0KGUuc291cmNlLmJvZHkuc3Vic3RyaW5nKGUuc3RhcnQsZS5lbmQpKX1mdW5jdGlvbiBabihlKXt2YXIgdD1uZXcgU2V0LG49W107cmV0dXJuIGUuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpKXtpZihpLmtpbmQ9PT0iRnJhZ21lbnREZWZpbml0aW9uIil7dmFyIHI9aS5uYW1lLnZhbHVlLHM9V24oaS5sb2MpLG89S2UuZ2V0KHIpO28mJiFvLmhhcyhzKT9SdCYmY29uc29sZS53YXJuKCJXYXJuaW5nOiBmcmFnbWVudCB3aXRoIG5hbWUgIityK2AgYWxyZWFkeSBleGlzdHMuCmdyYXBocWwtdGFnIGVuZm9yY2VzIGFsbCBmcmFnbWVudCBuYW1lcyBhY3Jvc3MgeW91ciBhcHBsaWNhdGlvbiB0byBiZSB1bmlxdWU7IHJlYWQgbW9yZSBhYm91dAp0aGlzIGluIHRoZSBkb2NzOiBodHRwOi8vZGV2LmFwb2xsb2RhdGEuY29tL2NvcmUvZnJhZ21lbnRzLmh0bWwjdW5pcXVlLW5hbWVzYCk6b3x8S2Uuc2V0KHIsbz1uZXcgU2V0KSxvLmFkZChzKSx0LmhhcyhzKXx8KHQuYWRkKHMpLG4ucHVzaChpKSl9ZWxzZSBuLnB1c2goaSl9KSxSZShSZSh7fSxlKSx7ZGVmaW5pdGlvbnM6bn0pfWZ1bmN0aW9uIEtuKGUpe3ZhciB0PW5ldyBTZXQoZS5kZWZpbml0aW9ucyk7dC5mb3JFYWNoKGZ1bmN0aW9uKGkpe2kubG9jJiZkZWxldGUgaS5sb2MsT2JqZWN0LmtleXMoaSkuZm9yRWFjaChmdW5jdGlvbihyKXt2YXIgcz1pW3JdO3MmJnR5cGVvZiBzPT0ib2JqZWN0IiYmdC5hZGQocyl9KX0pO3ZhciBuPWUubG9jO3JldHVybiBuJiYoZGVsZXRlIG4uc3RhcnRUb2tlbixkZWxldGUgbi5lbmRUb2tlbiksZX1mdW5jdGlvbiBlcihlKXt2YXIgdD1QdChlKTtpZighUGUuaGFzKHQpKXt2YXIgbj1JdChlLHtleHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlczpMZSxhbGxvd0xlZ2FjeUZyYWdtZW50VmFyaWFibGVzOkxlfSk7aWYoIW58fG4ua2luZCE9PSJEb2N1bWVudCIpdGhyb3cgbmV3IEVycm9yKCJOb3QgYSB2YWxpZCBHcmFwaFFMIGRvY3VtZW50LiIpO1BlLnNldCh0LEtuKFpuKG4pKSl9cmV0dXJuIFBlLmdldCh0KX1mdW5jdGlvbiBKKGUpe2Zvcih2YXIgdD1bXSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0W24tMV09YXJndW1lbnRzW25dO3R5cGVvZiBlPT0ic3RyaW5nIiYmKGU9W2VdKTt2YXIgaT1lWzBdO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24ocixzKXtyJiZyLmtpbmQ9PT0iRG9jdW1lbnQiP2krPXIubG9jLnNvdXJjZS5ib2R5OmkrPXIsaSs9ZVtzKzFdfSksZXIoaSl9ZnVuY3Rpb24gdHIoKXtQZS5jbGVhcigpLEtlLmNsZWFyKCl9ZnVuY3Rpb24gbnIoKXtSdD0hMX1mdW5jdGlvbiBycigpe0xlPSEwfWZ1bmN0aW9uIGlyKCl7TGU9ITF9dmFyIGJlPXtncWw6SixyZXNldENhY2hlczp0cixkaXNhYmxlRnJhZ21lbnRXYXJuaW5nczpucixlbmFibGVFeHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlczpycixkaXNhYmxlRXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXM6aXJ9OyhmdW5jdGlvbihlKXtlLmdxbD1iZS5ncWwsZS5yZXNldENhY2hlcz1iZS5yZXNldENhY2hlcyxlLmRpc2FibGVGcmFnbWVudFdhcm5pbmdzPWJlLmRpc2FibGVGcmFnbWVudFdhcm5pbmdzLGUuZW5hYmxlRXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXM9YmUuZW5hYmxlRXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXMsZS5kaXNhYmxlRXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXM9YmUuZGlzYWJsZUV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzfSkoSnx8KEo9e30pKSxKLmRlZmF1bHQ9Sjtjb25zdCBMdD1KYAoJZnJhZ21lbnQgTWF0Y2hQYXJ0cyBvbiBNYXRjaENvbmZpZyB7CgkJcmVnZXhWYWx1ZQoJCW1hdGNoVmFsdWUKCX0KYCxzcj1KYAoJbXV0YXRpb24gUHVzaFBheWxvYWQoCgkJJHNlc3Npb25fc2VjdXJlX2lkOiBTdHJpbmchCgkJJHBheWxvYWRfaWQ6IElEIQoJCSRldmVudHM6IFJlcGxheUV2ZW50c0lucHV0IQoJCSRtZXNzYWdlczogU3RyaW5nIQoJCSRyZXNvdXJjZXM6IFN0cmluZyEKCQkkd2ViX3NvY2tldF9ldmVudHM6IFN0cmluZyEKCQkkZXJyb3JzOiBbRXJyb3JPYmplY3RJbnB1dF0hCgkJJGlzX2JlYWNvbjogQm9vbGVhbgoJCSRoYXNfc2Vzc2lvbl91bmxvYWRlZDogQm9vbGVhbgoJCSRoaWdobGlnaHRfbG9nczogU3RyaW5nCgkpIHsKCQlwdXNoUGF5bG9hZCgKCQkJc2Vzc2lvbl9zZWN1cmVfaWQ6ICRzZXNzaW9uX3NlY3VyZV9pZAoJCQlwYXlsb2FkX2lkOiAkcGF5bG9hZF9pZAoJCQlldmVudHM6ICRldmVudHMKCQkJbWVzc2FnZXM6ICRtZXNzYWdlcwoJCQlyZXNvdXJjZXM6ICRyZXNvdXJjZXMKCQkJd2ViX3NvY2tldF9ldmVudHM6ICR3ZWJfc29ja2V0X2V2ZW50cwoJCQllcnJvcnM6ICRlcnJvcnMKCQkJaXNfYmVhY29uOiAkaXNfYmVhY29uCgkJCWhhc19zZXNzaW9uX3VubG9hZGVkOiAkaGFzX3Nlc3Npb25fdW5sb2FkZWQKCQkJaGlnaGxpZ2h0X2xvZ3M6ICRoaWdobGlnaHRfbG9ncwoJCSkKCX0KYCxvcj1KYAoJbXV0YXRpb24gUHVzaFNlc3Npb25FdmVudHMoCgkJJHNlc3Npb25fc2VjdXJlX2lkOiBTdHJpbmchCgkJJHBheWxvYWRfaWQ6IEludDY0SUQhCgkJJGRhdGE6IFN0cmluZyEKCSkgewoJCXB1c2hTZXNzaW9uRXZlbnRzKAoJCQlzZXNzaW9uX3NlY3VyZV9pZDogJHNlc3Npb25fc2VjdXJlX2lkCgkJCXBheWxvYWRfaWQ6ICRwYXlsb2FkX2lkCgkJCWRhdGE6ICRkYXRhCgkJKQoJfQpgLGFyPUpgCgltdXRhdGlvbiBpZGVudGlmeVNlc3Npb24oCgkJJHNlc3Npb25fc2VjdXJlX2lkOiBTdHJpbmchCgkJJHVzZXJfaWRlbnRpZmllcjogU3RyaW5nIQoJCSR1c2VyX29iamVjdDogQW55CgkpIHsKCQlpZGVudGlmeVNlc3Npb24oCgkJCXNlc3Npb25fc2VjdXJlX2lkOiAkc2Vzc2lvbl9zZWN1cmVfaWQKCQkJdXNlcl9pZGVudGlmaWVyOiAkdXNlcl9pZGVudGlmaWVyCgkJCXVzZXJfb2JqZWN0OiAkdXNlcl9vYmplY3QKCQkpCgl9CmAsY3I9SmAKCW11dGF0aW9uIGFkZFNlc3Npb25Qcm9wZXJ0aWVzKAoJCSRzZXNzaW9uX3NlY3VyZV9pZDogU3RyaW5nIQoJCSRwcm9wZXJ0aWVzX29iamVjdDogQW55CgkpIHsKCQlhZGRTZXNzaW9uUHJvcGVydGllcygKCQkJc2Vzc2lvbl9zZWN1cmVfaWQ6ICRzZXNzaW9uX3NlY3VyZV9pZAoJCQlwcm9wZXJ0aWVzX29iamVjdDogJHByb3BlcnRpZXNfb2JqZWN0CgkJKQoJfQpgLHVyPUpgCgltdXRhdGlvbiBwdXNoTWV0cmljcygkbWV0cmljczogW01ldHJpY0lucHV0XSEpIHsKCQlwdXNoTWV0cmljcyhtZXRyaWNzOiAkbWV0cmljcykKCX0KYCxscj1KYAoJbXV0YXRpb24gYWRkU2Vzc2lvbkZlZWRiYWNrKAoJCSRzZXNzaW9uX3NlY3VyZV9pZDogU3RyaW5nIQoJCSR1c2VyX25hbWU6IFN0cmluZwoJCSR1c2VyX2VtYWlsOiBTdHJpbmcKCQkkdmVyYmF0aW06IFN0cmluZyEKCQkkdGltZXN0YW1wOiBUaW1lc3RhbXAhCgkpIHsKCQlhZGRTZXNzaW9uRmVlZGJhY2soCgkJCXNlc3Npb25fc2VjdXJlX2lkOiAkc2Vzc2lvbl9zZWN1cmVfaWQKCQkJdXNlcl9uYW1lOiAkdXNlcl9uYW1lCgkJCXVzZXJfZW1haWw6ICR1c2VyX2VtYWlsCgkJCXZlcmJhdGltOiAkdmVyYmF0aW0KCQkJdGltZXN0YW1wOiAkdGltZXN0YW1wCgkJKQoJfQpgLGZyPUpgCgltdXRhdGlvbiBpbml0aWFsaXplU2Vzc2lvbigKCQkkc2Vzc2lvbl9zZWN1cmVfaWQ6IFN0cmluZyEKCQkkc2Vzc2lvbl9rZXk6IFN0cmluZwoJCSRvcmdhbml6YXRpb25fdmVyYm9zZV9pZDogU3RyaW5nIQoJCSRlbmFibGVfc3RyaWN0X3ByaXZhY3k6IEJvb2xlYW4hCgkJJHByaXZhY3lfc2V0dGluZzogU3RyaW5nIQoJCSRlbmFibGVfcmVjb3JkaW5nX25ldHdvcmtfY29udGVudHM6IEJvb2xlYW4hCgkJJGNsaWVudFZlcnNpb246IFN0cmluZyEKCQkkZmlyc3Rsb2FkVmVyc2lvbjogU3RyaW5nIQoJCSRjbGllbnRDb25maWc6IFN0cmluZyEKCQkkZW52aXJvbm1lbnQ6IFN0cmluZyEKCQkkaWQ6IFN0cmluZyEKCQkkYXBwVmVyc2lvbjogU3RyaW5nCgkJJHNlcnZpY2VOYW1lOiBTdHJpbmchCgkJJGNsaWVudF9pZDogU3RyaW5nIQoJCSRuZXR3b3JrX3JlY29yZGluZ19kb21haW5zOiBbU3RyaW5nIV0KCQkkZGlzYWJsZV9zZXNzaW9uX3JlY29yZGluZzogQm9vbGVhbgoJKSB7CgkJaW5pdGlhbGl6ZVNlc3Npb24oCgkJCXNlc3Npb25fc2VjdXJlX2lkOiAkc2Vzc2lvbl9zZWN1cmVfaWQKCQkJc2Vzc2lvbl9rZXk6ICRzZXNzaW9uX2tleQoJCQlvcmdhbml6YXRpb25fdmVyYm9zZV9pZDogJG9yZ2FuaXphdGlvbl92ZXJib3NlX2lkCgkJCWVuYWJsZV9zdHJpY3RfcHJpdmFjeTogJGVuYWJsZV9zdHJpY3RfcHJpdmFjeQoJCQllbmFibGVfcmVjb3JkaW5nX25ldHdvcmtfY29udGVudHM6ICRlbmFibGVfcmVjb3JkaW5nX25ldHdvcmtfY29udGVudHMKCQkJY2xpZW50VmVyc2lvbjogJGNsaWVudFZlcnNpb24KCQkJZmlyc3Rsb2FkVmVyc2lvbjogJGZpcnN0bG9hZFZlcnNpb24KCQkJY2xpZW50Q29uZmlnOiAkY2xpZW50Q29uZmlnCgkJCWVudmlyb25tZW50OiAkZW52aXJvbm1lbnQKCQkJYXBwVmVyc2lvbjogJGFwcFZlcnNpb24KCQkJc2VydmljZU5hbWU6ICRzZXJ2aWNlTmFtZQoJCQlmaW5nZXJwcmludDogJGlkCgkJCWNsaWVudF9pZDogJGNsaWVudF9pZAoJCQluZXR3b3JrX3JlY29yZGluZ19kb21haW5zOiAkbmV0d29ya19yZWNvcmRpbmdfZG9tYWlucwoJCQlkaXNhYmxlX3Nlc3Npb25fcmVjb3JkaW5nOiAkZGlzYWJsZV9zZXNzaW9uX3JlY29yZGluZwoJCQlwcml2YWN5X3NldHRpbmc6ICRwcml2YWN5X3NldHRpbmcKCQkpIHsKCQkJc2VjdXJlX2lkCgkJCXByb2plY3RfaWQKCQkJc2FtcGxpbmcgewoJCQkJc3BhbnMgewoJCQkJCW5hbWUgewoJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJfQoJCQkJCWF0dHJpYnV0ZXMgewoJCQkJCQlrZXkgewoJCQkJCQkJLi4uTWF0Y2hQYXJ0cwoJCQkJCQl9CgkJCQkJCWF0dHJpYnV0ZSB7CgkJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJCX0KCQkJCQl9CgkJCQkJZXZlbnRzIHsKCQkJCQkJbmFtZSB7CgkJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJCX0KCQkJCQkJYXR0cmlidXRlcyB7CgkJCQkJCQlrZXkgewoJCQkJCQkJCS4uLk1hdGNoUGFydHMKCQkJCQkJCX0KCQkJCQkJCWF0dHJpYnV0ZSB7CgkJCQkJCQkJLi4uTWF0Y2hQYXJ0cwoJCQkJCQkJfQoJCQkJCQl9CgkJCQkJfQoJCQkJCXNhbXBsaW5nUmF0aW8KCQkJCX0KCQkJCWxvZ3MgewoJCQkJCW1lc3NhZ2UgewoJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJfQoJCQkJCXNldmVyaXR5VGV4dCB7CgkJCQkJCS4uLk1hdGNoUGFydHMKCQkJCQl9CgkJCQkJYXR0cmlidXRlcyB7CgkJCQkJCWtleSB7CgkJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJCX0KCQkJCQkJYXR0cmlidXRlIHsKCQkJCQkJCS4uLk1hdGNoUGFydHMKCQkJCQkJfQoJCQkJCX0KCQkJCQlzYW1wbGluZ1JhdGlvCgkJCQl9CgkJCX0KCQl9Cgl9Cgkke0x0fQpgLGhyPUpgCglxdWVyeSBJZ25vcmUoJGlkOiBJRCEpIHsKCQlpZ25vcmUoaWQ6ICRpZCkKCX0KYCxkcj1KYAoJcXVlcnkgR2V0U2FtcGxpbmdDb25maWcoJG9yZ2FuaXphdGlvbl92ZXJib3NlX2lkOiBTdHJpbmchKSB7CgkJc2FtcGxpbmcob3JnYW5pemF0aW9uX3ZlcmJvc2VfaWQ6ICRvcmdhbml6YXRpb25fdmVyYm9zZV9pZCkgewoJCQlzcGFucyB7CgkJCQluYW1lIHsKCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQl9CgkJCQlhdHRyaWJ1dGVzIHsKCQkJCQlrZXkgewoJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJfQoJCQkJCWF0dHJpYnV0ZSB7CgkJCQkJCS4uLk1hdGNoUGFydHMKCQkJCQl9CgkJCQl9CgkJCQlldmVudHMgewoJCQkJCW5hbWUgewoJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJfQoJCQkJCWF0dHJpYnV0ZXMgewoJCQkJCQlrZXkgewoJCQkJCQkJLi4uTWF0Y2hQYXJ0cwoJCQkJCQl9CgkJCQkJCWF0dHJpYnV0ZSB7CgkJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJCX0KCQkJCQl9CgkJCQl9CgkJCQlzYW1wbGluZ1JhdGlvCgkJCX0KCQkJbG9ncyB7CgkJCQltZXNzYWdlIHsKCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQl9CgkJCQlzZXZlcml0eVRleHQgewoJCQkJCS4uLk1hdGNoUGFydHMKCQkJCX0KCQkJCWF0dHJpYnV0ZXMgewoJCQkJCWtleSB7CgkJCQkJCS4uLk1hdGNoUGFydHMKCQkJCQl9CgkJCQkJYXR0cmlidXRlIHsKCQkJCQkJLi4uTWF0Y2hQYXJ0cwoJCQkJCX0KCQkJCX0KCQkJCXNhbXBsaW5nUmF0aW8KCQkJfQoJCX0KCX0KCSR7THR9CmAscHI9KGUsdCxuLGkpPT5lKCk7ZnVuY3Rpb24gbXIoZSx0PXByKXtyZXR1cm57UHVzaFBheWxvYWQobixpKXtyZXR1cm4gdChyPT5lLnJlcXVlc3Qoc3IsbixEKEQoe30saSkscikpLCJQdXNoUGF5bG9hZCIsIm11dGF0aW9uIixuKX0sUHVzaFNlc3Npb25FdmVudHMobixpKXtyZXR1cm4gdChyPT5lLnJlcXVlc3Qob3IsbixEKEQoe30saSkscikpLCJQdXNoU2Vzc2lvbkV2ZW50cyIsIm11dGF0aW9uIixuKX0saWRlbnRpZnlTZXNzaW9uKG4saSl7cmV0dXJuIHQocj0+ZS5yZXF1ZXN0KGFyLG4sRChEKHt9LGkpLHIpKSwiaWRlbnRpZnlTZXNzaW9uIiwibXV0YXRpb24iLG4pfSxhZGRTZXNzaW9uUHJvcGVydGllcyhuLGkpe3JldHVybiB0KHI9PmUucmVxdWVzdChjcixuLEQoRCh7fSxpKSxyKSksImFkZFNlc3Npb25Qcm9wZXJ0aWVzIiwibXV0YXRpb24iLG4pfSxwdXNoTWV0cmljcyhuLGkpe3JldHVybiB0KHI9PmUucmVxdWVzdCh1cixuLEQoRCh7fSxpKSxyKSksInB1c2hNZXRyaWNzIiwibXV0YXRpb24iLG4pfSxhZGRTZXNzaW9uRmVlZGJhY2sobixpKXtyZXR1cm4gdChyPT5lLnJlcXVlc3QobHIsbixEKEQoe30saSkscikpLCJhZGRTZXNzaW9uRmVlZGJhY2siLCJtdXRhdGlvbiIsbil9LGluaXRpYWxpemVTZXNzaW9uKG4saSl7cmV0dXJuIHQocj0+ZS5yZXF1ZXN0KGZyLG4sRChEKHt9LGkpLHIpKSwiaW5pdGlhbGl6ZVNlc3Npb24iLCJtdXRhdGlvbiIsbil9LElnbm9yZShuLGkpe3JldHVybiB0KHI9PmUucmVxdWVzdChocixuLEQoRCh7fSxpKSxyKSksIklnbm9yZSIsInF1ZXJ5IixuKX0sR2V0U2FtcGxpbmdDb25maWcobixpKXtyZXR1cm4gdChyPT5lLnJlcXVlc3QoZHIsbixEKEQoe30saSkscikpLCJHZXRTYW1wbGluZ0NvbmZpZyIsInF1ZXJ5IixuKX19fXZhciBXPVVpbnQ4QXJyYXksWj1VaW50MTZBcnJheSxldD1JbnQzMkFycmF5LHR0PW5ldyBXKFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMCwwLDBdKSxudD1uZXcgVyhbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxMywwLDBdKSxGdD1uZXcgVyhbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pLE10PWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPW5ldyBaKDMxKSxpPTA7aTwzMTsrK2kpbltpXT10Kz0xPDxlW2ktMV07Zm9yKHZhciByPW5ldyBldChuWzMwXSksaT0xO2k8MzA7KytpKWZvcih2YXIgcz1uW2ldO3M8bltpKzFdOysrcylyW3NdPXMtbltpXTw8NXxpO3JldHVybntiOm4scn19LCR0PU10KHR0LDIpLHlyPSR0LmIscnQ9JHQucjt5clsyOF09MjU4LHJ0WzI1OF09Mjg7Zm9yKHZhciBncj1NdChudCwwKSxCdD1nci5yLGl0PW5ldyBaKDMyNzY4KSxMPTA7TDwzMjc2ODsrK0wpe3ZhciBhZT0oTCY0MzY5MCk+PjF8KEwmMjE4NDUpPDwxO2FlPShhZSY1MjQyOCk+PjJ8KGFlJjEzMTA3KTw8MixhZT0oYWUmNjE2ODApPj40fChhZSYzODU1KTw8NCxpdFtMXT0oKGFlJjY1MjgwKT4+OHwoYWUmMjU1KTw8OCk+PjF9Zm9yKHZhciBOZT1mdW5jdGlvbihlLHQsbil7Zm9yKHZhciBpPWUubGVuZ3RoLHI9MCxzPW5ldyBaKHQpO3I8aTsrK3IpZVtyXSYmKytzW2Vbcl0tMV07dmFyIG89bmV3IFoodCk7Zm9yKHI9MTtyPHQ7KytyKW9bcl09b1tyLTFdK3Nbci0xXTw8MTt2YXIgYztpZihuKXtjPW5ldyBaKDE8PHQpO3ZhciBmPTE1LXQ7Zm9yKHI9MDtyPGk7KytyKWlmKGVbcl0pZm9yKHZhciBkPXI8PDR8ZVtyXSx1PXQtZVtyXSx5PW9bZVtyXS0xXSsrPDx1LHY9eXwoMTw8dSktMTt5PD12OysreSljW2l0W3ldPj5mXT1kfWVsc2UgZm9yKGM9bmV3IFooaSkscj0wO3I8aTsrK3IpZVtyXSYmKGNbcl09aXRbb1tlW3JdLTFdKytdPj4xNS1lW3JdKTtyZXR1cm4gY30sbGU9bmV3IFcoMjg4KSxMPTA7TDwxNDQ7KytMKWxlW0xdPTg7Zm9yKHZhciBMPTE0NDtMPDI1NjsrK0wpbGVbTF09OTtmb3IodmFyIEw9MjU2O0w8MjgwOysrTClsZVtMXT03O2Zvcih2YXIgTD0yODA7TDwyODg7KytMKWxlW0xdPTg7Zm9yKHZhciBGZT1uZXcgVygzMiksTD0wO0w8MzI7KytMKUZlW0xdPTU7dmFyIHZyPU5lKGxlLDksMCksRXI9TmUoRmUsNSwwKSxVdD1mdW5jdGlvbihlKXtyZXR1cm4oZSs3KS84fDB9LFZ0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4obj09bnVsbHx8bj5lLmxlbmd0aCkmJihuPWUubGVuZ3RoKSxuZXcgVyhlLnN1YmFycmF5KHQsbikpfSxpZT1mdW5jdGlvbihlLHQsbil7bjw8PXQmNzt2YXIgaT10Lzh8MDtlW2ldfD1uLGVbaSsxXXw9bj4+OH0seGU9ZnVuY3Rpb24oZSx0LG4pe248PD10Jjc7dmFyIGk9dC84fDA7ZVtpXXw9bixlW2krMV18PW4+PjgsZVtpKzJdfD1uPj4xNn0sc3Q9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49W10saT0wO2k8ZS5sZW5ndGg7KytpKWVbaV0mJm4ucHVzaCh7czppLGY6ZVtpXX0pO3ZhciByPW4ubGVuZ3RoLHM9bi5zbGljZSgpO2lmKCFyKXJldHVybnt0Onp0LGw6MH07aWYocj09MSl7dmFyIG89bmV3IFcoblswXS5zKzEpO3JldHVybiBvW25bMF0uc109MSx7dDpvLGw6MX19bi5zb3J0KGZ1bmN0aW9uKCQscSl7cmV0dXJuICQuZi1xLmZ9KSxuLnB1c2goe3M6LTEsZjoyNTAwMX0pO3ZhciBjPW5bMF0sZj1uWzFdLGQ9MCx1PTEseT0yO2ZvcihuWzBdPXtzOi0xLGY6Yy5mK2YuZixsOmMscjpmfTt1IT1yLTE7KWM9bltuW2RdLmY8blt5XS5mP2QrKzp5KytdLGY9bltkIT11JiZuW2RdLmY8blt5XS5mP2QrKzp5KytdLG5bdSsrXT17czotMSxmOmMuZitmLmYsbDpjLHI6Zn07Zm9yKHZhciB2PXNbMF0ucyxpPTE7aTxyOysraSlzW2ldLnM+diYmKHY9c1tpXS5zKTt2YXIgYj1uZXcgWih2KzEpLG09b3Qoblt1LTFdLGIsMCk7aWYobT50KXt2YXIgaT0wLE49MCxnPW0tdCxFPTE8PGc7Zm9yKHMuc29ydChmdW5jdGlvbihxLEIpe3JldHVybiBiW0Iuc10tYltxLnNdfHxxLmYtQi5mfSk7aTxyOysraSl7dmFyIEM9c1tpXS5zO2lmKGJbQ10+dClOKz1FLSgxPDxtLWJbQ10pLGJbQ109dDtlbHNlIGJyZWFrfWZvcihOPj49ZztOPjA7KXt2YXIgdz1zW2ldLnM7Ylt3XTx0P04tPTE8PHQtYlt3XSsrLTE6KytpfWZvcig7aT49MCYmTjstLWkpe3ZhciBSPXNbaV0ucztiW1JdPT10JiYoLS1iW1JdLCsrTil9bT10fXJldHVybnt0Om5ldyBXKGIpLGw6bX19LG90PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZS5zPT0tMT9NYXRoLm1heChvdChlLmwsdCxuKzEpLG90KGUucix0LG4rMSkpOnRbZS5zXT1ufSxqdD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS5sZW5ndGg7dCYmIWVbLS10XTspO2Zvcih2YXIgbj1uZXcgWigrK3QpLGk9MCxyPWVbMF0scz0xLG89ZnVuY3Rpb24oZil7bltpKytdPWZ9LGM9MTtjPD10OysrYylpZihlW2NdPT1yJiZjIT10KSsrcztlbHNle2lmKCFyJiZzPjIpe2Zvcig7cz4xMzg7cy09MTM4KW8oMzI3NTQpO3M+MiYmKG8ocz4xMD9zLTExPDw1fDI4NjkwOnMtMzw8NXwxMjMwNSkscz0wKX1lbHNlIGlmKHM+Myl7Zm9yKG8ociksLS1zO3M+NjtzLT02KW8oODMwNCk7cz4yJiYobyhzLTM8PDV8ODIwOCkscz0wKX1mb3IoO3MtLTspbyhyKTtzPTEscj1lW2NdfXJldHVybntjOm4uc3ViYXJyYXkoMCxpKSxuOnR9fSxBZT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0wLGk9MDtpPHQubGVuZ3RoOysraSluKz1lW2ldKnRbaV07cmV0dXJuIG59LHF0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgaT1uLmxlbmd0aCxyPVV0KHQrMik7ZVtyXT1pJjI1NSxlW3IrMV09aT4+OCxlW3IrMl09ZVtyXV4yNTUsZVtyKzNdPWVbcisxXV4yNTU7Zm9yKHZhciBzPTA7czxpOysrcyllW3Ircys0XT1uW3NdO3JldHVybihyKzQraSkqOH0sR3Q9ZnVuY3Rpb24oZSx0LG4saSxyLHMsbyxjLGYsZCx1KXtpZSh0LHUrKyxuKSwrK3JbMjU2XTtmb3IodmFyIHk9c3QociwxNSksdj15LnQsYj15LmwsbT1zdChzLDE1KSxOPW0udCxnPW0ubCxFPWp0KHYpLEM9RS5jLHc9RS5uLFI9anQoTiksJD1SLmMscT1SLm4sQj1uZXcgWigxOSksST0wO0k8Qy5sZW5ndGg7KytJKSsrQltDW0ldJjMxXTtmb3IodmFyIEk9MDtJPCQubGVuZ3RoOysrSSkrK0JbJFtJXSYzMV07Zm9yKHZhciBTPXN0KEIsNyksaj1TLnQsVT1TLmwsej0xOTt6PjQmJiFqW0Z0W3otMV1dOy0teik7dmFyIEs9ZCs1PDwzLGE9QWUocixsZSkrQWUocyxGZSkrbyxoPUFlKHIsdikrQWUocyxOKStvKzE0KzMqeitBZShCLGopKzIqQlsxNl0rMypCWzE3XSs3KkJbMThdO2lmKGY+PTAmJks8PWEmJks8PWgpcmV0dXJuIHF0KHQsdSxlLnN1YmFycmF5KGYsZitkKSk7dmFyIF8sQSxrLHg7aWYoaWUodCx1LDErKGg8YSkpLHUrPTIsaDxhKXtfPU5lKHYsYiwwKSxBPXYsaz1OZShOLGcsMCkseD1OO3ZhciBjZT1OZShqLFUsMCk7aWUodCx1LHctMjU3KSxpZSh0LHUrNSxxLTEpLGllKHQsdSsxMCx6LTQpLHUrPTE0O2Zvcih2YXIgST0wO0k8ejsrK0kpaWUodCx1KzMqSSxqW0Z0W0ldXSk7dSs9Myp6O2Zvcih2YXIgSD1bQywkXSxzZT0wO3NlPDI7KytzZSlmb3IodmFyIHllPUhbc2VdLEk9MDtJPHllLmxlbmd0aDsrK0kpe3ZhciBuZT15ZVtJXSYzMTtpZSh0LHUsY2VbbmVdKSx1Kz1qW25lXSxuZT4xNSYmKGllKHQsdSx5ZVtJXT4+NSYxMjcpLHUrPXllW0ldPj4xMil9fWVsc2UgXz12cixBPWxlLGs9RXIseD1GZTtmb3IodmFyIEk9MDtJPGM7KytJKXt2YXIgWT1pW0ldO2lmKFk+MjU1KXt2YXIgbmU9WT4+MTgmMzE7eGUodCx1LF9bbmUrMjU3XSksdSs9QVtuZSsyNTddLG5lPjcmJihpZSh0LHUsWT4+MjMmMzEpLHUrPXR0W25lXSk7dmFyIGdlPVkmMzE7eGUodCx1LGtbZ2VdKSx1Kz14W2dlXSxnZT4zJiYoeGUodCx1LFk+PjUmODE5MSksdSs9bnRbZ2VdKX1lbHNlIHhlKHQsdSxfW1ldKSx1Kz1BW1ldfXJldHVybiB4ZSh0LHUsX1syNTZdKSx1K0FbMjU2XX0sX3I9bmV3IGV0KFs2NTU0MCwxMzEwODAsMTMxMDg4LDEzMTEwNCwyNjIxNzYsMTA0ODcwNCwxMDQ4ODMyLDIxMTQ1NjAsMjExNzYzMl0pLHp0PW5ldyBXKDApLFRyPWZ1bmN0aW9uKGUsdCxuLGkscixzKXt2YXIgbz1zLnp8fGUubGVuZ3RoLGM9bmV3IFcoaStvKzUqKDErTWF0aC5jZWlsKG8vN2UzKSkrciksZj1jLnN1YmFycmF5KGksYy5sZW5ndGgtciksZD1zLmwsdT0ocy5yfHwwKSY3O2lmKHQpe3UmJihmWzBdPXMucj4+Myk7Zm9yKHZhciB5PV9yW3QtMV0sdj15Pj4xMyxiPXkmODE5MSxtPSgxPDxuKS0xLE49cy5wfHxuZXcgWigzMjc2OCksZz1zLmh8fG5ldyBaKG0rMSksRT1NYXRoLmNlaWwobi8zKSxDPTIqRSx3PWZ1bmN0aW9uKGx0KXtyZXR1cm4oZVtsdF1eZVtsdCsxXTw8RV5lW2x0KzJdPDxDKSZtfSxSPW5ldyBldCgyNWUzKSwkPW5ldyBaKDI4OCkscT1uZXcgWigzMiksQj0wLEk9MCxTPXMuaXx8MCxqPTAsVT1zLnd8fDAsej0wO1MrMjxvOysrUyl7dmFyIEs9dyhTKSxhPVMmMzI3NjcsaD1nW0tdO2lmKE5bYV09aCxnW0tdPWEsVTw9Uyl7dmFyIF89by1TO2lmKChCPjdlM3x8aj4yNDU3NikmJihfPjQyM3x8IWQpKXt1PUd0KGUsZiwwLFIsJCxxLEksaix6LFMteix1KSxqPUI9ST0wLHo9Uztmb3IodmFyIEE9MDtBPDI4NjsrK0EpJFtBXT0wO2Zvcih2YXIgQT0wO0E8MzA7KytBKXFbQV09MH12YXIgaz0yLHg9MCxjZT1iLEg9YS1oJjMyNzY3O2lmKF8+MiYmSz09dyhTLUgpKWZvcih2YXIgc2U9TWF0aC5taW4odixfKS0xLHllPU1hdGgubWluKDMyNzY3LFMpLG5lPU1hdGgubWluKDI1OCxfKTtIPD15ZSYmLS1jZSYmYSE9aDspe2lmKGVbUytrXT09ZVtTK2stSF0pe2Zvcih2YXIgWT0wO1k8bmUmJmVbUytZXT09ZVtTK1ktSF07KytZKTtpZihZPmspe2lmKGs9WSx4PUgsWT5zZSlicmVhaztmb3IodmFyIGdlPU1hdGgubWluKEgsWS0yKSxXdD0wLEE9MDtBPGdlOysrQSl7dmFyIGN0PVMtSCtBJjMyNzY3LFVyPU5bY3RdLFp0PWN0LVVyJjMyNzY3O1p0Pld0JiYoV3Q9WnQsaD1jdCl9fX1hPWgsaD1OW2FdLEgrPWEtaCYzMjc2N31pZih4KXtSW2orK109MjY4NDM1NDU2fHJ0W2tdPDwxOHxCdFt4XTt2YXIgS3Q9cnRba10mMzEsZW49QnRbeF0mMzE7SSs9dHRbS3RdK250W2VuXSwrKyRbMjU3K0t0XSwrK3FbZW5dLFU9UytrLCsrQn1lbHNlIFJbaisrXT1lW1NdLCsrJFtlW1NdXX19Zm9yKFM9TWF0aC5tYXgoUyxVKTtTPG87KytTKVJbaisrXT1lW1NdLCsrJFtlW1NdXTt1PUd0KGUsZixkLFIsJCxxLEksaix6LFMteix1KSxkfHwocy5yPXUmN3xmW3UvOHwwXTw8Myx1LT03LHMuaD1nLHMucD1OLHMuaT1TLHMudz1VKX1lbHNle2Zvcih2YXIgUz1zLnd8fDA7UzxvK2Q7Uys9NjU1MzUpe3ZhciB1dD1TKzY1NTM1O3V0Pj1vJiYoZlt1Lzh8MF09ZCx1dD1vKSx1PXF0KGYsdSsxLGUuc3ViYXJyYXkoUyx1dCkpfXMuaT1vfXJldHVybiBWdChjLDAsaStVdCh1KStyKX0sYnI9ZnVuY3Rpb24oKXtmb3IodmFyIGU9bmV3IEludDMyQXJyYXkoMjU2KSx0PTA7dDwyNTY7Kyt0KXtmb3IodmFyIG49dCxpPTk7LS1pOyluPShuJjEmJi0zMDY2NzQ5MTIpXm4+Pj4xO2VbdF09bn1yZXR1cm4gZX0oKSxOcj1mdW5jdGlvbigpe3ZhciBlPS0xO3JldHVybntwOmZ1bmN0aW9uKHQpe2Zvcih2YXIgbj1lLGk9MDtpPHQubGVuZ3RoOysraSluPWJyW24mMjU1XnRbaV1dXm4+Pj44O2U9bn0sZDpmdW5jdGlvbigpe3JldHVybn5lfX19LHhyPWZ1bmN0aW9uKGUsdCxuLGkscil7aWYoIXImJihyPXtsOjF9LHQuZGljdGlvbmFyeSkpe3ZhciBzPXQuZGljdGlvbmFyeS5zdWJhcnJheSgtMzI3NjgpLG89bmV3IFcocy5sZW5ndGgrZS5sZW5ndGgpO28uc2V0KHMpLG8uc2V0KGUscy5sZW5ndGgpLGU9byxyLnc9cy5sZW5ndGh9cmV0dXJuIFRyKGUsdC5sZXZlbD09bnVsbD82OnQubGV2ZWwsdC5tZW09PW51bGw/ci5sP01hdGguY2VpbChNYXRoLm1heCg4LE1hdGgubWluKDEzLE1hdGgubG9nKGUubGVuZ3RoKSkpKjEuNSk6MjA6MTIrdC5tZW0sbixpLHIpfSxhdD1mdW5jdGlvbihlLHQsbil7Zm9yKDtuOysrdCllW3RdPW4sbj4+Pj04fSxBcj1mdW5jdGlvbihlLHQpe3ZhciBuPXQuZmlsZW5hbWU7aWYoZVswXT0zMSxlWzFdPTEzOSxlWzJdPTgsZVs4XT10LmxldmVsPDI/NDp0LmxldmVsPT05PzI6MCxlWzldPTMsdC5tdGltZSE9MCYmYXQoZSw0LE1hdGguZmxvb3IobmV3IERhdGUodC5tdGltZXx8RGF0ZS5ub3coKSkvMWUzKSksbil7ZVszXT04O2Zvcih2YXIgaT0wO2k8PW4ubGVuZ3RoOysraSllW2krMTBdPW4uY2hhckNvZGVBdChpKX19LElyPWZ1bmN0aW9uKGUpe3JldHVybiAxMCsoZS5maWxlbmFtZT9lLmZpbGVuYW1lLmxlbmd0aCsxOjApfTtmdW5jdGlvbiBTcihlLHQpe3R8fCh0PXt9KTt2YXIgbj1OcigpLGk9ZS5sZW5ndGg7bi5wKGUpO3ZhciByPXhyKGUsdCxJcih0KSw4KSxzPXIubGVuZ3RoO3JldHVybiBBcihyLHQpLGF0KHIscy04LG4uZCgpKSxhdChyLHMtNCxpKSxyfXZhciBIdD10eXBlb2YgVGV4dEVuY29kZXIhPSJ1bmRlZmluZWQiJiZuZXcgVGV4dEVuY29kZXIsT3I9dHlwZW9mIFRleHREZWNvZGVyIT0idW5kZWZpbmVkIiYmbmV3IFRleHREZWNvZGVyLHdyPTA7dHJ5e09yLmRlY29kZSh6dCx7c3RyZWFtOiEwfSksd3I9MX1jYXRjaChlKXt9ZnVuY3Rpb24gRHIoZSx0KXt2YXIgbjtpZihIdClyZXR1cm4gSHQuZW5jb2RlKGUpO2Zvcih2YXIgaT1lLmxlbmd0aCxyPW5ldyBXKGUubGVuZ3RoKyhlLmxlbmd0aD4+MSkpLHM9MCxvPWZ1bmN0aW9uKGQpe3JbcysrXT1kfSxuPTA7bjxpOysrbil7aWYocys1PnIubGVuZ3RoKXt2YXIgYz1uZXcgVyhzKzgrKGktbjw8MSkpO2Muc2V0KHIpLHI9Y312YXIgZj1lLmNoYXJDb2RlQXQobik7ZjwxMjh8fHQ/byhmKTpmPDIwNDg/KG8oMTkyfGY+PjYpLG8oMTI4fGYmNjMpKTpmPjU1Mjk1JiZmPDU3MzQ0PyhmPTY1NTM2KyhmJjEwNDc1NTIpfGUuY2hhckNvZGVBdCgrK24pJjEwMjMsbygyNDB8Zj4+MTgpLG8oMTI4fGY+PjEyJjYzKSxvKDEyOHxmPj42JjYzKSxvKDEyOHxmJjYzKSk6KG8oMjI0fGY+PjEyKSxvKDEyOHxmPj42JjYzKSxvKDEyOHxmJjYzKSl9cmV0dXJuIFZ0KHIsMCxzKX1mdW5jdGlvbiBDcihlKXtyZXR1cm4gUSh0aGlzLG51bGwsZnVuY3Rpb24qKCl7Y29uc3QgdD1EcihKU09OLnN0cmluZ2lmeShlKSksbj1Tcih0KSxpPXlpZWxkIG5ldyBQcm9taXNlKHI9Pntjb25zdCBzPW5ldyBGaWxlUmVhZGVyO3Mub25sb2FkPSgpPT5yKHMucmVzdWx0KSxzLnJlYWRBc0RhdGFVUkwobmV3IEJsb2IoW25ldyBVaW50OEFycmF5KG4pXSkpfSk7cmV0dXJue2NvbXByZXNzZWRCYXNlNjQ6aS5zbGljZShpLmluZGV4T2YoIiwiKSsxKSxjb21wcmVzc2VkU2l6ZTpuLmxlbmd0aCxidWZmZXJMZW5ndGg6dC5sZW5ndGh9fSl9Y2xhc3Mga3J7Y29uc3RydWN0b3IodCxuKXtodCh0aGlzLCJkZWJ1ZyIpO2h0KHRoaXMsIm5hbWUiKTt0aGlzLmRlYnVnPXQsdGhpcy5uYW1lPW59bG9nKC4uLnQpe2lmKHRoaXMuZGVidWcpe2xldCBuPWBbJHtEYXRlLm5vdygpfV1gO3RoaXMubmFtZSYmKG4rPWAgLSAke3RoaXMubmFtZX1gKSxjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLFtuLC4uLnRdKX19d2FybiguLi50KXtsZXQgbj1gWyR7RGF0ZS5ub3coKX1dYDt0aGlzLm5hbWUmJihuKz1gIC0gJHt0aGlzLm5hbWV9YCksY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsW24sLi4udF0pfX12YXIgWXQ9KGU9PihlLkJpbGxpbmdRdW90YUV4Y2VlZGVkPSJCaWxsaW5nUXVvdGFFeGNlZWRlZCIsZSkpKFl0fHx7fSk7Y29uc3QgUnI9MTAsUHI9MWUzLExyPTUwMCxGcj1bWXQuQmlsbGluZ1F1b3RhRXhjZWVkZWQudG9TdHJpbmcoKV0sTXI9ZT0+e3ZhciBuO3JldHVybigobj1lLnJlc3BvbnNlLmVycm9ycyk9PW51bGw/dm9pZCAwOm4uZmluZChpPT5Gci5pbmNsdWRlcyhpLm1lc3NhZ2UpKSk9PT12b2lkIDB9LCRyPSgpPT57Y29uc3QgZT0odCxuLGkscixzPTApPT5RKHRoaXMsbnVsbCxmdW5jdGlvbiooKXt0cnl7cmV0dXJuIHlpZWxkIHQoKX1jYXRjaChvKXtpZihvIGluc3RhbmNlb2YgZGUmJiFNcihvKSl0aHJvdyBvO2lmKHM8UnIpcmV0dXJuIHlpZWxkIG5ldyBQcm9taXNlKGM9PnNldFRpbWVvdXQoYyxQcitMcipNYXRoLnBvdygyLHMpKSkseWllbGQgZSh0LG4saSxyLHMrMSk7dGhyb3cgY29uc29sZS5lcnJvcihgaGlnaGxpZ2h0LmlvOiBkYXRhIHJlcXVlc3QgZmFpbGVkIGFmdGVyICR7c30gcmV0cmllc2ApLG99fSk7cmV0dXJuIGV9LEp0PTUsUXQ9MmUzLEJyPVsibnVtYmVyIiwic3RyaW5nIiwiYm9vbGVhbiJdO3ZhciB0ZT0oZT0+KGVbZS5Jbml0aWFsaXplPTBdPSJJbml0aWFsaXplIixlW2UuQXN5bmNFdmVudHM9MV09IkFzeW5jRXZlbnRzIixlW2UuSWRlbnRpZnk9Ml09IklkZW50aWZ5IixlW2UuUHJvcGVydGllcz0zXT0iUHJvcGVydGllcyIsZVtlLk1ldHJpY3M9NF09Ik1ldHJpY3MiLGVbZS5GZWVkYmFjaz01XT0iRmVlZGJhY2siLGVbZS5DdXN0b21FdmVudD02XT0iQ3VzdG9tRXZlbnQiLGVbZS5TdG9wPTddPSJTdG9wIixlKSkodGV8fHt9KTtjb25zdCBNZT1zZWxmO2Z1bmN0aW9uIFh0KGUsdCl7Y29uc3Qgbj17fSxpPVtdLHI9W107Zm9yKGNvbnN0W3Msb11vZiBPYmplY3QuZW50cmllcyhlKSl7aWYobz09bnVsbCljb250aW51ZTtCci5pbmNsdWRlcyh0eXBlb2Ygbyl8fGkucHVzaCh7W3NdOm99KTtsZXQgYzt0eXBlb2Ygbz09InN0cmluZyI/Yz1vOmM9bWUobyksYy5sZW5ndGg+UXQmJihyLnB1c2goe1tzXTpvfSksYz1jLnN1YnN0cmluZygwLFF0KSksbltzXT1jfXJldHVybiB0IT09InNlc3Npb24iJiYoaS5sZW5ndGg+MCYmY29uc29sZS53YXJuKGBIaWdobGlnaHQgd2FzIHBhc3NlZCBvbmUgb3IgbW9yZSAke3R9IHByb3BlcnRpZXMgbm90IG9mIHR5cGUgc3RyaW5nLCBudW1iZXIsIG9yIGJvb2xlYW4uYCxpKSxyLmxlbmd0aD4wJiZjb25zb2xlLndhcm4oYEhpZ2hsaWdodCB3YXMgcGFzc2VkIG9uZSBvciBtb3JlICR7dH0gcHJvcGVydGllcyBleGNlZWRpbmcgMjAwMCBjaGFyYWN0ZXJzLCB3aGljaCB3aWxsIGJlIHRydW5jYXRlZC5gLHIpKSxufXtsZXQgZSx0LG4saT0wLHI9MCxzPSExLG89MCxjPW5ldyBrcighMSwiW3dvcmtlcl0iKTtjb25zdCBmPVtdLGQ9KCk9Pm8hPT0wJiZpPEp0JiYhIShuIT1udWxsJiZuLmxlbmd0aCksdT0oZyxFKT0+e01lLnBvc3RNZXNzYWdlKHtyZXNwb25zZTp7dHlwZTp0ZS5DdXN0b21FdmVudCx0YWc6ZyxwYXlsb2FkOkV9fSl9LHk9Zz0+USh0aGlzLG51bGwsZnVuY3Rpb24qKCl7Y29uc3R7aWQ6RSxldmVudHM6QyxtZXNzYWdlczp3LGVycm9yczpSLHJlc291cmNlc1N0cmluZzokLHdlYlNvY2tldEV2ZW50c1N0cmluZzpxLGhhc1Nlc3Npb25VbmxvYWRlZDpCLGhpZ2hsaWdodExvZ3M6SX09ZyxTPW1lKHttZXNzYWdlczp3fSk7bGV0IGo9e3Nlc3Npb25fc2VjdXJlX2lkOm4scGF5bG9hZF9pZDpFLnRvU3RyaW5nKCksZXZlbnRzOntldmVudHM6Q30sbWVzc2FnZXM6UyxyZXNvdXJjZXM6JCx3ZWJfc29ja2V0X2V2ZW50czpxLGVycm9yczpSLGlzX2JlYWNvbjohMSxoYXNfc2Vzc2lvbl91bmxvYWRlZDpCfTtJJiYoai5oaWdobGlnaHRfbG9ncz1JKTtjb25zdHtjb21wcmVzc2VkQmFzZTY0OlUsYnVmZmVyTGVuZ3RoOnosY29tcHJlc3NlZFNpemU6S309eWllbGQgQ3IoaiksYT17dHlwZTp0ZS5Bc3luY0V2ZW50cyxpZDpFLGV2ZW50c1NpemU6eixjb21wcmVzc2VkU2l6ZTpVLmxlbmd0aH07Yy5sb2coYFB1c2hpbmcgcGF5bG9hZDogJHtKU09OLnN0cmluZ2lmeSh7c2Vzc2lvblNlY3VyZUlEOm4saWQ6RSxmaXJzdFNJRDpNYXRoLm1pbiguLi5qLmV2ZW50cy5ldmVudHMubWFwKHg9Png9PW51bGw/dm9pZCAwOnguX3NpZCkuZmlsdGVyKHg9PiEheCkpLGV2ZW50c0xlbmd0aDpqLmV2ZW50cy5ldmVudHMubGVuZ3RoLG1lc3NhZ2VzTGVuZ3RoOncubGVuZ3RoLHJlc291cmNlc0xlbmd0aDokLmxlbmd0aCx3ZWJTb2NrZXRMZW5ndGg6cS5sZW5ndGgsZXJyb3JzTGVuZ3RoOlIubGVuZ3RoLGJ1Zkxlbmd0aDp6LGNvbXByZXNzZWRMZW5ndGg6Syxjb21wcmVzc2VkQmFzZTY0TGVuZ3RoOlUubGVuZ3RofSx2b2lkIDAsMil9YCk7Y29uc3QgaD1lLlB1c2hTZXNzaW9uRXZlbnRzKHtzZXNzaW9uX3NlY3VyZV9pZDpuLHBheWxvYWRfaWQ6RS50b1N0cmluZygpLGRhdGE6VX0pO2xldCBfPVByb21pc2UucmVzb2x2ZSgpO2YubGVuZ3RoJiYoXz1lLnB1c2hNZXRyaWNzKHttZXRyaWNzOmZ9KSxmLnNwbGljZSgwKSk7bGV0IEE9cGVyZm9ybWFuY2Uubm93KCk7Y29uc3Qgaz1zZXRJbnRlcnZhbCgoKT0+e0EmJnBlcmZvcm1hbmNlLm5vdygpLUE+a3QmJihjb25zb2xlLndhcm4oYFVwbG9hZGluZyBwdXNoUGF5bG9hZCB0b29rIHRvbyBsb25nLCBmYWlsdXJlIG51bWJlciAjJHtyfS5gKSxyKz0xLGNsZWFySW50ZXJ2YWwoaykscj49SnQmJihjb25zb2xlLndhcm4oIlVwbG9hZGluZyBwdXNoUGF5bG9hZCB0b29rIHRvbyBsb25nLCBzdG9wcGluZyByZWNvcmRpbmcgdG8gYXZvaWQgT09NLiIpLE1lLnBvc3RNZXNzYWdlKHtyZXNwb25zZTp7dHlwZTp0ZS5TdG9wLHJlcXVlc3RTdGFydDpBLGFzeW5jRXZlbnRzUmVzcG9uc2U6YX19KSxiKHt0eXBlOnRlLlByb3BlcnRpZXMscHJvcGVydGllc09iamVjdDp7c3RvcFJlYXNvbjoiUHVzaCBQYXlsb2FkIFRpbWVvdXQifSxwcm9wZXJ0eVR5cGU6e3R5cGU6InRyYWNrIn19KSkpfSwxMDApO3RyeXt5aWVsZCBQcm9taXNlLmFsbChbaCxfXSksciYmcGVyZm9ybWFuY2Uubm93KCktQTw9a3QmJihjb25zb2xlLndhcm4oYHB1c2hQYXlsb2FkIHN1Y2NlZWRlZCBhZnRlciAjJHtyfSBmYWlsdXJlcywgcmVzZXR0aW5nIHN0b3Agc3dpdGNoLmApLHI9MCl9ZmluYWxseXtBPTAsY2xlYXJJbnRlcnZhbChrKX1NZS5wb3N0TWVzc2FnZSh7cmVzcG9uc2U6YX0pfSksdj1nPT5RKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtjb25zdHt1c2VyT2JqZWN0OkUsdXNlcklkZW50aWZpZXI6Qyxzb3VyY2U6d309Zzt3PT09InNlZ21lbnQiP3UoIlNlZ21lbnQgSWRlbnRpZnkiLG1lKEQoe3VzZXJJZGVudGlmaWVyOkN9LEUpKSk6dSgiSWRlbnRpZnkiLG1lKEQoe3VzZXJJZGVudGlmaWVyOkN9LEUpKSkseWllbGQgZS5pZGVudGlmeVNlc3Npb24oe3Nlc3Npb25fc2VjdXJlX2lkOm4sdXNlcl9pZGVudGlmaWVyOkMsdXNlcl9vYmplY3Q6WHQoRSwidXNlciIpfSk7Y29uc3QgUj13PT09InNlZ21lbnQiP3c6ImRlZmF1bHQiO2MubG9nKGBJZGVudGlmeSAoJHtDfSwgc291cmNlOiAke1J9KSB3LyBvYmo6ICR7bWUoRSl9IEAgJHt0fWApfSksYj1nPT5RKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtjb25zdHtwcm9wZXJ0aWVzT2JqZWN0OkUscHJvcGVydHlUeXBlOkN9PWc7bGV0IHc7KEM9PW51bGw/dm9pZCAwOkMudHlwZSk9PT0ic2Vzc2lvbiI/KHc9IlNlc3Npb24iLHlpZWxkIGUuYWRkU2Vzc2lvblByb3BlcnRpZXMoe3Nlc3Npb25fc2VjdXJlX2lkOm4scHJvcGVydGllc19vYmplY3Q6WHQoRSwic2Vzc2lvbiIpfSkpOihDPT1udWxsP3ZvaWQgMDpDLnNvdXJjZSk9PT0ic2VnbWVudCI/dz0iU2VnbWVudCI6dz0iVHJhY2siLHchPT0iU2Vzc2lvbiImJnUodyxtZShFKSksYy5sb2coYEFkZGluZyAke3d9IFByb3BlcnRpZXMgdG8gc2Vzc2lvbiAoJHtufSkgdy8gb2JqOiAke0pTT04uc3RyaW5naWZ5KEUpfSBAICR7dH1gKX0pLG09Zz0+USh0aGlzLG51bGwsZnVuY3Rpb24qKCl7Zi5wdXNoKC4uLmcubWV0cmljcy5tYXAoRT0+KHtuYW1lOkUubmFtZSx2YWx1ZTpFLnZhbHVlLHNlc3Npb25fc2VjdXJlX2lkOm4sY2F0ZWdvcnk6RS5jYXRlZ29yeSxncm91cDpFLmdyb3VwLHRpbWVzdGFtcDpFLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLHRhZ3M6RS50YWdzfSkpKX0pLE49Zz0+USh0aGlzLG51bGwsZnVuY3Rpb24qKCl7Y29uc3R7dGltZXN0YW1wOkUsdmVyYmF0aW06Qyx1c2VyRW1haWw6dyx1c2VyTmFtZTpSfT1nO3lpZWxkIGUuYWRkU2Vzc2lvbkZlZWRiYWNrKHtzZXNzaW9uX3NlY3VyZV9pZDpuLHRpbWVzdGFtcDpFLHZlcmJhdGltOkMsdXNlcl9lbWFpbDp3LHVzZXJfbmFtZTpSfSl9KTtNZS5vbm1lc3NhZ2U9ZnVuY3Rpb24oZyl7cmV0dXJuIFEodGhpcyxudWxsLGZ1bmN0aW9uKigpe2lmKGcuZGF0YS5tZXNzYWdlLnR5cGU9PT10ZS5Jbml0aWFsaXplKXt0PWcuZGF0YS5tZXNzYWdlLmJhY2tlbmQsbj1nLmRhdGEubWVzc2FnZS5zZXNzaW9uU2VjdXJlSUQscz1nLmRhdGEubWVzc2FnZS5kZWJ1ZyxvPWcuZGF0YS5tZXNzYWdlLnJlY29yZGluZ1N0YXJ0VGltZSxjLmRlYnVnPXMsZT1tcihuZXcgWW4odCx7aGVhZGVyczp7fX0pLCRyKCkpO3JldHVybn1pZihkKCkpdHJ5e2cuZGF0YS5tZXNzYWdlLnR5cGU9PT10ZS5Bc3luY0V2ZW50cz95aWVsZCB5KGcuZGF0YS5tZXNzYWdlKTpnLmRhdGEubWVzc2FnZS50eXBlPT09dGUuSWRlbnRpZnk/eWllbGQgdihnLmRhdGEubWVzc2FnZSk6Zy5kYXRhLm1lc3NhZ2UudHlwZT09PXRlLlByb3BlcnRpZXM/eWllbGQgYihnLmRhdGEubWVzc2FnZSk6Zy5kYXRhLm1lc3NhZ2UudHlwZT09PXRlLk1ldHJpY3M/eWllbGQgbShnLmRhdGEubWVzc2FnZSk6Zy5kYXRhLm1lc3NhZ2UudHlwZT09PXRlLkZlZWRiYWNrJiYoeWllbGQgTihnLmRhdGEubWVzc2FnZSkpLGk9MH1jYXRjaChFKXtzJiZjb25zb2xlLmVycm9yKEUpLGkrPTF9fSl9fX0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPWhpZ2hsaWdodC1jbGllbnQtd29ya2VyLThaZ0xJRTFCLmpzLm1hcAo=", sf = (s) => Uint8Array.from(atob(s), (e) => e.charCodeAt(0)), rl = typeof self != "undefined" && self.Blob && new Blob([sf(ha)], { type: "text/javascript;charset=utf-8" });
function rf(s) {
  let e;
  try {
    if (e = rl && (self.URL || self.webkitURL).createObjectURL(rl), !e) throw "";
    const t = new Worker(e, {
      name: s == null ? void 0 : s.name
    });
    return t.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(e);
    }), t;
  } catch (t) {
    return new Worker(
      "data:text/javascript;base64," + ha,
      {
        name: s == null ? void 0 : s.name
      }
    );
  } finally {
    e && (self.URL || self.webkitURL).revokeObjectURL(e);
  }
}
var Je = /* @__PURE__ */ ((s) => (s[s.Initialize = 0] = "Initialize", s[s.AsyncEvents = 1] = "AsyncEvents", s[s.Identify = 2] = "Identify", s[s.Properties = 3] = "Properties", s[s.Metrics = 4] = "Metrics", s[s.Feedback = 5] = "Feedback", s[s.CustomEvent = 6] = "CustomEvent", s[s.Stop = 7] = "Stop", s))(Je || {});
const nf = ({
  apiKey: s
}) => {
  (function(e, t) {
    var i = e.amplitude || { _q: [], _iq: {} }, r = t.createElement("script");
    r.type = "text/javascript", r.integrity = "sha384-+EO59vL/X7v6VE2s6/F4HxfHlK0nDUVWKVg8K9oUlvffAeeaShVBmbORTC2D3UF+", r.crossOrigin = "anonymous", r.async = !0, r.src = "https://cdn.amplitude.com/libs/amplitude-8.17.0-min.gz.js", r.onload = function() {
      e.amplitude.runQueuedFunctions || console.log("[Amplitude] Error: could not load SDK"), amplitude.getInstance().init(s);
    };
    var n = t.getElementsByTagName("script")[0];
    n.parentNode.insertBefore(r, n);
    function o(m, f) {
      m.prototype[f] = function() {
        return this._q.push(
          [f].concat(Array.prototype.slice.call(arguments, 0))
        ), this;
      };
    }
    for (var a = function() {
      return this._q = [], this;
    }, l = [
      "add",
      "append",
      "clearAll",
      "prepend",
      "set",
      "setOnce",
      "unset",
      "preInsert",
      "postInsert",
      "remove"
    ], u = 0; u < l.length; u++)
      o(a, l[u]);
    i.Identify = a;
    for (var c = function() {
      return this._q = [], this;
    }, h = [
      "setProductId",
      "setQuantity",
      "setPrice",
      "setRevenueType",
      "setEventProperties"
    ], p = 0; p < h.length; p++)
      o(c, h[p]);
    i.Revenue = c;
    var d = [
      "init",
      "logEvent",
      "logRevenue",
      "setUserId",
      "setUserProperties",
      "setOptOut",
      "setVersionName",
      "setDomain",
      "setDeviceId",
      "enableTracking",
      "setGlobalUserProperties",
      "identify",
      "clearUserProperties",
      "setGroup",
      "logRevenueV2",
      "regenerateDeviceId",
      "groupIdentify",
      "onInit",
      "logEventWithTimestamp",
      "logEventWithGroups",
      "setSessionId",
      "resetSessionId"
    ];
    function b(m) {
      function f(S) {
        m[S] = function() {
          m._q.push(
            [S].concat(Array.prototype.slice.call(arguments, 0))
          );
        };
      }
      for (var G = 0; G < d.length; G++)
        f(d[G]);
    }
    b(i), i.getInstance = function(m) {
      return m = (!m || m.length === 0 ? "$default_instance" : m).toLowerCase(), Object.prototype.hasOwnProperty.call(i._iq, m) || (i._iq[m] = { _q: [] }, b(i._iq[m])), i._iq[m];
    }, e.amplitude = i;
  })(window, document);
}, lf = ({
  projectToken: s
}) => {
  if (window.mixpanel)
    return;
  (function(t, i) {
    if (!i.__SV) {
      var r, n;
      window.mixpanel = i, i._i = [], i.init = function(o, a, l) {
        function u(p, d) {
          var b = d.split(".");
          b.length == 2 && (p = p[b[0]], d = b[1]), p[d] = function() {
            p.push(
              [d].concat(
                Array.prototype.slice.call(arguments, 0)
              )
            );
          };
        }
        var c = i;
        for (typeof l != "undefined" ? c = i[l] = [] : l = "mixpanel", c.people = c.people || [], c.toString = function(p) {
          var d = "mixpanel";
          return l !== "mixpanel" && (d += "." + l), p || (d += " (stub)"), d;
        }, c.people.toString = function() {
          return c.toString(1) + ".people (stub)";
        }, r = "disable time_event track track_pageview track_links track_forms track_with_groups add_group set_group remove_group register register_once alias unregister identify name_tag set_config reset opt_in_tracking opt_out_tracking has_opted_in_tracking has_opted_out_tracking clear_opt_in_out_tracking start_batch_senders people.set people.set_once people.unset people.increment people.append people.union people.track_charge people.clear_charges people.delete_user people.remove".split(
          " "
        ), n = 0; n < r.length; n++) u(c, r[n]);
        var h = "set set_once union unset remove delete".split(" ");
        c.get_group = function() {
          function p(f) {
            d[f] = function() {
              call2_args = arguments, call2 = [f].concat(
                Array.prototype.slice.call(call2_args, 0)
              ), c.push([b, call2]);
            };
          }
          for (var d = {}, b = ["get_group"].concat(
            Array.prototype.slice.call(arguments, 0)
          ), m = 0; m < h.length; m++)
            p(h[m]);
          return d;
        }, i._i.push([o, a, l]);
      }, i.__SV = 1.2;
    }
  })(document, window.mixpanel || []);
  const e = document.createElement("script");
  e.src = of, document.head.appendChild(e), e.addEventListener("load", () => {
    var t;
    (t = window.mixpanel) == null || t.init(s);
  });
}, of = "https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";
class af {
  constructor(e) {
    k(this, "options");
    /** Determines if the client is running on a Highlight property (e.g. frontend). */
    k(this, "isRunningOnHighlight");
    /** Verbose project ID that is exposed to users. Legacy users may still be using ints. */
    k(this, "organizationID");
    k(this, "graphqlSDK");
    k(this, "events");
    k(this, "sessionData");
    k(this, "ready");
    k(this, "manualStopped");
    k(this, "state");
    k(this, "logger");
    k(this, "enableSegmentIntegration");
    k(this, "privacySetting");
    k(this, "enableCanvasRecording");
    k(this, "samplingStrategy");
    k(this, "inlineImages");
    k(this, "inlineVideos");
    k(this, "inlineStylesheet");
    k(this, "debugOptions");
    k(this, "listeners");
    k(this, "firstloadVersion");
    k(this, "environment");
    k(this, "sessionShortcut");
    /** The end-user's app version. This isn't Highlight's version. */
    k(this, "appVersion");
    k(this, "serviceName");
    k(this, "_worker");
    k(this, "_optionsInternal");
    k(this, "_backendUrl");
    k(this, "_recordingStartTime");
    k(this, "_isOnLocalHost");
    k(this, "_onToggleFeedbackFormVisibility");
    k(this, "_isCrossOriginIframe");
    k(this, "_eventBytesSinceSnapshot");
    k(this, "_lastSnapshotTime");
    k(this, "_lastVisibilityChangeTime");
    k(this, "pushPayloadTimerId");
    k(this, "hasSessionUnloaded");
    k(this, "hasPushedData");
    k(this, "reloaded");
    k(this, "_hasPreviouslyInitialized");
    k(this, "_recordStop");
    k(this, "_integrations", []);
    var i, r, n, o, a;
    this.options = e, typeof ((i = this.options) == null ? void 0 : i.debug) == "boolean" ? this.debugOptions = this.options.debug ? { clientInteractions: !0 } : {} : this.debugOptions = (n = (r = this.options) == null ? void 0 : r.debug) != null ? n : {}, this.logger = new Oa(this.debugOptions.clientInteractions), this._worker = new rf(), this._worker.onmessage = (l) => {
      var u, c, h;
      ((u = l.data.response) == null ? void 0 : u.type) === Je.AsyncEvents ? (this._eventBytesSinceSnapshot += l.data.response.eventsSize, this.logger.log(
        `Web worker sent payloadID ${l.data.response.id} size ${l.data.response.eventsSize} bytes, compression ratio ${l.data.response.eventsSize / l.data.response.compressedSize}.
                Total since snapshot: ${(this._eventBytesSinceSnapshot / 1e6).toFixed(1)}MB`
      )) : ((c = l.data.response) == null ? void 0 : c.type) === Je.CustomEvent ? this.addCustomEvent(
        l.data.response.tag,
        l.data.response.payload
      ) : ((h = l.data.response) == null ? void 0 : h.type) === Je.Stop && (Fe(
        "worker.onmessage",
        "warn",
        "Stopping recording due to worker failure",
        l.data.response
      ), this.stop(!1));
    };
    let t = ts();
    if (this.reloaded = !1, !((o = this.sessionData) != null && o.sessionSecureID) && (t != null && t.sessionSecureID))
      this.sessionData = t, this.options.sessionSecureID = t.sessionSecureID, this.reloaded = !0, this.logger.log(
        `Tab reloaded, continuing previous session: ${this.sessionData.sessionSecureID}`
      );
    else {
      for (const l of Object.values(ve))
        Ur(l);
      this.sessionData = {
        sessionSecureID: this.options.sessionSecureID,
        projectID: 0,
        sessionStartTime: Date.now()
      };
    }
    this._hasPreviouslyInitialized = !1;
    try {
      window.parent.document && (this._isCrossOriginIframe = !1);
    } catch (l) {
      this._isCrossOriginIframe = (a = this.options.recordCrossOriginIframe) != null ? a : !0;
    }
    this._initMembers(this.options);
  }
  // Start a new session
  _reset(i) {
    return ne(this, arguments, function* ({
      forceNew: e,
      sessionKey: t
    }) {
      this.pushPayloadTimerId && (clearTimeout(this.pushPayloadTimerId), this.pushPayloadTimerId = void 0);
      let r, n;
      if (!e)
        try {
          r = Ce(ve.USER_IDENTIFIER);
          const o = Ce(
            ve.USER_OBJECT
          );
          o && (n = JSON.parse(o));
        } catch (o) {
        }
      for (const o of Object.values(ve))
        Ur(o);
      this.sessionData.sessionSecureID = t ? is(`${this.organizationID}-${t}`) : is(), this.sessionData.sessionKey = t, this.sessionData.sessionStartTime = Date.now(), this.options.sessionSecureID = this.sessionData.sessionSecureID, this.stop(), yield this.start(), r && n && this.identify(r, n);
    });
  }
  _initMembers(e) {
    var n, o, a, l, u, c, h, p, d;
    this.sessionShortcut = !1, this._recordingStartTime = 0, this._isOnLocalHost = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1" || window.location.hostname === "", this.ready = !1, this.state = "NotRecording", this.manualStopped = !1, this.enableSegmentIntegration = !!e.enableSegmentIntegration, this.privacySetting = (n = e.privacySetting) != null ? n : "default", this.enableCanvasRecording = (o = e.enableCanvasRecording) != null ? o : !1, this.inlineImages = (a = e.inlineImages) != null ? a : this._isOnLocalHost, this.inlineVideos = (l = e.inlineVideos) != null ? l : this._isOnLocalHost, this.inlineStylesheet = (u = e.inlineStylesheet) != null ? u : this._isOnLocalHost, this.samplingStrategy = x({
      canvasFactor: 0.5,
      canvasMaxSnapshotDimension: 360,
      canvasClearWebGLBuffer: !0,
      dataUrlOptions: ya()
    }, (c = e.samplingStrategy) != null ? c : {
      canvas: 2
    }), this._backendUrl = (h = e == null ? void 0 : e.backendUrl) != null ? h : "https://pub.observability.app.launchdarkly.com", this._backendUrl[0] === "/" && (this._backendUrl = new URL(this._backendUrl, document.baseURI).href);
    const t = new Ga(`${this._backendUrl}`, {
      headers: {}
    });
    this.graphqlSDK = ga(t, Za()), this.environment = (p = e.environment) != null ? p : "production", this.appVersion = e.appVersion, this.serviceName = (d = e.serviceName) != null ? d : "browser", typeof e.organizationID == "string" ? this.organizationID = e.organizationID : this.organizationID = e.organizationID.toString(), this.isRunningOnHighlight = this.organizationID === "1" || this.organizationID === "1jdkoe52", this.firstloadVersion = e.firstloadVersion || "unknown", this.sessionShortcut = e.sessionShortcut || !1, this._onToggleFeedbackFormVisibility = () => {
    };
    const b = e, { firstloadVersion: i } = b, r = Qe(b, ["firstloadVersion"]);
    this._optionsInternal = r, this.listeners = [], this.events = [], this.hasSessionUnloaded = !1, this.hasPushedData = !1, window.Intercom && window.Intercom("onShow", () => {
      window.Intercom("update", {
        highlightSessionURL: this.getCurrentSessionURLWithTimestamp()
      }), this.addProperties({ event: "Intercom onShow" });
    }), this._eventBytesSinceSnapshot = 0, this._lastSnapshotTime = (/* @__PURE__ */ new Date()).getTime(), this._lastVisibilityChangeTime = (/* @__PURE__ */ new Date()).getTime();
  }
  identify(e, t = {}, i) {
    if (!e || e === "") {
      Fe(
        "identify",
        "warn",
        "Highlight's identify() call was passed an empty identifier.",
        { user_identifier: e, user_object: t }
      );
      return;
    }
    this.sessionData.userIdentifier = e.toString(), this.sessionData.userObject = t, De(
      ve.USER_IDENTIFIER,
      e.toString()
    ), De(ve.USER_OBJECT, JSON.stringify(t)), this._worker.postMessage({
      message: {
        type: Je.Identify,
        userIdentifier: e,
        userObject: t,
        source: i
      }
    });
  }
  track(e, t) {
    this.addProperties(re(x({}, t), { event: e }));
  }
  addProperties(e = {}, t) {
    const i = x({}, e);
    Object.entries(i).forEach(([r, n]) => {
      try {
        structuredClone(n);
      } catch (o) {
        delete i[r];
      }
    }), this._worker.postMessage({
      message: {
        type: Je.Properties,
        propertiesObject: i,
        propertyType: t
      }
    });
  }
  start(e) {
    return ne(this, null, function* () {
      var t, i, r, n, o, a, l, u;
      if (!((t = navigator == null ? void 0 : navigator.userAgent) != null && t.includes("Googlebot") || (i = navigator == null ? void 0 : navigator.userAgent) != null && i.includes("AdsBot")))
        try {
          if (e != null && e.forceNew) {
            yield this._reset(e);
            return;
          }
          if (e != null && e.sessionKey && (e == null ? void 0 : e.sessionKey) !== this.sessionData.sessionKey) {
            yield this._reset(re(x({}, e), { forceNew: !0 }));
            return;
          }
          this.logger.log(
            "Initializing...",
            e,
            this.sessionData,
            this.options
          ), this.sessionData = (r = ts(this.sessionData.sessionSecureID)) != null ? r : this.sessionData, (n = this.sessionData) != null && n.sessionStartTime ? this._recordingStartTime = (o = this.sessionData) == null ? void 0 : o.sessionStartTime : (this._recordingStartTime = (/* @__PURE__ */ new Date()).getTime(), this.sessionData.sessionStartTime = this._recordingStartTime);
          let c = Ce(Kr.CLIENT_ID);
          c || (c = is(), De(Kr.CLIENT_ID, c));
          let h;
          this.options.disableSessionRecording || this.options.disableNetworkRecording !== void 0 || typeof this.options.networkRecording == "boolean" ? h = !1 : h = ((a = this.options.networkRecording) == null ? void 0 : a.recordHeadersAndBody) || !1;
          let p = [];
          if (typeof this.options.networkRecording == "object" && ((l = this.options.networkRecording.destinationDomains) != null && l.length) && (p = this.options.networkRecording.destinationDomains), this._isCrossOriginIframe)
            yield this._setupCrossOriginIframe();
          else {
            const G = yield this.graphqlSDK.initializeSession({
              organization_verbose_id: this.organizationID,
              enable_strict_privacy: this.privacySetting === "strict",
              privacy_setting: this.privacySetting,
              enable_recording_network_contents: h,
              clientVersion: this.firstloadVersion,
              firstloadVersion: this.firstloadVersion,
              clientConfig: JSON.stringify(this._optionsInternal),
              environment: this.environment,
              id: c,
              appVersion: this.appVersion,
              serviceName: this.serviceName,
              session_secure_id: this.sessionData.sessionSecureID,
              session_key: this.sessionData.sessionKey,
              client_id: c,
              network_recording_domains: p,
              disable_session_recording: this.options.disableSessionRecording
            });
            if (G.initializeSession.secure_id !== this.sessionData.sessionSecureID && this.logger.log(
              `Unexpected secure id returned by initializeSession: ${G.initializeSession.secure_id}, expected ${this.sessionData.sessionSecureID}`
            ), this.sessionData.sessionSecureID = G.initializeSession.secure_id, this.sessionData.projectID = parseInt(
              ((u = G == null ? void 0 : G.initializeSession) == null ? void 0 : u.project_id) || "0"
            ), !this.sessionData.projectID || !this.sessionData.sessionSecureID) {
              console.error(
                "Failed to initialize Highlight; an error occurred on our end.",
                this.sessionData
              );
              return;
            }
          }
          ss(""), Zt(this.sessionData), this.logger.log(
            `Loaded Highlight
Remote: ${this._backendUrl}
Project ID: ${this.sessionData.projectID}
SessionSecureID: ${this.sessionData.sessionSecureID}`
          ), this.options.sessionSecureID = this.sessionData.sessionSecureID, this._worker.postMessage({
            message: {
              type: Je.Initialize,
              sessionSecureID: this.sessionData.sessionSecureID,
              backend: this._backendUrl,
              debug: !!this.debugOptions.clientInteractions,
              recordingStartTime: this._recordingStartTime
            }
          });
          for (const G of this._integrations)
            G.init(this.sessionData.sessionSecureID);
          if (this.sessionData.userIdentifier && this.identify(
            this.sessionData.userIdentifier,
            this.sessionData.userObject
          ), this.pushPayloadTimerId && (clearTimeout(this.pushPayloadTimerId), this.pushPayloadTimerId = void 0), this._isCrossOriginIframe || (this.pushPayloadTimerId = setTimeout(() => {
            this._save();
          }, Fr)), this.options.disableSessionRecording) {
            this.logger.log(
              "Highlight is NOT RECORDING a session replay per H.init setting."
            ), this.ready = !0, this.state = "Recording", this.manualStopped = !1;
            return;
          }
          const d = (G, S) => {
            S && this.logger.log("received isCheckout emit", { event: G }), this.events.push(G);
          };
          d.bind(this);
          const b = !!this._recordStop;
          this._recordStop && (this._recordStop(), this._recordStop = void 0);
          const [m, f] = Xm(
            this.privacySetting
          );
          this._recordStop = Ye({
            ignoreClass: "highlight-ignore",
            blockClass: "highlight-block",
            emit: d,
            recordCrossOriginIframes: this.options.recordCrossOriginIframe,
            privacySetting: this.privacySetting,
            maskAllInputs: m,
            maskInputOptions: f,
            recordCanvas: this.enableCanvasRecording,
            sampling: {
              canvas: {
                fps: this.samplingStrategy.canvas,
                fpsManual: this.samplingStrategy.canvasManualSnapshot,
                resizeFactor: this.samplingStrategy.canvasFactor,
                clearWebGLBuffer: this.samplingStrategy.canvasClearWebGLBuffer,
                initialSnapshotDelay: this.samplingStrategy.canvasInitialSnapshotDelay,
                dataURLOptions: this.samplingStrategy.dataUrlOptions,
                maxSnapshotDimension: this.samplingStrategy.canvasMaxSnapshotDimension
              }
            },
            keepIframeSrcFn: (G) => !this.options.recordCrossOriginIframe,
            inlineImages: this.inlineImages,
            inlineVideos: this.inlineVideos,
            collectFonts: this.inlineImages,
            inlineStylesheet: this.inlineStylesheet,
            plugins: [Qa()],
            logger: typeof this.options.debug == "boolean" && this.options.debug || typeof this.options.debug == "object" && this.options.debug.domRecording ? {
              debug: this.logger.log,
              warn: Fe.bind("RecordSDK", "warn")
            } : void 0
          }), b || this.options.recordCrossOriginIframe && this._setupCrossOriginIframeParent(), document.referrer && (window && document.referrer.includes(window.location.origin) || (this.addCustomEvent("Referrer", document.referrer), this.addProperties(
            { referrer: document.referrer },
            { type: "session" }
          ))), this.sessionData.sessionKey && this.addProperties(
            {
              sessionKey: this.sessionData.sessionKey
            },
            { type: "session" }
          ), this._setupWindowListeners(), this.ready = !0, this.state = "Recording", this.manualStopped = !1;
        } catch (c) {
          Fe("initializeSession _setupWindowListeners", "warn", c);
        }
    });
  }
  _visibilityHandler(e) {
    return ne(this, null, function* () {
      if (this.manualStopped) {
        this.logger.log("Ignoring visibility event due to manual stop.");
        return;
      }
      (/* @__PURE__ */ new Date()).getTime() - this._lastVisibilityChangeTime < Va || (this._lastVisibilityChangeTime = (/* @__PURE__ */ new Date()).getTime(), this.logger.log(`Detected window ${e ? "hidden" : "visible"}.`), e ? (this.addCustomEvent("TabHidden", !0), this.options.disableBackgroundRecording && this.stop()) : (this.options.disableBackgroundRecording && (yield this.start()), this.addCustomEvent("TabHidden", !1)));
    });
  }
  _setupCrossOriginIframe() {
    return ne(this, null, function* () {
      this.logger.log("highlight in cross-origin iframe is waiting "), yield new Promise((e) => {
        const t = (i) => {
          if (i.data.highlight === _n) {
            const r = i.data;
            this.logger.log("highlight got window message ", r), this.sessionData.projectID = r.projectID, this.sessionData.sessionSecureID = r.sessionSecureID, window.parent.postMessage(
              {
                highlight: $n
              },
              "*"
            ), window.removeEventListener("message", t), e();
          }
        };
        window.addEventListener("message", t);
      });
    });
  }
  _setupCrossOriginIframeParent() {
    this.logger.log(
      "highlight setting up cross origin iframe parent notification"
    ), setInterval(() => {
      window.document.querySelectorAll("iframe").forEach((e) => {
        var t;
        (t = e.contentWindow) == null || t.postMessage(
          {
            highlight: _n,
            projectID: this.sessionData.projectID,
            sessionSecureID: this.sessionData.sessionSecureID
          },
          "*"
        );
      });
    }, Fr), window.addEventListener("message", (e) => {
      e.data.highlight === $n && this.logger.log(
        "highlight got response from initialized iframe"
      );
    });
  }
  _setupWindowListeners() {
    var i;
    try {
      const r = this;
      this.enableSegmentIntegration && this.listeners.push(
        wm((o) => {
          if (o.type === "track") {
            const a = {};
            a["segment-event"] = o.event, r.addProperties(a, {
              type: "track",
              source: "segment"
            });
          } else if (o.type === "identify") {
            const a = o.userId.replace(
              /^"(.*)"$/,
              "$1"
            );
            r.identify(
              a,
              o.traits,
              "segment"
            );
          }
        })
      ), this.listeners.push(
        Im((o) => {
          this.reloaded ? (this.addCustomEvent("Reload", o), this.reloaded = !1, r.addProperties(
            { reload: !0 },
            { type: "session" }
          )) : this.addCustomEvent("Navigate", o);
        })
      ), this.listeners.push(
        Sa(
          (o) => {
            this.addCustomEvent("Viewport", o);
          }
        )
      ), this.listeners.push(
        Wm((o, a) => {
          let l = null, u = null;
          if (a && a.target) {
            const c = a.target;
            l = Ia(c), u = c.textContent, u && u.length > 2e3 && (u = u.substring(0, 2e3));
          }
          this.addCustomEvent("Click", {
            clickTarget: o,
            clickTextContent: u,
            clickSelector: l
          });
        })
      ), this.listeners.push(
        Rm((o) => {
          o && this.addCustomEvent("Focus", o);
        })
      ), this.sessionShortcut && km(this.sessionShortcut, () => {
        window.open(
          this.getCurrentSessionURLWithTimestamp(),
          "_blank"
        );
      }), this._hasPreviouslyInitialized || ((i = window.electron) != null && i.ipcRenderer ? (window.electron.ipcRenderer.on(
        "highlight.run",
        ({ visible: o }) => {
          this._visibilityHandler(!o);
        }
      ), this.logger.log("Set up Electron highlight.run events.")) : (Cm(
        (o) => this._visibilityHandler(o)
      ), this.logger.log("Set up document visibility listener.")), this._hasPreviouslyInitialized = !0);
      const n = () => {
        this.hasSessionUnloaded = !0, this.pushPayloadTimerId && (clearTimeout(this.pushPayloadTimerId), this.pushPayloadTimerId = void 0);
      };
      window.addEventListener("beforeunload", n), this.listeners.push(
        () => window.removeEventListener("beforeunload", n)
      );
    } catch (r) {
      Fe("initializeSession _setupWindowListeners", "warn", r);
    }
    const e = () => {
      this.addCustomEvent("Page Unload", ""), ss(this.sessionData.sessionSecureID), Zt(this.sessionData);
    };
    if (window.addEventListener("beforeunload", e), this.listeners.push(
      () => window.removeEventListener("beforeunload", e)
    ), navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPhone/i)) {
      const r = () => {
        this.addCustomEvent("Page Unload", ""), ss(this.sessionData.sessionSecureID), Zt(this.sessionData);
      };
      window.addEventListener("pagehide", r), this.listeners.push(
        () => window.removeEventListener("beforeunload", r)
      );
    }
  }
  /**
   * Stops Highlight from recording.
   * @param manual The end user requested to stop recording.
   */
  stop(e) {
    this.manualStopped = !!e, this.manualStopped && this.addCustomEvent(
      "Stop",
      "H.stop() was called which stops Highlight from recording."
    ), this.state = "NotRecording", e && this._recordStop && (this._recordStop(), this._recordStop = void 0), this.listeners.forEach((t) => t()), this.listeners = [];
  }
  /**
   * Returns the current timestamp for the current session.
   */
  getCurrentSessionURLWithTimestamp() {
    const e = (/* @__PURE__ */ new Date()).getTime(), { projectID: t, sessionSecureID: i } = this.sessionData, r = (e - this._recordingStartTime) / 1e3;
    return `https://${zr}/${t}/sessions/${i}?ts=${r}`;
  }
  getCurrentSessionURL() {
    const e = this.sessionData.projectID, t = this.sessionData.sessionSecureID;
    return e && t ? `https://${zr}/${e}/sessions/${t}` : null;
  }
  snapshot(e) {
    return ne(this, null, function* () {
      yield Ye.snapshotCanvas(e);
    });
  }
  addSessionFeedback({
    timestamp: e,
    verbatim: t,
    user_email: i,
    user_name: r
  }) {
    var n;
    this._worker.postMessage({
      message: {
        type: Je.Feedback,
        verbatim: t,
        timestamp: e,
        userName: r || this.sessionData.userIdentifier,
        userEmail: i || ((n = this.sessionData.userObject) == null ? void 0 : n.name)
      }
    });
  }
  // Reset the events array and push to a backend.
  _save() {
    return ne(this, null, function* () {
      var e;
      try {
        this.state === "Recording" && this.listeners && !this.sessionData.sessionKey && this.sessionData.sessionStartTime && Date.now() - this.sessionData.sessionStartTime > Xa && (this.logger.log("Resetting session", {
          start: this.sessionData.sessionStartTime
        }), yield this._reset({}));
        let t;
        ((e = this.options) == null ? void 0 : e.sendMode) === "local" && (t = (i) => ne(this, null, function* () {
          let r = new Blob(
            [
              JSON.stringify({
                query: Ja(va),
                variables: i
              })
            ],
            {
              type: "application/json"
            }
          );
          return yield window.fetch(`${this._backendUrl}`, {
            method: "POST",
            body: r
          }), 0;
        })), yield this._sendPayload({ sendFn: t }), this.hasPushedData = !0, this.sessionData.lastPushTime = Date.now(), Zt(this.sessionData);
      } catch (t) {
        Fe("_save", "warn", t);
      }
      this.state === "Recording" && (this.pushPayloadTimerId && (clearTimeout(this.pushPayloadTimerId), this.pushPayloadTimerId = void 0), this.pushPayloadTimerId = setTimeout(() => {
        this._save();
      }, Wa));
    });
  }
  /**
   * This proxy should be used instead of rrweb's native addCustomEvent.
   * The proxy makes sure recording has started before emitting a custom event.
   */
  addCustomEvent(e, t) {
    if (this.state === "NotRecording") {
      let i;
      const r = () => {
        clearInterval(i), this.state === "Recording" && this.events.length > 0 ? jn(e, t) : i = setTimeout(r, 500);
      };
      i = setTimeout(r, 500);
    } else this.state === "Recording" && (this.events.length > 0 || this.hasPushedData) && jn(e, t);
  }
  _sendPayload(t) {
    return ne(this, arguments, function* ({
      sendFn: e
    }) {
      const i = [...this.events], { bytes: r, time: n } = this.enableCanvasRecording ? Hr.canvas : Hr.normal;
      this._eventBytesSinceSnapshot >= r && (/* @__PURE__ */ new Date()).getTime() - this._lastSnapshotTime >= n && this.takeFullSnapshot(), this.logger.log(
        `Sending: ${i.length} events, 
To: ${this._backendUrl}
Org: ${this.organizationID}
SessionSecureID: ${this.sessionData.sessionSecureID}`
      );
      const o = (/* @__PURE__ */ new Date()).getTime(), a = Fm();
      if (e) {
        const l = {
          session_secure_id: this.sessionData.sessionSecureID,
          payload_id: o.toString(),
          events: { events: i },
          messages: Ra({ messages: [] }),
          resources: JSON.stringify({ resources: [] }),
          web_socket_events: JSON.stringify({
            webSocketEvents: []
          }),
          errors: [],
          is_beacon: !1,
          has_session_unloaded: this.hasSessionUnloaded,
          highlight_logs: a || void 0
        }, { compressedBase64: u } = yield tf(l);
        yield e({
          session_secure_id: this.sessionData.sessionSecureID,
          payload_id: o.toString(),
          data: u
        });
      } else
        this._worker.postMessage({
          message: {
            type: Je.AsyncEvents,
            id: o,
            events: i,
            messages: [],
            errors: [],
            resourcesString: JSON.stringify({ resources: [] }),
            webSocketEventsString: JSON.stringify({
              webSocketEvents: []
            }),
            hasSessionUnloaded: this.hasSessionUnloaded,
            highlightLogs: a
          }
        });
      Zt(this.sessionData), this.events = this.events.slice(i.length), zm(a);
    });
  }
  takeFullSnapshot() {
    if (!this._recordStop) {
      this.logger.log("skipping full snapshot as rrweb is not running");
      return;
    }
    this.logger.log("taking full snapshot", {
      bytesSinceSnapshot: this._eventBytesSinceSnapshot,
      lastSnapshotTime: this._lastSnapshotTime
    }), Ye.takeFullSnapshot(), this._eventBytesSinceSnapshot = 0, this._lastSnapshotTime = (/* @__PURE__ */ new Date()).getTime();
  }
  register(e, t) {
    this._integrations.push(new Ca(e, t));
  }
  getHooks(e) {
    return this._integrations.flatMap((t) => {
      var i, r;
      return (r = (i = t.getHooks) == null ? void 0 : i.call(t, e)) != null ? r : [];
    });
  }
  getRecordingState() {
    var e;
    return (e = this == null ? void 0 : this.state) != null ? e : "NotRecording";
  }
  getSession() {
    const e = this.sessionData.sessionSecureID, t = ts(e);
    if (!t)
      return null;
    const i = `${this.getFrontendUrl()}/sessions/${e}`;
    if (!i || !(t == null ? void 0 : t.sessionStartTime))
      return null;
    const n = (/* @__PURE__ */ new Date()).getTime();
    let o;
    try {
      o = new URL(i);
    } catch (u) {
      return Fe(
        "identify",
        "warn",
        `failed to construct session url from ${i}`,
        u
      ), null;
    }
    const a = new URL(o), l = (n - this._recordingStartTime) / 1e3;
    return a.searchParams.set("ts", l.toString()), {
      url: o.toString(),
      urlWithTimestamp: a.toString(),
      sessionSecureID: e
    };
  }
  getFrontendUrl() {
    var t, i;
    const e = this._backendUrl.match(wa);
    if (e && ((t = e == null ? void 0 : e.groups) != null && t.domain)) {
      const r = (i = e.groups.domain) != null ? i : "";
      return `https://${xa[r]}${ka}`;
    }
    return La;
  }
}
class Ef extends Ya {
  constructor(t) {
    super(t);
    k(this, "record");
    k(this, "options");
    this.options = t;
  }
  initialize(t, i) {
    var r, n, o, a, l, u, c, h, p;
    try {
      if (typeof window == "undefined" || typeof document == "undefined") {
        console.warn(
          "@launchdarkly/session-replay is not initializing because it is not supported in this environment."
        );
        return;
      }
      if (typeof Worker == "undefined") {
        console.warn(
          "@launchdarkly/session-replay is not initializing because Worker is not supported."
        );
        return;
      }
      if (!t) {
        console.warn(
          "@launchdarkly/session-replay is not initializing because the SDK credential is undefined."
        );
        return;
      }
      this.configureSession(t, i);
      const d = re(x({}, i), {
        organizationID: t,
        firstloadVersion: Na,
        environment: (i == null ? void 0 : i.environment) || "production",
        appVersion: i == null ? void 0 : i.version,
        sessionSecureID: this.sessionSecureID,
        privacySetting: (r = i == null ? void 0 : i.privacySetting) != null ? r : "strict"
      });
      this.record = new af(d), i != null && i.manualStart || this.record.start(), Pa.load(this.record), !((o = (n = i == null ? void 0 : i.integrations) == null ? void 0 : n.mixpanel) != null && o.disabled) && ((l = (a = i == null ? void 0 : i.integrations) == null ? void 0 : a.mixpanel) != null && l.projectToken) && lf(i.integrations.mixpanel), !((c = (u = i == null ? void 0 : i.integrations) == null ? void 0 : u.amplitude) != null && c.disabled) && ((p = (h = i == null ? void 0 : i.integrations) == null ? void 0 : h.amplitude) != null && p.apiKey) && nf(i.integrations.amplitude);
    } catch (d) {
      Fe(
        "Error initializing @launchdarkly/session-replay SDK",
        "error",
        d
      );
    }
  }
  getMetadata() {
    return {
      name: "@launchdarkly/session-replay"
    };
  }
  register(t, i) {
    var r;
    (r = this.record) == null || r.register(t, i);
  }
  getHooks(t) {
    var r, n, o, a;
    const i = x(x({
      [Ma]: t.sdk.name,
      [Ha]: t.sdk.version,
      [za]: t.clientSideId,
      [Fa]: "LaunchDarkly"
    }, (r = t.application) != null && r.id ? { [Ka]: t.application.id } : {}), (n = t.application) != null && n.version ? {
      [Ua]: t.application.version
    } : {});
    return this.initialize(
      (a = (o = t.sdkKey) != null ? o : t.mobileKey) != null ? a : t.clientSideId,
      this.options
    ), [
      {
        getMetadata: () => ({
          name: "@launchdarkly/session-replay/hooks"
        }),
        afterIdentify: (l, u, c) => {
          var h, p, d, b, m, f, G, S;
          for (const V of (d = (p = (h = this.record) == null ? void 0 : h.getHooks) == null ? void 0 : p.call(h, t)) != null ? d : [])
            (b = V.afterIdentify) == null || b.call(V, l, u, c);
          if (c.status === "completed") {
            const V = re(x({}, Ta(l.context)), {
              key: (G = (f = (m = this.options) == null ? void 0 : m.contextFriendlyName) == null ? void 0 : f.call(
                m,
                l.context
              )) != null ? G : Mr(l.context),
              canonicalKey: Mr(l.context)
            });
            (S = this.record) == null || S.identify(
              V.key,
              x(x({}, i), V),
              "LaunchDarkly"
            );
          }
          return u;
        },
        afterEvaluation: (l, u, c) => {
          var h, p, d, b;
          for (const m of (d = (p = (h = this.record) == null ? void 0 : h.getHooks) == null ? void 0 : p.call(h, t)) != null ? d : [])
            (b = m.afterEvaluation) == null || b.call(m, l, u, c);
          return u;
        },
        afterTrack: (l) => {
          var u, c, h, p, d;
          for (const b of (h = (c = (u = this.record) == null ? void 0 : u.getHooks) == null ? void 0 : c.call(u, t)) != null ? h : [])
            (p = b.afterTrack) == null || p.call(b, l);
          (d = this.record) == null || d.track(l.key, {
            data: l.data,
            value: l.metricValue
          });
        }
      }
    ];
  }
}
export {
  Wm as C,
  Rm as F,
  _n as I,
  Je as M,
  Im as P,
  Ef as R,
  wm as S,
  rf as W,
  $n as a,
  km as b,
  Cm as c,
  jn as d,
  zm as e,
  Qa as f,
  Fm as g,
  Xm as h,
  nf as i,
  tf as p,
  Ye as r,
  lf as s
};
//# sourceMappingURL=record-DV9GPmGE.js.map
