'use strict';

var jsSdkCommon = require('@launchdarkly/js-sdk-common');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var jsSdkCommon__namespace = /*#__PURE__*/_interopNamespaceDefault(jsSdkCommon);

exports.DataSourceState = void 0;
(function (DataSourceState) {
    DataSourceState["Initializing"] = "INITIALIZING";
    DataSourceState["Valid"] = "VALID";
    DataSourceState["Interrupted"] = "INTERRUPTED";
    DataSourceState["SetOffline"] = "SET_OFFLINE";
    DataSourceState["Closed"] = "CLOSED";
    // TODO: SDK-702 - Implement network availability behaviors
    // NetworkUnavailable,
})(exports.DataSourceState || (exports.DataSourceState = {}));

// eslint-disable-next-line max-classes-per-file
function isOk(status) {
    return status >= 200 && status <= 299;
}
class LDRequestError extends Error {
    constructor(message, status) {
        super(message);
        this.status = status;
        this.name = 'LaunchDarklyRequestError';
    }
}
/**
 * Note: The requestor is implemented independently from polling such that it can be used to
 * make a one-off request.
 */
class Requestor {
    constructor(_requests, _uri, _headers, _method, _body) {
        this._requests = _requests;
        this._uri = _uri;
        this._headers = _headers;
        this._method = _method;
        this._body = _body;
    }
    async requestPayload() {
        let status;
        try {
            const res = await this._requests.fetch(this._uri, {
                method: this._method,
                headers: this._headers,
                body: this._body,
            });
            if (isOk(res.status)) {
                return await res.text();
            }
            // Assigning so it can be thrown after the try/catch.
            status = res.status;
        }
        catch (err) {
            throw new LDRequestError(err?.message);
        }
        throw new LDRequestError(`Unexpected status code: ${status}`, status);
    }
}
function makeRequestor(plainContextString, serviceEndpoints, paths, requests, encoding, baseHeaders, baseQueryParams, withReasons, useReport, secureModeHash) {
    let body;
    let method = 'GET';
    const headers = { ...baseHeaders };
    if (useReport) {
        method = 'REPORT';
        headers['content-type'] = 'application/json';
        body = plainContextString; // context is in body for REPORT
    }
    const path = useReport
        ? paths.pathReport(encoding, plainContextString)
        : paths.pathGet(encoding, plainContextString);
    const parameters = [...(baseQueryParams ?? [])];
    if (withReasons) {
        parameters.push({ key: 'withReasons', value: 'true' });
    }
    if (secureModeHash) {
        parameters.push({ key: 'h', value: secureModeHash });
    }
    const uri = jsSdkCommon.getPollingUri(serviceEndpoints, path, parameters);
    return new Requestor(requests, uri, headers, method, body);
}

// eslint-disable-next-line max-classes-per-file
const validators = {
    logger: jsSdkCommon.TypeValidators.Object,
    maxCachedContexts: jsSdkCommon.TypeValidators.numberWithMin(0),
    baseUri: jsSdkCommon.TypeValidators.String,
    streamUri: jsSdkCommon.TypeValidators.String,
    eventsUri: jsSdkCommon.TypeValidators.String,
    capacity: jsSdkCommon.TypeValidators.numberWithMin(1),
    diagnosticRecordingInterval: jsSdkCommon.TypeValidators.numberWithMin(2),
    flushInterval: jsSdkCommon.TypeValidators.numberWithMin(2),
    streamInitialReconnectDelay: jsSdkCommon.TypeValidators.numberWithMin(0),
    allAttributesPrivate: jsSdkCommon.TypeValidators.Boolean,
    debug: jsSdkCommon.TypeValidators.Boolean,
    diagnosticOptOut: jsSdkCommon.TypeValidators.Boolean,
    withReasons: jsSdkCommon.TypeValidators.Boolean,
    sendEvents: jsSdkCommon.TypeValidators.Boolean,
    pollInterval: jsSdkCommon.TypeValidators.numberWithMin(30),
    useReport: jsSdkCommon.TypeValidators.Boolean,
    privateAttributes: jsSdkCommon.TypeValidators.StringArray,
    applicationInfo: jsSdkCommon.TypeValidators.Object,
    wrapperName: jsSdkCommon.TypeValidators.String,
    wrapperVersion: jsSdkCommon.TypeValidators.String,
    payloadFilterKey: jsSdkCommon.TypeValidators.stringMatchingRegex(/^[a-zA-Z0-9](\w|\.|-)*$/),
    hooks: jsSdkCommon.TypeValidators.createTypeArray('Hook[]', {}),
    inspectors: jsSdkCommon.TypeValidators.createTypeArray('LDInspection', {}),
};

const DEFAULT_POLLING_INTERVAL = 60 * 5;
const DEFAULT_POLLING = 'https://clientsdk.launchdarkly.com';
const DEFAULT_STREAM = 'https://clientstream.launchdarkly.com';
function ensureSafeLogger(logger) {
    if (logger instanceof jsSdkCommon.SafeLogger) {
        return logger;
    }
    // Even if logger is not defined this will produce a valid logger.
    return jsSdkCommon.createSafeLogger(logger);
}
class ConfigurationImpl {
    constructor(pristineOptions = {}, internalOptions = {
        getImplementationHooks: () => [],
        credentialType: 'mobileKey',
    }) {
        this.logger = jsSdkCommon.createSafeLogger();
        // Naming conventions is not followed for these lines because the config validation
        // accesses members based on the keys of the options. (sdk-763)
        // eslint-disable-next-line @typescript-eslint/naming-convention
        this.baseUri = DEFAULT_POLLING;
        // eslint-disable-next-line @typescript-eslint/naming-convention
        this.eventsUri = jsSdkCommon.ServiceEndpoints.DEFAULT_EVENTS;
        // eslint-disable-next-line @typescript-eslint/naming-convention
        this.streamUri = DEFAULT_STREAM;
        this.maxCachedContexts = 5;
        this.capacity = 100;
        this.diagnosticRecordingInterval = 900;
        this.flushInterval = 30;
        this.streamInitialReconnectDelay = 1;
        this.allAttributesPrivate = false;
        this.debug = false;
        this.diagnosticOptOut = false;
        this.sendEvents = true;
        this.sendLDHeaders = true;
        this.useReport = false;
        this.withReasons = false;
        this.privateAttributes = [];
        this.pollInterval = DEFAULT_POLLING_INTERVAL;
        this.hooks = [];
        this.inspectors = [];
        this.logger = ensureSafeLogger(pristineOptions.logger);
        const errors = this._validateTypesAndNames(pristineOptions);
        errors.forEach((e) => this.logger.warn(e));
        this.serviceEndpoints = new jsSdkCommon.ServiceEndpoints(this.streamUri, this.baseUri, this.eventsUri, internalOptions.analyticsEventPath, internalOptions.diagnosticEventPath, internalOptions.includeAuthorizationHeader, pristineOptions.payloadFilterKey);
        this.useReport = pristineOptions.useReport ?? false;
        this.tags = new jsSdkCommon.ApplicationTags({ application: this.applicationInfo, logger: this.logger });
        this.userAgentHeaderName = internalOptions.userAgentHeaderName ?? 'user-agent';
        this.trackEventModifier = internalOptions.trackEventModifier ?? ((event) => event);
        this.credentialType = internalOptions.credentialType;
        this.getImplementationHooks = internalOptions.getImplementationHooks;
    }
    _validateTypesAndNames(pristineOptions) {
        const errors = [];
        Object.entries(pristineOptions).forEach(([k, v]) => {
            const validator = validators[k];
            if (validator) {
                if (!validator.is(v)) {
                    const validatorType = validator.getType();
                    if (validatorType === 'boolean') {
                        errors.push(jsSdkCommon.OptionMessages.wrongOptionTypeBoolean(k, typeof v));
                        this[k] = !!v;
                    }
                    else if (validatorType === 'boolean | undefined | null') {
                        errors.push(jsSdkCommon.OptionMessages.wrongOptionTypeBoolean(k, typeof v));
                        if (typeof v !== 'boolean' && typeof v !== 'undefined' && v !== null) {
                            this[k] = !!v;
                        }
                    }
                    else if (validator instanceof jsSdkCommon.NumberWithMinimum && jsSdkCommon.TypeValidators.Number.is(v)) {
                        const { min } = validator;
                        errors.push(jsSdkCommon.OptionMessages.optionBelowMinimum(k, v, min));
                        this[k] = min;
                    }
                    else {
                        errors.push(jsSdkCommon.OptionMessages.wrongOptionType(k, validator.getType(), typeof v));
                    }
                }
                else if (k === 'logger') ;
                else {
                    // if an option is explicitly null, coerce to undefined
                    this[k] = v ?? undefined;
                }
            }
            else {
                errors.push(jsSdkCommon.OptionMessages.unknownOption(k));
            }
        });
        return errors;
    }
}

async function digest(hasher, encoding) {
    if (hasher.digest) {
        return hasher.digest(encoding);
    }
    if (hasher.asyncDigest) {
        return hasher.asyncDigest(encoding);
    }
    // This represents an error in platform implementation.
    throw new Error('Platform must implement digest or asyncDigest');
}

/**
 * This function will retrieve a previously generated key for the given {@link storageKey} if it
 * exists or generate and store one on the fly if it does not already exist.
 * @param storageKey keyed storage location where the generated key should live.  See {@link namespaceForGeneratedContextKey}
 * for related exmaples of generating a storage key and usage.
 * @param platform crypto and storage implementations for necessary operations
 * @returns the generated key
 */
const getOrGenerateKey = async (storageKey, { crypto, storage }) => {
    let generatedKey = await storage?.get(storageKey);
    if (!generatedKey) {
        generatedKey = crypto.randomUUID();
        await storage?.set(storageKey, generatedKey);
    }
    return generatedKey;
};

/**
 * Hashes the input and encodes it as base64
 */
function hashAndBase64Encode(crypto) {
    return async (input) => digest(crypto.createHash('sha256').update(input), 'base64');
}
const noop = async (input) => input; // no-op transform
async function concatNamespacesAndValues(parts) {
    const processedParts = await Promise.all(parts.map((part) => part.transform(part.value))); // use the transform from each part to transform the value
    return processedParts.join('_');
}
async function namespaceForEnvironment(crypto, sdkKey) {
    return concatNamespacesAndValues([
        { value: 'LaunchDarkly', transform: noop },
        { value: sdkKey, transform: hashAndBase64Encode(crypto) }, // hash sdk key and encode it
    ]);
}
/**
 * @deprecated prefer {@link namespaceForGeneratedContextKey}. At one time we only generated keys for
 * anonymous contexts and they were namespaced in LaunchDarkly_AnonymousKeys.  Eventually we started
 * generating context keys for non-anonymous contexts such as for the Auto Environment Attributes
 * feature and those were namespaced in LaunchDarkly_ContextKeys.  This function can be removed
 * when the data under the LaunchDarkly_AnonymousKeys namespace is merged with data under the
 * LaunchDarkly_ContextKeys namespace.
 */
async function namespaceForAnonymousGeneratedContextKey(kind) {
    return concatNamespacesAndValues([
        { value: 'LaunchDarkly', transform: noop },
        { value: 'AnonymousKeys', transform: noop },
        { value: kind, transform: noop }, // existing SDKs are not hashing or encoding this kind, though they should have
    ]);
}
async function namespaceForGeneratedContextKey(kind) {
    return concatNamespacesAndValues([
        { value: 'LaunchDarkly', transform: noop },
        { value: 'ContextKeys', transform: noop },
        { value: kind, transform: noop }, // existing SDKs are not hashing or encoding this kind, though they should have
    ]);
}
async function namespaceForContextIndex(environmentNamespace) {
    return concatNamespacesAndValues([
        { value: environmentNamespace, transform: noop },
        { value: 'ContextIndex', transform: noop },
    ]);
}
async function namespaceForContextData(crypto, environmentNamespace, context) {
    return concatNamespacesAndValues([
        { value: environmentNamespace, transform: noop },
        { value: context.canonicalKey, transform: hashAndBase64Encode(crypto) }, // hash and encode canonical key
    ]);
}

/* eslint-disable @typescript-eslint/naming-convention */
const { isLegacyUser: isLegacyUser$1, isSingleKind: isSingleKind$1, isMultiKind: isMultiKind$1 } = jsSdkCommon.internal;
const defaultAutoEnvSchemaVersion = '1.0';
const toMulti = (c) => {
    const { kind, ...contextCommon } = c;
    return {
        kind: 'multi',
        [kind]: contextCommon,
    };
};
/**
 * Clones the LDApplication object and populates the key, envAttributesVersion, id and version fields.
 *
 * @param crypto
 * @param info
 * @param applicationInfo
 * @param config
 * @return An LDApplication object with populated key, envAttributesVersion, id and version.
 */
const addApplicationInfo = async ({ crypto, info }, { applicationInfo }) => {
    const { ld_application } = info.platformData();
    let app = jsSdkCommon.deepCompact(ld_application) ?? {};
    const id = applicationInfo?.id || app?.id;
    if (id) {
        const version = applicationInfo?.version || app?.version;
        const name = applicationInfo?.name || app?.name;
        const versionName = applicationInfo?.versionName || app?.versionName;
        app = {
            ...app,
            id,
            // only add props if they are defined
            ...(version ? { version } : {}),
            ...(name ? { name } : {}),
            ...(versionName ? { versionName } : {}),
        };
        app.key = await digest(crypto.createHash('sha256').update(id), 'base64');
        app.envAttributesVersion = app.envAttributesVersion || defaultAutoEnvSchemaVersion;
        return app;
    }
    return undefined;
};
/**
 * Clones the LDDevice object and populates the key and envAttributesVersion field.
 *
 * @param platform
 * @return An LDDevice object with populated key and envAttributesVersion.
 */
const addDeviceInfo = async (platform) => {
    const { ld_device, os } = platform.info.platformData();
    const device = jsSdkCommon.deepCompact(ld_device) ?? {};
    const name = os?.name || device.os?.name;
    const version = os?.version || device.os?.version;
    const family = device.os?.family;
    // only add device.os if there's data
    if (name || version || family) {
        device.os = {
            // only add props if they are defined
            ...(name ? { name } : {}),
            ...(version ? { version } : {}),
            ...(family ? { family } : {}),
        };
    }
    // Check if device has any meaningful data before we return it.
    if (Object.keys(device).filter((k) => k !== 'key' && k !== 'envAttributesVersion').length) {
        const ldDeviceNamespace = await namespaceForGeneratedContextKey('ld_device');
        device.key = await getOrGenerateKey(ldDeviceNamespace, platform);
        device.envAttributesVersion = device.envAttributesVersion || defaultAutoEnvSchemaVersion;
        return device;
    }
    return undefined;
};
const addAutoEnv = async (context, platform, config) => {
    // LDUser is not supported for auto env reporting
    if (isLegacyUser$1(context)) {
        return context;
    }
    let ld_application;
    let ld_device;
    // Check if customer contexts exist. Only override if they are not provided.
    if ((isSingleKind$1(context) && context.kind !== 'ld_application') ||
        (isMultiKind$1(context) && !context.ld_application)) {
        ld_application = await addApplicationInfo(platform, config);
    }
    else {
        config.logger.warn('Not adding ld_application environment attributes because it already exists.');
    }
    if ((isSingleKind$1(context) && context.kind !== 'ld_device') ||
        (isMultiKind$1(context) && !context.ld_device)) {
        ld_device = await addDeviceInfo(platform);
    }
    else {
        config.logger.warn('Not adding ld_device environment attributes because it already exists.');
    }
    // Unable to automatically add environment attributes for kind: {}.  {} already exists.
    if (ld_application || ld_device) {
        const multi = isSingleKind$1(context) ? toMulti(context) : context;
        return {
            ...multi,
            ...(ld_application ? { ld_application } : {}),
            ...(ld_device ? { ld_device } : {}),
        };
    }
    return context;
};

const { isLegacyUser, isMultiKind, isSingleKind } = jsSdkCommon.internal;
/**
 * This is the root ensureKey function. All other ensureKey functions reduce to this.
 *
 * - ensureKeyCommon // private root function
 *  - ensureKeySingle
 *  - ensureKeyMulti
 *  - ensureKeyLegacy
 *    - ensureKey // exported for external use
 *
 * @param kind The LDContext kind
 * @param c The LDContext object
 * @param platform Platform containing crypto and storage needed for storing and querying keys.
 */
const ensureKeyCommon = async (kind, c, platform) => {
    const { anonymous, key } = c;
    if (anonymous && !key) {
        const storageKey = await namespaceForAnonymousGeneratedContextKey(kind);
        // This mutates a cloned copy of the original context from ensureyKey so this is safe.
        // eslint-disable-next-line no-param-reassign
        c.key = await getOrGenerateKey(storageKey, platform);
    }
};
const ensureKeySingle = async (c, platform) => {
    await ensureKeyCommon(c.kind, c, platform);
};
const ensureKeyMulti = async (multiContext, platform) => {
    const { kind, ...singleContexts } = multiContext;
    return Promise.all(Object.entries(singleContexts).map(([k, c]) => ensureKeyCommon(k, c, platform)));
};
const ensureKeyLegacy = async (c, platform) => {
    await ensureKeyCommon('user', c, platform);
};
/**
 * Ensure a key is always present in anonymous contexts. Non-anonymous contexts
 * are not processed and will just be returned as is.
 *
 * @param context
 * @param platform
 */
const ensureKey = async (context, platform) => {
    const cloned = jsSdkCommon.clone(context);
    if (isSingleKind(cloned)) {
        await ensureKeySingle(cloned, platform);
    }
    if (isMultiKind(cloned)) {
        await ensureKeyMulti(cloned, platform);
    }
    if (isLegacyUser(cloned)) {
        await ensureKeyLegacy(cloned, platform);
    }
    return cloned;
};

const createDiagnosticsInitConfig = (config) => ({
    customBaseURI: config.serviceEndpoints.polling !== DEFAULT_POLLING,
    customStreamURI: config.serviceEndpoints.streaming !== DEFAULT_STREAM,
    customEventsURI: config.serviceEndpoints.events !== jsSdkCommon.ServiceEndpoints.DEFAULT_EVENTS,
    eventsCapacity: config.capacity,
    eventsFlushIntervalMillis: jsSdkCommon.secondsToMillis(config.flushInterval),
    reconnectTimeMillis: jsSdkCommon.secondsToMillis(config.streamInitialReconnectDelay),
    diagnosticRecordingIntervalMillis: jsSdkCommon.secondsToMillis(config.diagnosticRecordingInterval),
    allAttributesPrivate: config.allAttributesPrivate,
    // TODO: Implement when corresponding features are implemented.
    usingSecureMode: false,
    bootstrapMode: false,
});

const createDiagnosticsManager = (clientSideID, config, platform) => {
    if (config.sendEvents && !config.diagnosticOptOut) {
        return new jsSdkCommon.internal.DiagnosticsManager(clientSideID, platform, createDiagnosticsInitConfig(config));
    }
    return undefined;
};

function createErrorEvaluationDetail(errorKind, def) {
    return {
        value: def ?? null,
        variationIndex: null,
        reason: { kind: 'ERROR', errorKind },
    };
}
function createSuccessEvaluationDetail(value, variationIndex, reason) {
    const res = {
        value,
        variationIndex: variationIndex ?? null,
        reason: reason ?? null,
    };
    return res;
}

const createEventProcessor = (clientSideID, config, platform, baseHeaders, diagnosticsManager) => {
    if (config.sendEvents) {
        return new jsSdkCommon.internal.EventProcessor({ ...config, eventsCapacity: config.capacity }, new jsSdkCommon.ClientContext(clientSideID, config, platform), baseHeaders, undefined, diagnosticsManager, false);
    }
    return undefined;
};

/**
 * @internal
 */
class EventFactory extends jsSdkCommon.internal.EventFactoryBase {
    evalEventClient(flagKey, value, defaultVal, flag, context, reason) {
        const { trackEvents, debugEventsUntilDate, trackReason, flagVersion, version, variation } = flag;
        return super.evalEvent({
            addExperimentData: trackReason,
            context,
            debugEventsUntilDate,
            defaultVal,
            flagKey,
            reason,
            trackEvents: !!trackEvents,
            value,
            variation,
            version: flagVersion ?? version,
        });
    }
}

/**
 * An index for tracking the most recently used contexts by timestamp with the ability to
 * update entry timestamps and prune out least used contexts above a max capacity provided.
 */
class ContextIndex {
    constructor() {
        this.container = { index: new Array() };
    }
    /**
     * Creates a {@link ContextIndex} from its JSON representation (likely retrieved from persistence).
     * @param json representation of the {@link ContextIndex}
     * @returns the {@link ContextIndex}
     */
    static fromJson(json) {
        const contextIndex = new ContextIndex();
        try {
            contextIndex.container = JSON.parse(json);
        }
        catch (e) {
            /* ignoring error and returning empty index */
        }
        return contextIndex;
    }
    /**
     * @returns the JSON representation of the {@link ContextIndex} (like for saving to persistence)
     */
    toJson() {
        return JSON.stringify(this.container);
    }
    /**
     * Notice that a context has been used and when it was used.  This will update an existing record
     * with the given timestamp, or create a new record if one doesn't exist.
     * @param id of the corresponding context
     * @param timestamp in millis since epoch
     */
    notice(id, timestamp) {
        const entry = this.container.index.find((it) => it.id === id);
        if (entry === undefined) {
            this.container.index.push({ id, timestamp });
        }
        else {
            entry.timestamp = timestamp;
        }
    }
    /**
     * Prune the index to the specified max size and then return the IDs
     * @param maxContexts the maximum number of contexts to retain after this prune
     * @returns an array of removed entries
     */
    prune(maxContexts) {
        const clampedMax = Math.max(maxContexts, 0); // clamp to [0, infinity)
        if (this.container.index.length > clampedMax) {
            // sort by timestamp so that older timestamps appear first in the array
            this.container.index.sort((a, b) => a.timestamp - b.timestamp);
            // delete the first N many elements above capacity.  splice returns removed elements
            return this.container.index.splice(0, this.container.index.length - clampedMax);
        }
        return [];
    }
}

/**
 * This class handles persisting and loading flag values from a persistent
 * store. It intercepts updates and forwards them to the flag updater and
 * then persists changes after the updater has completed.
 */
class FlagPersistence {
    constructor(_platform, _environmentNamespace, _maxCachedContexts, _flagStore, _flagUpdater, _logger, _timeStamper = () => Date.now()) {
        this._platform = _platform;
        this._environmentNamespace = _environmentNamespace;
        this._maxCachedContexts = _maxCachedContexts;
        this._flagStore = _flagStore;
        this._flagUpdater = _flagUpdater;
        this._logger = _logger;
        this._timeStamper = _timeStamper;
        this._indexKeyPromise = namespaceForContextIndex(this._environmentNamespace);
    }
    /**
     * Inits flag persistence for the provided context with the provided flags.  This will result
     * in the underlying {@link FlagUpdater} switching its active context.
     */
    async init(context, newFlags) {
        this._flagUpdater.init(context, newFlags);
        await this._storeCache(context);
    }
    /**
     * Upserts a flag into the {@link FlagUpdater} and stores that to persistence if the upsert
     * was successful / accepted.  An upsert may be rejected if the provided context is not
     * the active context.
     */
    async upsert(context, key, item) {
        if (this._flagUpdater.upsert(context, key, item)) {
            await this._storeCache(context);
            return true;
        }
        return false;
    }
    /**
     * Loads the flags from persistence for the provided context and gives those to the
     * {@link FlagUpdater} this {@link FlagPersistence} was constructed with.
     */
    async loadCached(context) {
        const storageKey = await namespaceForContextData(this._platform.crypto, this._environmentNamespace, context);
        let flagsJson = await this._platform.storage?.get(storageKey);
        if (flagsJson === null || flagsJson === undefined) {
            // Fallback: in version <10.3.1 flag data was stored under the canonical key, check
            // to see if data is present and migrate the data if present.
            flagsJson = await this._platform.storage?.get(context.canonicalKey);
            if (flagsJson === null || flagsJson === undefined) {
                // return false indicating cache did not load if flag json is still absent
                return false;
            }
            // migrate data from version <10.3.1 and cleanup data that was under canonical key
            await this._platform.storage?.set(storageKey, flagsJson);
            await this._platform.storage?.clear(context.canonicalKey);
        }
        try {
            const flags = JSON.parse(flagsJson);
            // mapping flags to item descriptors
            const descriptors = Object.entries(flags).reduce((acc, [key, flag]) => {
                acc[key] = { version: flag.version, flag };
                return acc;
            }, {});
            this._flagUpdater.initCached(context, descriptors);
            this._logger.debug('Loaded cached flag evaluations from persistent storage');
            return true;
        }
        catch (e) {
            this._logger.warn(`Could not load cached flag evaluations from persistent storage: ${e.message}`);
            return false;
        }
    }
    async _loadIndex() {
        if (this._contextIndex !== undefined) {
            return this._contextIndex;
        }
        const json = await this._platform.storage?.get(await this._indexKeyPromise);
        if (!json) {
            this._contextIndex = new ContextIndex();
            return this._contextIndex;
        }
        try {
            this._contextIndex = ContextIndex.fromJson(json);
            this._logger.debug('Loaded context index from persistent storage');
        }
        catch (e) {
            this._logger.warn(`Could not load index from persistent storage: ${e.message}`);
            this._contextIndex = new ContextIndex();
        }
        return this._contextIndex;
    }
    async _storeCache(context) {
        const index = await this._loadIndex();
        const storageKey = await namespaceForContextData(this._platform.crypto, this._environmentNamespace, context);
        index.notice(storageKey, this._timeStamper());
        const pruned = index.prune(this._maxCachedContexts);
        await Promise.all(pruned.map(async (it) => this._platform.storage?.clear(it.id)));
        // store index
        await this._platform.storage?.set(await this._indexKeyPromise, index.toJson());
        const allFlags = this._flagStore.getAll();
        // mapping item descriptors to flags
        const flags = Object.entries(allFlags).reduce((acc, [key, descriptor]) => {
            if (descriptor.flag !== null && descriptor.flag !== undefined) {
                acc[key] = descriptor.flag;
            }
            return acc;
        }, {});
        const jsonAll = JSON.stringify(flags);
        // store flag data
        await this._platform.storage?.set(storageKey, jsonAll);
    }
}

/**
 * In memory flag store.
 */
class DefaultFlagStore {
    constructor() {
        this._flags = {};
    }
    init(newFlags) {
        this._flags = Object.entries(newFlags).reduce((acc, [key, flag]) => {
            acc[key] = flag;
            return acc;
        }, {});
    }
    insertOrUpdate(key, update) {
        this._flags[key] = update;
    }
    get(key) {
        if (Object.prototype.hasOwnProperty.call(this._flags, key)) {
            return this._flags[key];
        }
        return undefined;
    }
    getAll() {
        return this._flags;
    }
}

function calculateChangedKeys(existingObject, newObject) {
    const changedKeys = [];
    // property deleted or updated
    Object.entries(existingObject).forEach(([k, f]) => {
        const subObject = newObject[k];
        if (!subObject || !jsSdkCommon.fastDeepEqual(f, subObject)) {
            changedKeys.push(k);
        }
    });
    // property added
    Object.keys(newObject).forEach((k) => {
        if (!existingObject[k]) {
            changedKeys.push(k);
        }
    });
    return changedKeys;
}

/**
 * The flag updater handles logic required during the flag update process.
 * It handles versions checking to handle out of order flag updates and
 * also handles flag comparisons for change notification.
 */
class FlagUpdater {
    constructor(flagStore, logger) {
        this._changeCallbacks = new Array();
        this._flagStore = flagStore;
        this._logger = logger;
    }
    init(context, newFlags) {
        this._activeContextKey = context.canonicalKey;
        const oldFlags = this._flagStore.getAll();
        this._flagStore.init(newFlags);
        const changed = calculateChangedKeys(oldFlags, newFlags);
        if (changed.length > 0) {
            this._changeCallbacks.forEach((callback) => {
                try {
                    callback(context, changed, 'init');
                }
                catch (err) {
                    /* intentionally empty */
                }
            });
        }
    }
    initCached(context, newFlags) {
        if (this._activeContextKey === context.canonicalKey) {
            return;
        }
        this.init(context, newFlags);
    }
    upsert(context, key, item) {
        if (this._activeContextKey !== context.canonicalKey) {
            this._logger.warn('Received an update for an inactive context.');
            return false;
        }
        const currentValue = this._flagStore.get(key);
        if (currentValue !== undefined && currentValue.version >= item.version) {
            // this is an out of order update that can be ignored
            return false;
        }
        this._flagStore.insertOrUpdate(key, item);
        this._changeCallbacks.forEach((callback) => {
            try {
                callback(context, [key], 'patch');
            }
            catch (err) {
                /* intentionally empty */
            }
        });
        return true;
    }
    on(callback) {
        this._changeCallbacks.push(callback);
    }
    off(callback) {
        const index = this._changeCallbacks.indexOf(callback);
        if (index > -1) {
            this._changeCallbacks.splice(index, 1);
        }
    }
}

class DefaultFlagManager {
    /**
     * @param platform implementation of various platform provided functionality
     * @param sdkKey that will be used to distinguish different environments
     * @param maxCachedContexts that specifies the max number of contexts that will be cached in persistence
     * @param logger used for logging various messages
     * @param timeStamper exists for testing purposes
     */
    constructor(platform, sdkKey, maxCachedContexts, logger, timeStamper = () => Date.now()) {
        this._flagStore = new DefaultFlagStore();
        this._flagUpdater = new FlagUpdater(this._flagStore, logger);
        this._flagPersistencePromise = this._initPersistence(platform, sdkKey, maxCachedContexts, logger, timeStamper);
    }
    async _initPersistence(platform, sdkKey, maxCachedContexts, logger, timeStamper = () => Date.now()) {
        const environmentNamespace = await namespaceForEnvironment(platform.crypto, sdkKey);
        return new FlagPersistence(platform, environmentNamespace, maxCachedContexts, this._flagStore, this._flagUpdater, logger, timeStamper);
    }
    get(key) {
        return this._flagStore.get(key);
    }
    getAll() {
        return this._flagStore.getAll();
    }
    setBootstrap(context, newFlags) {
        // Bypasses the persistence as we do not want to put these flags into any cache.
        // Generally speaking persistence likely *SHOULD* be disabled when using bootstrap.
        this._flagUpdater.init(context, newFlags);
    }
    async init(context, newFlags) {
        return (await this._flagPersistencePromise).init(context, newFlags);
    }
    async upsert(context, key, item) {
        return (await this._flagPersistencePromise).upsert(context, key, item);
    }
    async loadCached(context) {
        return (await this._flagPersistencePromise).loadCached(context);
    }
    on(callback) {
        this._flagUpdater.on(callback);
    }
    off(callback) {
        this._flagUpdater.off(callback);
    }
}

const UNKNOWN_HOOK_NAME = 'unknown hook';
const BEFORE_EVALUATION_STAGE_NAME = 'beforeEvaluation';
const AFTER_EVALUATION_STAGE_NAME = 'afterEvaluation';
const AFTER_TRACK_STAGE_NAME = 'afterTrack';
function tryExecuteStage(logger, method, hookName, stage, def) {
    try {
        return stage();
    }
    catch (err) {
        logger?.error(`An error was encountered in "${method}" of the "${hookName}" hook: ${err}`);
        return def;
    }
}
function getHookName(logger, hook) {
    try {
        return hook.getMetadata().name || UNKNOWN_HOOK_NAME;
    }
    catch {
        logger.error(`Exception thrown getting metadata for hook. Unable to get hook name.`);
        return UNKNOWN_HOOK_NAME;
    }
}
function executeBeforeEvaluation(logger, hooks, hookContext) {
    return hooks.map((hook) => tryExecuteStage(logger, BEFORE_EVALUATION_STAGE_NAME, getHookName(logger, hook), () => hook?.beforeEvaluation?.(hookContext, {}) ?? {}, {}));
}
function executeAfterEvaluation(logger, hooks, hookContext, updatedData, result) {
    // This iterates in reverse, versus reversing a shallow copy of the hooks,
    // for efficiency.
    for (let hookIndex = hooks.length - 1; hookIndex >= 0; hookIndex -= 1) {
        const hook = hooks[hookIndex];
        const data = updatedData[hookIndex];
        tryExecuteStage(logger, AFTER_EVALUATION_STAGE_NAME, getHookName(logger, hook), () => hook?.afterEvaluation?.(hookContext, data, result) ?? {}, {});
    }
}
function executeBeforeIdentify(logger, hooks, hookContext) {
    return hooks.map((hook) => tryExecuteStage(logger, BEFORE_EVALUATION_STAGE_NAME, getHookName(logger, hook), () => hook?.beforeIdentify?.(hookContext, {}) ?? {}, {}));
}
function executeAfterIdentify(logger, hooks, hookContext, updatedData, result) {
    // This iterates in reverse, versus reversing a shallow copy of the hooks,
    // for efficiency.
    for (let hookIndex = hooks.length - 1; hookIndex >= 0; hookIndex -= 1) {
        const hook = hooks[hookIndex];
        const data = updatedData[hookIndex];
        tryExecuteStage(logger, AFTER_EVALUATION_STAGE_NAME, getHookName(logger, hook), () => hook?.afterIdentify?.(hookContext, data, result) ?? {}, {});
    }
}
function executeAfterTrack(logger, hooks, hookContext) {
    // This iterates in reverse, versus reversing a shallow copy of the hooks,
    // for efficiency.
    for (let hookIndex = hooks.length - 1; hookIndex >= 0; hookIndex -= 1) {
        const hook = hooks[hookIndex];
        tryExecuteStage(logger, AFTER_TRACK_STAGE_NAME, getHookName(logger, hook), () => hook?.afterTrack?.(hookContext), undefined);
    }
}
class HookRunner {
    constructor(_logger, initialHooks) {
        this._logger = _logger;
        this._hooks = [];
        this._hooks.push(...initialHooks);
    }
    withEvaluation(key, context, defaultValue, method) {
        if (this._hooks.length === 0) {
            return method();
        }
        const hooks = [...this._hooks];
        const hookContext = {
            flagKey: key,
            context,
            defaultValue,
        };
        const hookData = executeBeforeEvaluation(this._logger, hooks, hookContext);
        const result = method();
        executeAfterEvaluation(this._logger, hooks, hookContext, hookData, result);
        return result;
    }
    identify(context, timeout) {
        const hooks = [...this._hooks];
        const hookContext = {
            context,
            timeout,
        };
        const hookData = executeBeforeIdentify(this._logger, hooks, hookContext);
        return (result) => {
            executeAfterIdentify(this._logger, hooks, hookContext, hookData, result);
        };
    }
    addHook(hook) {
        this._hooks.push(hook);
    }
    afterTrack(hookContext) {
        if (this._hooks.length === 0) {
            return;
        }
        const hooks = [...this._hooks];
        executeAfterTrack(this._logger, hooks, hookContext);
    }
}

function getInspectorHook(inspectorManager) {
    return {
        getMetadata() {
            return {
                name: 'LaunchDarkly-Inspector-Adapter',
            };
        },
        afterEvaluation: (hookContext, data, detail) => {
            inspectorManager.onFlagUsed(hookContext.flagKey, detail, hookContext.context);
            return data;
        },
        afterIdentify(hookContext, data, _result) {
            inspectorManager.onIdentityChanged(hookContext.context);
            return data;
        },
    };
}

function invalidInspector(type, name) {
    return `an inspector: "${name}" of an invalid type (${type}) was configured`;
}
function inspectorMethodError(type, name) {
    return `an inspector: "${name}" of type: "${type}" generated an exception`;
}

/**
 * Wrap an inspector ensuring that calling its methods are safe.
 * @param inspector Inspector to wrap.
 */
function createSafeInspector(inspector, logger) {
    let errorLogged = false;
    const wrapper = {
        method: (...args) => {
            try {
                // We are proxying arguments here to the underlying method. Typescript doesn't care
                // for this as it cannot validate the parameters are correct, but we are also the caller
                // in this case and will dispatch things with the correct arguments. The dispatch to this
                // will itself happen with a type guard.
                // @ts-ignore
                inspector.method(...args);
            }
            catch {
                // If something goes wrong in an inspector we want to log that something
                // went wrong. We don't want to flood the logs, so we only log something
                // the first time that something goes wrong.
                // We do not include the exception in the log, because we do not know what
                // kind of data it may contain.
                if (!errorLogged) {
                    errorLogged = true;
                    logger.warn(inspectorMethodError(wrapper.type, wrapper.name));
                }
                // Prevent errors.
            }
        },
        type: inspector.type,
        name: inspector.name,
        synchronous: inspector.synchronous,
    };
    return wrapper;
}

const FLAG_USED_TYPE = 'flag-used';
const FLAG_DETAILS_CHANGED_TYPE = 'flag-details-changed';
const FLAG_DETAIL_CHANGED_TYPE = 'flag-detail-changed';
const IDENTITY_CHANGED_TYPE = 'client-identity-changed';
const VALID__TYPES = [
    FLAG_USED_TYPE,
    FLAG_DETAILS_CHANGED_TYPE,
    FLAG_DETAIL_CHANGED_TYPE,
    IDENTITY_CHANGED_TYPE,
];
function validateInspector(inspector, logger) {
    const valid = VALID__TYPES.includes(inspector.type) &&
        inspector.method &&
        typeof inspector.method === 'function';
    if (!valid) {
        logger.warn(invalidInspector(inspector.type, inspector.name));
    }
    return valid;
}
/**
 * Manages dispatching of inspection data to registered inspectors.
 */
class InspectorManager {
    constructor(inspectors, logger) {
        this._safeInspectors = [];
        const validInspectors = inspectors.filter((inspector) => validateInspector(inspector, logger));
        this._safeInspectors = validInspectors.map((inspector) => createSafeInspector(inspector, logger));
    }
    hasInspectors() {
        return this._safeInspectors.length !== 0;
    }
    /**
     * Notify registered inspectors of a flag being used.
     *
     * @param flagKey The key for the flag.
     * @param detail The LDEvaluationDetail for the flag.
     * @param context The LDContext for the flag.
     */
    onFlagUsed(flagKey, detail, context) {
        this._safeInspectors.forEach((inspector) => {
            if (inspector.type === FLAG_USED_TYPE) {
                inspector.method(flagKey, detail, context);
            }
        });
    }
    /**
     * Notify registered inspectors that the flags have been replaced.
     *
     * @param flags The current flags as a Record<string, LDEvaluationDetail>.
     */
    onFlagsChanged(flags) {
        this._safeInspectors.forEach((inspector) => {
            if (inspector.type === FLAG_DETAILS_CHANGED_TYPE) {
                inspector.method(flags);
            }
        });
    }
    /**
     * Notify registered inspectors that a flag value has changed.
     *
     * @param flagKey The key for the flag that changed.
     * @param flag An `LDEvaluationDetail` for the flag.
     */
    onFlagChanged(flagKey, flag) {
        this._safeInspectors.forEach((inspector) => {
            if (inspector.type === FLAG_DETAIL_CHANGED_TYPE) {
                inspector.method(flagKey, flag);
            }
        });
    }
    /**
     * Notify the registered inspectors that the context identity has changed.
     *
     * The notification itself will be dispatched asynchronously.
     *
     * @param context The `LDContext` which is now identified.
     */
    onIdentityChanged(context) {
        this._safeInspectors.forEach((inspector) => {
            if (inspector.type === IDENTITY_CHANGED_TYPE) {
                inspector.method(context);
            }
        });
    }
}

/**
 * Implementation Note: There should not be any default listeners for change events in a client
 * implementation. Default listeners mean a client cannot determine when there are actual
 * application developer provided listeners. If we require default listeners, then we should add
 * a system to allow listeners which have counts independent of the primary listener counts.
 */
class LDEmitter {
    constructor(_logger) {
        this._logger = _logger;
        this._listeners = new Map();
    }
    on(name, listener) {
        if (!this._listeners.has(name)) {
            this._listeners.set(name, [listener]);
        }
        else {
            this._listeners.get(name)?.push(listener);
        }
    }
    /**
     * Unsubscribe one or all events.
     *
     * @param name
     * @param listener Optional. If unspecified, all listeners for the event will be removed.
     */
    off(name, listener) {
        const existingListeners = this._listeners.get(name);
        if (!existingListeners) {
            return;
        }
        if (listener) {
            // remove from internal cache
            const updated = existingListeners.filter((fn) => fn !== listener);
            if (updated.length === 0) {
                this._listeners.delete(name);
            }
            else {
                this._listeners.set(name, updated);
            }
            return;
        }
        // listener was not specified, so remove them all for that event
        this._listeners.delete(name);
    }
    _invokeListener(listener, name, ...detail) {
        try {
            listener(...detail);
        }
        catch (err) {
            this._logger?.error(`Encountered error invoking handler for "${name}", detail: "${err}"`);
        }
    }
    emit(name, ...detail) {
        const listeners = this._listeners.get(name);
        listeners?.forEach((listener) => this._invokeListener(listener, name, ...detail));
    }
    eventNames() {
        return [...this._listeners.keys()];
    }
    listenerCount(name) {
        return this._listeners.get(name)?.length ?? 0;
    }
}

function createPluginEnvironmentMetadata(sdkKey, platform, config) {
    const sdkData = platform.info.sdkData();
    let applicationMetadata;
    if (config.applicationInfo) {
        if (config.applicationInfo.id) {
            applicationMetadata = applicationMetadata ?? {};
            applicationMetadata.id = config.applicationInfo.id;
        }
        if (config.applicationInfo.version) {
            applicationMetadata = applicationMetadata ?? {};
            applicationMetadata.version = config.applicationInfo.version;
        }
        if (config.applicationInfo.name) {
            applicationMetadata = applicationMetadata ?? {};
            applicationMetadata.name = config.applicationInfo.name;
        }
        if (config.applicationInfo.versionName) {
            applicationMetadata = applicationMetadata ?? {};
            applicationMetadata.versionName = config.applicationInfo.versionName;
        }
    }
    const sdkMetadata = {
        name: sdkData.userAgentBase,
        version: sdkData.version,
    };
    if (sdkData.wrapperName) {
        sdkMetadata.wrapperName = sdkData.wrapperName;
    }
    if (sdkData.wrapperVersion) {
        sdkMetadata.wrapperVersion = sdkData.wrapperVersion;
    }
    const environmentMetadata = {
        sdk: sdkMetadata,
        [config.credentialType]: sdkKey,
    };
    if (applicationMetadata) {
        environmentMetadata.application = applicationMetadata;
    }
    return environmentMetadata;
}

const { ClientMessages, ErrorKinds } = jsSdkCommon.internal;
const DEFAULT_IDENTIFY_TIMEOUT_SECONDS = 5;
class LDClientImpl {
    /**
     * Creates the client object synchronously. No async, no network calls.
     */
    constructor(sdkKey, autoEnvAttributes, platform, options, dataManagerFactory, internalOptions) {
        this.sdkKey = sdkKey;
        this.autoEnvAttributes = autoEnvAttributes;
        this.platform = platform;
        this._highTimeoutThreshold = 15;
        this._eventFactoryDefault = new EventFactory(false);
        this._eventFactoryWithReasons = new EventFactory(true);
        this._eventSendingEnabled = false;
        if (!sdkKey) {
            throw new Error('You must configure the client with a client-side SDK key');
        }
        if (!platform.encoding) {
            throw new Error('Platform must implement Encoding because btoa is required.');
        }
        this._config = new ConfigurationImpl(options, internalOptions);
        this.logger = this._config.logger;
        this._baseHeaders = jsSdkCommon.defaultHeaders(this.sdkKey, this.platform.info, this._config.tags, this._config.serviceEndpoints.includeAuthorizationHeader, this._config.userAgentHeaderName);
        this._flagManager = new DefaultFlagManager(this.platform, sdkKey, this._config.maxCachedContexts, this._config.logger);
        this._diagnosticsManager = createDiagnosticsManager(sdkKey, this._config, platform);
        this._eventProcessor = createEventProcessor(sdkKey, this._config, platform, this._baseHeaders, this._diagnosticsManager);
        this.emitter = new LDEmitter();
        this.emitter.on('error', (c, err) => {
            this.logger.error(`error: ${err}, context: ${JSON.stringify(c)}`);
        });
        this._flagManager.on((context, flagKeys, type) => {
            this._handleInspectionChanged(flagKeys, type);
            const ldContext = jsSdkCommon.Context.toLDContext(context);
            this.emitter.emit('change', ldContext, flagKeys);
            flagKeys.forEach((it) => {
                this.emitter.emit(`change:${it}`, ldContext);
            });
        });
        this.dataManager = dataManagerFactory(this._flagManager, this._config, this._baseHeaders, this.emitter, this._diagnosticsManager);
        const hooks = [...this._config.hooks];
        this.environmentMetadata = createPluginEnvironmentMetadata(this.sdkKey, this.platform, this._config);
        this._config.getImplementationHooks(this.environmentMetadata).forEach((hook) => {
            hooks.push(hook);
        });
        this._hookRunner = new HookRunner(this.logger, hooks);
        this._inspectorManager = new InspectorManager(this._config.inspectors, this.logger);
        if (this._inspectorManager.hasInspectors()) {
            this._hookRunner.addHook(getInspectorHook(this._inspectorManager));
        }
    }
    allFlags() {
        // extracting all flag values
        const result = Object.entries(this._flagManager.getAll()).reduce((acc, [key, descriptor]) => {
            if (descriptor.flag !== null && descriptor.flag !== undefined && !descriptor.flag.deleted) {
                acc[key] = descriptor.flag.value;
            }
            return acc;
        }, {});
        return result;
    }
    async close() {
        await this.flush();
        this._eventProcessor?.close();
        this.dataManager.close();
        this.logger.debug('Closed event processor and data source.');
    }
    async flush() {
        try {
            await this._eventProcessor?.flush();
            this.logger.debug('Successfully flushed event processor.');
        }
        catch (e) {
            this.logger.error(`Error flushing event processor: ${e}.`);
            return { error: e, result: false };
        }
        return { result: true };
    }
    getContext() {
        // The LDContext returned here may have been modified by the SDK (for example: adding auto env attributes).
        // We are returning an LDContext here to maintain a consistent represetnation of context to the consuming
        // code.  We are returned the unchecked context so that if a consumer identifies with an invalid context
        // and then calls getContext, they get back the same context they provided, without any assertion about
        // validity.
        return this._uncheckedContext ? jsSdkCommon.clone(this._uncheckedContext) : undefined;
    }
    getInternalContext() {
        return this._checkedContext;
    }
    _createIdentifyPromise(timeout, noTimeout) {
        let res;
        let rej;
        const basePromise = new Promise((resolve, reject) => {
            res = resolve;
            rej = reject;
        });
        if (noTimeout) {
            return { identifyPromise: basePromise, identifyResolve: res, identifyReject: rej };
        }
        const timed = jsSdkCommon.timedPromise(timeout, 'identify');
        const raced = Promise.race([timed, basePromise]).catch((e) => {
            if (e.message.includes('timed out')) {
                this.logger.error(`identify error: ${e}`);
            }
            throw e;
        });
        return { identifyPromise: raced, identifyResolve: res, identifyReject: rej };
    }
    /**
     * Identifies a context to LaunchDarkly. See {@link LDClient.identify}.
     *
     * @param pristineContext The LDContext object to be identified.
     * @param identifyOptions Optional configuration. See {@link LDIdentifyOptions}.
     * @returns A Promise which resolves when the flag values for the specified
     * context are available. It rejects when:
     *
     * 1. The context is unspecified or has no key.
     *
     * 2. The identify timeout is exceeded. In client SDKs this defaults to 5s.
     * You can customize this timeout with {@link LDIdentifyOptions | identifyOptions}.
     *
     * 3. A network error is encountered during initialization.
     */
    async identify(pristineContext, identifyOptions) {
        const identifyTimeout = identifyOptions?.timeout ?? DEFAULT_IDENTIFY_TIMEOUT_SECONDS;
        const noTimeout = identifyOptions?.timeout === undefined && identifyOptions?.noTimeout === true;
        // When noTimeout is specified, and a timeout is not secified, then this condition cannot
        // be encountered. (Our default would need to be greater)
        if (identifyTimeout > this._highTimeoutThreshold) {
            this.logger.warn('The identify function was called with a timeout greater than ' +
                `${this._highTimeoutThreshold} seconds. We recommend a timeout of less than ` +
                `${this._highTimeoutThreshold} seconds.`);
        }
        let context = await ensureKey(pristineContext, this.platform);
        if (this.autoEnvAttributes === jsSdkCommon.AutoEnvAttributes.Enabled) {
            context = await addAutoEnv(context, this.platform, this._config);
        }
        const checkedContext = jsSdkCommon.Context.fromLDContext(context);
        if (!checkedContext.valid) {
            const error = new Error('Context was unspecified or had no key');
            this.emitter.emit('error', context, error);
            return Promise.reject(error);
        }
        this._uncheckedContext = context;
        this._checkedContext = checkedContext;
        this._eventProcessor?.sendEvent(this._eventFactoryDefault.identifyEvent(this._checkedContext));
        const { identifyPromise, identifyResolve, identifyReject } = this._createIdentifyPromise(identifyTimeout, noTimeout);
        this.logger.debug(`Identifying ${JSON.stringify(this._checkedContext)}`);
        const afterIdentify = this._hookRunner.identify(context, identifyOptions?.timeout);
        await this.dataManager.identify(identifyResolve, identifyReject, checkedContext, identifyOptions);
        return identifyPromise.then((res) => {
            afterIdentify({ status: 'completed' });
            return res;
        }, (e) => {
            afterIdentify({ status: 'error' });
            throw e;
        });
    }
    on(eventName, listener) {
        this.emitter.on(eventName, listener);
    }
    off(eventName, listener) {
        this.emitter.off(eventName, listener);
    }
    track(key, data, metricValue) {
        if (!this._checkedContext || !this._checkedContext.valid) {
            this.logger.warn(ClientMessages.MissingContextKeyNoEvent);
            return;
        }
        // 0 is valid, so do not truthy check the metric value
        if (metricValue !== undefined && !jsSdkCommon.TypeValidators.Number.is(metricValue)) {
            this.logger?.warn(ClientMessages.invalidMetricValue(typeof metricValue));
        }
        this._eventProcessor?.sendEvent(this._config.trackEventModifier(this._eventFactoryDefault.customEvent(key, this._checkedContext, data, metricValue)));
        this._hookRunner.afterTrack({
            key,
            // The context is pre-checked above, so we know it can be unwrapped.
            context: this._uncheckedContext,
            data,
            metricValue,
        });
    }
    _variationInternal(flagKey, defaultValue, eventFactory, typeChecker) {
        if (!this._uncheckedContext) {
            this.logger.debug(ClientMessages.MissingContextKeyNoEvent);
            return createErrorEvaluationDetail(ErrorKinds.UserNotSpecified, defaultValue);
        }
        const evalContext = jsSdkCommon.Context.fromLDContext(this._uncheckedContext);
        const foundItem = this._flagManager.get(flagKey);
        if (foundItem === undefined || foundItem.flag.deleted) {
            const defVal = defaultValue ?? null;
            const error = new jsSdkCommon.LDClientError(`Unknown feature flag "${flagKey}"; returning default value ${defVal}.`);
            this.emitter.emit('error', this._uncheckedContext, error);
            this._eventProcessor?.sendEvent(this._eventFactoryDefault.unknownFlagEvent(flagKey, defVal, evalContext));
            return createErrorEvaluationDetail(ErrorKinds.FlagNotFound, defaultValue);
        }
        const { reason, value, variation, prerequisites } = foundItem.flag;
        if (typeChecker) {
            const [matched, type] = typeChecker(value);
            if (!matched) {
                this._eventProcessor?.sendEvent(eventFactory.evalEventClient(flagKey, defaultValue, // track default value on type errors
                defaultValue, foundItem.flag, evalContext, reason));
                const error = new jsSdkCommon.LDClientError(`Wrong type "${type}" for feature flag "${flagKey}"; returning default value`);
                this.emitter.emit('error', this._uncheckedContext, error);
                return createErrorEvaluationDetail(ErrorKinds.WrongType, defaultValue);
            }
        }
        const successDetail = createSuccessEvaluationDetail(value, variation, reason);
        if (value === undefined || value === null) {
            this.logger.debug('Result value is null. Providing default value.');
            successDetail.value = defaultValue;
        }
        prerequisites?.forEach((prereqKey) => {
            this._variationInternal(prereqKey, undefined, this._eventFactoryDefault);
        });
        this._eventProcessor?.sendEvent(eventFactory.evalEventClient(flagKey, value, defaultValue, foundItem.flag, evalContext, reason));
        return successDetail;
    }
    variation(flagKey, defaultValue) {
        const { value } = this._hookRunner.withEvaluation(flagKey, this._uncheckedContext, defaultValue, () => this._variationInternal(flagKey, defaultValue, this._eventFactoryDefault));
        return value;
    }
    variationDetail(flagKey, defaultValue) {
        return this._hookRunner.withEvaluation(flagKey, this._uncheckedContext, defaultValue, () => this._variationInternal(flagKey, defaultValue, this._eventFactoryWithReasons));
    }
    _typedEval(key, defaultValue, eventFactory, typeChecker) {
        return this._hookRunner.withEvaluation(key, this._uncheckedContext, defaultValue, () => this._variationInternal(key, defaultValue, eventFactory, typeChecker));
    }
    boolVariation(key, defaultValue) {
        return this._typedEval(key, defaultValue, this._eventFactoryDefault, (value) => [
            jsSdkCommon.TypeValidators.Boolean.is(value),
            jsSdkCommon.TypeValidators.Boolean.getType(),
        ]).value;
    }
    jsonVariation(key, defaultValue) {
        return this.variation(key, defaultValue);
    }
    numberVariation(key, defaultValue) {
        return this._typedEval(key, defaultValue, this._eventFactoryDefault, (value) => [
            jsSdkCommon.TypeValidators.Number.is(value),
            jsSdkCommon.TypeValidators.Number.getType(),
        ]).value;
    }
    stringVariation(key, defaultValue) {
        return this._typedEval(key, defaultValue, this._eventFactoryDefault, (value) => [
            jsSdkCommon.TypeValidators.String.is(value),
            jsSdkCommon.TypeValidators.String.getType(),
        ]).value;
    }
    boolVariationDetail(key, defaultValue) {
        return this._typedEval(key, defaultValue, this._eventFactoryWithReasons, (value) => [
            jsSdkCommon.TypeValidators.Boolean.is(value),
            jsSdkCommon.TypeValidators.Boolean.getType(),
        ]);
    }
    numberVariationDetail(key, defaultValue) {
        return this._typedEval(key, defaultValue, this._eventFactoryWithReasons, (value) => [
            jsSdkCommon.TypeValidators.Number.is(value),
            jsSdkCommon.TypeValidators.Number.getType(),
        ]);
    }
    stringVariationDetail(key, defaultValue) {
        return this._typedEval(key, defaultValue, this._eventFactoryWithReasons, (value) => [
            jsSdkCommon.TypeValidators.String.is(value),
            jsSdkCommon.TypeValidators.String.getType(),
        ]);
    }
    jsonVariationDetail(key, defaultValue) {
        return this.variationDetail(key, defaultValue);
    }
    addHook(hook) {
        this._hookRunner.addHook(hook);
    }
    /**
     * Enable/Disable event sending.
     * @param enabled True to enable event processing, false to disable.
     * @param flush True to flush while disabling. Useful to flush on certain state transitions.
     */
    setEventSendingEnabled(enabled, flush) {
        if (this._eventSendingEnabled === enabled) {
            return;
        }
        this._eventSendingEnabled = enabled;
        if (enabled) {
            this.logger.debug('Starting event processor');
            this._eventProcessor?.start();
        }
        else if (flush) {
            this.logger?.debug('Flushing event processor before disabling.');
            // Disable and flush.
            this.flush().then(() => {
                // While waiting for the flush event sending could be re-enabled, in which case
                // we do not want to close the event processor.
                if (!this._eventSendingEnabled) {
                    this.logger?.debug('Stopping event processor.');
                    this._eventProcessor?.close();
                }
            });
        }
        else {
            // Just disabled.
            this.logger?.debug('Stopping event processor.');
            this._eventProcessor?.close();
        }
    }
    sendEvent(event) {
        this._eventProcessor?.sendEvent(event);
    }
    _handleInspectionChanged(flagKeys, type) {
        if (!this._inspectorManager.hasInspectors()) {
            return;
        }
        const details = {};
        flagKeys.forEach((flagKey) => {
            const item = this._flagManager.get(flagKey);
            if (item?.flag && !item.flag.deleted) {
                const { reason, value, variation } = item.flag;
                details[flagKey] = createSuccessEvaluationDetail(value, variation, reason);
            }
            else {
                details[flagKey] = {
                    value: undefined,
                    // For backwards compatibility purposes reason and variationIndex are null instead of
                    // being undefined.
                    reason: null,
                    variationIndex: null,
                };
            }
        });
        if (type === 'init') {
            this._inspectorManager.onFlagsChanged(details);
        }
        else if (type === 'patch') {
            Object.entries(details).forEach(([flagKey, detail]) => {
                this._inspectorManager.onFlagChanged(flagKey, detail);
            });
        }
    }
}

class DataSourceEventHandler {
    constructor(_flagManager, _statusManager, _logger) {
        this._flagManager = _flagManager;
        this._statusManager = _statusManager;
        this._logger = _logger;
    }
    async handlePut(context, flags) {
        this._logger.debug(`Got PUT: ${Object.keys(flags)}`);
        // mapping flags to item descriptors
        const descriptors = Object.entries(flags).reduce((acc, [key, flag]) => {
            acc[key] = { version: flag.version, flag };
            return acc;
        }, {});
        await this._flagManager.init(context, descriptors);
        this._statusManager.requestStateUpdate(exports.DataSourceState.Valid);
    }
    async handlePatch(context, patchFlag) {
        this._logger.debug(`Got PATCH ${JSON.stringify(patchFlag, null, 2)}`);
        this._flagManager.upsert(context, patchFlag.key, {
            version: patchFlag.version,
            flag: patchFlag,
        });
    }
    async handleDelete(context, deleteFlag) {
        this._logger.debug(`Got DELETE ${JSON.stringify(deleteFlag, null, 2)}`);
        this._flagManager.upsert(context, deleteFlag.key, {
            version: deleteFlag.version,
            flag: {
                ...deleteFlag,
                deleted: true,
                // props below are set to sensible defaults. they are irrelevant
                // because this flag has been deleted.
                flagVersion: 0,
                value: undefined,
                variation: 0,
                trackEvents: false,
            },
        });
    }
    handleStreamingError(error) {
        this._statusManager.reportError(error.kind, error.message, error.code, error.recoverable);
    }
    handlePollingError(error) {
        this._statusManager.reportError(error.kind, error.message, error.status, error.recoverable);
    }
}

/**
 * Tracks the current data source status and emits updates when the status changes.
 */
class DataSourceStatusManager {
    constructor(_emitter, timeStamper = () => Date.now()) {
        this._emitter = _emitter;
        this._state = exports.DataSourceState.Closed;
        this._stateSinceMillis = timeStamper();
        this._timeStamper = timeStamper;
    }
    get status() {
        return {
            state: this._state,
            stateSince: this._stateSinceMillis,
            lastError: this._errorInfo,
        };
    }
    /**
     * Updates the state of the manager.
     *
     * @param requestedState to track
     * @param isError to indicate that the state update is a result of an error occurring.
     */
    _updateState(requestedState, isError = false) {
        const newState = requestedState === exports.DataSourceState.Interrupted && this._state === exports.DataSourceState.Initializing // don't go to interrupted from initializing (recoverable errors when initializing are not noteworthy)
            ? exports.DataSourceState.Initializing
            : requestedState;
        const changedState = this._state !== newState;
        if (changedState) {
            this._state = newState;
            this._stateSinceMillis = this._timeStamper();
        }
        if (changedState || isError) {
            this._emitter.emit('dataSourceStatus', this.status);
        }
    }
    /**
     * Requests the manager move to the provided state.  This request may be ignored
     * if the current state cannot transition to the requested state.
     * @param state that is requested
     */
    requestStateUpdate(state) {
        this._updateState(state);
    }
    /**
     * Reports a datasource error to this manager. Since the {@link DataSourceStatus} includes error
     * information, it is possible that that a {@link DataSourceStatus} update is emitted with
     * the same {@link DataSourceState}.
     *
     * @param kind of the error
     * @param message for the error
     * @param statusCode of the error if there was one
     * @param recoverable to indicate that the error is anticipated to be recoverable
     */
    reportError(kind, message, statusCode, recoverable = false) {
        const errorInfo = {
            kind,
            message,
            statusCode,
            time: this._timeStamper(),
        };
        this._errorInfo = errorInfo;
        this._updateState(recoverable ? exports.DataSourceState.Interrupted : exports.DataSourceState.Closed, true);
    }
}

/**
 * @internal
 */
class PollingProcessor {
    constructor(_requestor, _pollIntervalSeconds, _dataHandler, _errorHandler, _logger) {
        this._requestor = _requestor;
        this._pollIntervalSeconds = _pollIntervalSeconds;
        this._dataHandler = _dataHandler;
        this._errorHandler = _errorHandler;
        this._logger = _logger;
        this._stopped = false;
    }
    async _poll() {
        if (this._stopped) {
            return;
        }
        const reportJsonError = (data) => {
            this._logger?.error('Polling received invalid data');
            this._logger?.debug(`Invalid JSON follows: ${data}`);
            this._errorHandler?.(new jsSdkCommon.LDPollingError(jsSdkCommon.DataSourceErrorKind.InvalidData, 'Malformed JSON data in polling response'));
        };
        this._logger?.debug('Polling LaunchDarkly for feature flag updates');
        const startTime = Date.now();
        try {
            const res = await this._requestor.requestPayload();
            try {
                const flags = JSON.parse(res);
                try {
                    this._dataHandler?.(flags);
                }
                catch (err) {
                    this._logger?.error(`Exception from data handler: ${err}`);
                }
            }
            catch {
                reportJsonError(res);
            }
        }
        catch (err) {
            const requestError = err;
            if (requestError.status !== undefined) {
                if (!jsSdkCommon.isHttpRecoverable(requestError.status)) {
                    this._logger?.error(jsSdkCommon.httpErrorMessage(err, 'polling request'));
                    this._errorHandler?.(new jsSdkCommon.LDPollingError(jsSdkCommon.DataSourceErrorKind.ErrorResponse, requestError.message, requestError.status));
                    return;
                }
            }
            this._logger?.error(jsSdkCommon.httpErrorMessage(err, 'polling request', 'will retry'));
        }
        const elapsed = Date.now() - startTime;
        const sleepFor = Math.max(this._pollIntervalSeconds * 1000 - elapsed, 0);
        this._logger?.debug('Elapsed: %d ms, sleeping for %d ms', elapsed, sleepFor);
        this._timeoutHandle = setTimeout(() => {
            this._poll();
        }, sleepFor);
    }
    start() {
        this._poll();
    }
    stop() {
        if (this._timeoutHandle) {
            clearTimeout(this._timeoutHandle);
            this._timeoutHandle = undefined;
        }
        this._stopped = true;
    }
    close() {
        this.stop();
    }
}

const reportJsonError = (type, data, logger, errorHandler) => {
    logger?.error(`Stream received invalid data in "${type}" message`);
    logger?.debug(`Invalid JSON follows: ${data}`);
    errorHandler?.(new jsSdkCommon.LDStreamingError(jsSdkCommon.DataSourceErrorKind.InvalidData, 'Malformed JSON data in event stream'));
};
class StreamingProcessor {
    constructor(_plainContextString, _dataSourceConfig, _listeners, _requests, encoding, _pollingRequestor, _diagnosticsManager, _errorHandler, _logger) {
        this._plainContextString = _plainContextString;
        this._dataSourceConfig = _dataSourceConfig;
        this._listeners = _listeners;
        this._requests = _requests;
        this._pollingRequestor = _pollingRequestor;
        this._diagnosticsManager = _diagnosticsManager;
        this._errorHandler = _errorHandler;
        this._logger = _logger;
        let path;
        if (_dataSourceConfig.useReport && !_requests.getEventSourceCapabilities().customMethod) {
            path = _dataSourceConfig.paths.pathPing(encoding, _plainContextString);
        }
        else {
            path = _dataSourceConfig.useReport
                ? _dataSourceConfig.paths.pathReport(encoding, _plainContextString)
                : _dataSourceConfig.paths.pathGet(encoding, _plainContextString);
        }
        const parameters = [
            ...(_dataSourceConfig.queryParameters ?? []),
        ];
        if (this._dataSourceConfig.withReasons) {
            parameters.push({ key: 'withReasons', value: 'true' });
        }
        this._requests = _requests;
        this._headers = { ..._dataSourceConfig.baseHeaders };
        this._logger = _logger;
        this._streamUri = jsSdkCommon.getStreamingUri(_dataSourceConfig.serviceEndpoints, path, parameters);
    }
    _logConnectionStarted() {
        this._connectionAttemptStartTime = Date.now();
    }
    _logConnectionResult(success) {
        if (this._connectionAttemptStartTime && this._diagnosticsManager) {
            this._diagnosticsManager.recordStreamInit(this._connectionAttemptStartTime, !success, Date.now() - this._connectionAttemptStartTime);
        }
        this._connectionAttemptStartTime = undefined;
    }
    /**
     * This is a wrapper around the passed errorHandler which adds additional
     * diagnostics and logging logic.
     *
     * @param err The error to be logged and handled.
     * @return boolean whether to retry the connection.
     *
     * @private
     */
    _retryAndHandleError(err) {
        if (!jsSdkCommon.shouldRetry(err)) {
            this._logConnectionResult(false);
            this._errorHandler?.(new jsSdkCommon.LDStreamingError(jsSdkCommon.DataSourceErrorKind.ErrorResponse, err.message, err.status, false));
            this._logger?.error(jsSdkCommon.httpErrorMessage(err, 'streaming request'));
            return false;
        }
        this._logger?.warn(jsSdkCommon.httpErrorMessage(err, 'streaming request', 'will retry'));
        this._logConnectionResult(false);
        this._logConnectionStarted();
        return true;
    }
    start() {
        this._logConnectionStarted();
        let methodAndBodyOverrides;
        if (this._dataSourceConfig.useReport) {
            // REPORT will include a body, so content type is required.
            this._headers['content-type'] = 'application/json';
            // orverrides default method with REPORT and adds body.
            methodAndBodyOverrides = { method: 'REPORT', body: this._plainContextString };
        }
        else {
            // no method or body override
            methodAndBodyOverrides = {};
        }
        // TLS is handled by the platform implementation.
        const eventSource = this._requests.createEventSource(this._streamUri, {
            headers: this._headers,
            ...methodAndBodyOverrides,
            errorFilter: (error) => this._retryAndHandleError(error),
            initialRetryDelayMillis: this._dataSourceConfig.initialRetryDelayMillis,
            readTimeoutMillis: 5 * 60 * 1000,
            retryResetIntervalMillis: 60 * 1000,
        });
        this._eventSource = eventSource;
        eventSource.onclose = () => {
            this._logger?.info('Closed LaunchDarkly stream connection');
        };
        eventSource.onerror = () => {
            // The work is done by `errorFilter`.
        };
        eventSource.onopen = () => {
            this._logger?.info('Opened LaunchDarkly stream connection');
        };
        eventSource.onretrying = (e) => {
            this._logger?.info(`Will retry stream connection in ${e.delayMillis} milliseconds`);
        };
        this._listeners.forEach(({ deserializeData, processJson }, eventName) => {
            eventSource.addEventListener(eventName, (event) => {
                this._logger?.debug(`Received ${eventName} event`);
                if (event?.data) {
                    this._logConnectionResult(true);
                    const { data } = event;
                    const dataJson = deserializeData(data);
                    if (!dataJson) {
                        reportJsonError(eventName, data, this._logger, this._errorHandler);
                        return;
                    }
                    processJson(dataJson);
                }
                else {
                    this._errorHandler?.(new jsSdkCommon.LDStreamingError(jsSdkCommon.DataSourceErrorKind.InvalidData, 'Unexpected payload from event stream'));
                }
            });
        });
        // here we set up a listener that will poll when ping is received
        eventSource.addEventListener('ping', async () => {
            this._logger?.debug('Got PING, going to poll LaunchDarkly for feature flag updates');
            try {
                const res = await this._pollingRequestor.requestPayload();
                try {
                    const payload = JSON.parse(res);
                    try {
                        // forward the payload on to the PUT listener
                        this._listeners.get('put')?.processJson(payload);
                    }
                    catch (err) {
                        this._logger?.error(`Exception from data handler: ${err}`);
                    }
                }
                catch {
                    this._logger?.error('Polling after ping received invalid data');
                    this._logger?.debug(`Invalid JSON follows: ${res}`);
                    this._errorHandler?.(new jsSdkCommon.LDPollingError(jsSdkCommon.DataSourceErrorKind.InvalidData, 'Malformed JSON data in ping polling response'));
                }
            }
            catch (err) {
                const requestError = err;
                this._errorHandler?.(new jsSdkCommon.LDPollingError(jsSdkCommon.DataSourceErrorKind.ErrorResponse, requestError.message, requestError.status));
            }
        });
    }
    stop() {
        this._eventSource?.close();
        this._eventSource = undefined;
    }
    close() {
        this.stop();
    }
}

class BaseDataManager {
    constructor(platform, flagManager, credential, config, getPollingPaths, getStreamingPaths, baseHeaders, emitter, diagnosticsManager) {
        this.platform = platform;
        this.flagManager = flagManager;
        this.credential = credential;
        this.config = config;
        this.getPollingPaths = getPollingPaths;
        this.getStreamingPaths = getStreamingPaths;
        this.baseHeaders = baseHeaders;
        this.emitter = emitter;
        this.diagnosticsManager = diagnosticsManager;
        this.closed = false;
        this.logger = config.logger;
        this.dataSourceStatusManager = new DataSourceStatusManager(emitter);
        this._dataSourceEventHandler = new DataSourceEventHandler(flagManager, this.dataSourceStatusManager, this.config.logger);
    }
    /**
     * Set additional connection parameters for requests polling/streaming.
     */
    setConnectionParams(connectionParams) {
        this._connectionParams = connectionParams;
    }
    createPollingProcessor(context, checkedContext, requestor, identifyResolve, identifyReject) {
        const processor = new PollingProcessor(requestor, this.config.pollInterval, async (flags) => {
            await this._dataSourceEventHandler.handlePut(checkedContext, flags);
            identifyResolve?.();
        }, (err) => {
            this.emitter.emit('error', context, err);
            this._dataSourceEventHandler.handlePollingError(err);
            identifyReject?.(err);
        }, this.logger);
        this.updateProcessor = this._decorateProcessorWithStatusReporting(processor, this.dataSourceStatusManager);
    }
    createStreamingProcessor(context, checkedContext, pollingRequestor, identifyResolve, identifyReject) {
        const processor = new StreamingProcessor(JSON.stringify(context), {
            credential: this.credential,
            serviceEndpoints: this.config.serviceEndpoints,
            paths: this.getStreamingPaths(),
            baseHeaders: this.baseHeaders,
            initialRetryDelayMillis: this.config.streamInitialReconnectDelay * 1000,
            withReasons: this.config.withReasons,
            useReport: this.config.useReport,
            queryParameters: this._connectionParams?.queryParameters,
        }, this.createStreamListeners(checkedContext, identifyResolve), this.platform.requests, this.platform.encoding, pollingRequestor, this.diagnosticsManager, (e) => {
            this.emitter.emit('error', context, e);
            this._dataSourceEventHandler.handleStreamingError(e);
            identifyReject?.(e);
        }, this.logger);
        this.updateProcessor = this._decorateProcessorWithStatusReporting(processor, this.dataSourceStatusManager);
    }
    createStreamListeners(context, identifyResolve) {
        const listeners = new Map();
        listeners.set('put', {
            deserializeData: JSON.parse,
            processJson: async (flags) => {
                await this._dataSourceEventHandler.handlePut(context, flags);
                identifyResolve?.();
            },
        });
        listeners.set('patch', {
            deserializeData: JSON.parse,
            processJson: async (patchFlag) => {
                this._dataSourceEventHandler.handlePatch(context, patchFlag);
            },
        });
        listeners.set('delete', {
            deserializeData: JSON.parse,
            processJson: async (deleteFlag) => {
                this._dataSourceEventHandler.handleDelete(context, deleteFlag);
            },
        });
        return listeners;
    }
    _decorateProcessorWithStatusReporting(processor, statusManager) {
        return {
            start: () => {
                // update status before starting processor to ensure potential errors are reported after initializing
                statusManager.requestStateUpdate(exports.DataSourceState.Initializing);
                processor.start();
            },
            stop: () => {
                processor.stop();
                statusManager.requestStateUpdate(exports.DataSourceState.Closed);
            },
            close: () => {
                processor.close();
                statusManager.requestStateUpdate(exports.DataSourceState.Closed);
            },
        };
    }
    close() {
        this.updateProcessor?.close();
        this.closed = true;
    }
}

exports.platform = jsSdkCommon__namespace;
exports.BaseDataManager = BaseDataManager;
exports.LDClientImpl = LDClientImpl;
exports.Requestor = Requestor;
exports.makeRequestor = makeRequestor;
Object.keys(jsSdkCommon).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return jsSdkCommon[k]; }
    });
});
//# sourceMappingURL=index.cjs.map
